{"version":3,"sources":["../../../../../../src/webgpu/api/operation/command_buffer/programmable/programmable_state_test.ts"],"names":["unreachable","GPUTest","ProgrammableStateTest","commonBindGroupLayouts","Map","storageTypes","getBindGroupLayout","index","type","has","set","device","createBindGroupLayout","entries","binding","visibility","GPUShaderStage","COMPUTE","FRAGMENT","buffer","get","createBindGroup","layout","resource","setBindGroup","encoder","factory","createBindingStatePipeline","encoderType","groups","algorithm","wgsl","a","b","out","createComputePipeline","createPipelineLayout","bindGroupLayouts","compute","module","createShaderModule","code","entryPoint","wgslShaders","vertex","fragment","createRenderPipeline","targets","format","primitive","topology","setPipeline","pass","pipeline","GPUComputePassEncoder","GPURenderPassEncoder","GPURenderBundleEncoder","dispatchOrDraw","dispatch","draw"],"mappings":"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","sourcesContent":["import { unreachable } from '../../../../../common/util/util.js';\nimport { GPUTest } from '../../../../gpu_test.js';\nimport { EncoderType } from '../../../../util/command_buffer_maker.js';\n\ninterface BindGroupIndices {\n  a: number;\n  b: number;\n  out: number;\n}\n\nexport class ProgrammableStateTest extends GPUTest {\n  private commonBindGroupLayouts: Map<string, GPUBindGroupLayout> = new Map();\n\n  // These types match the shader types in createBindingStatePipeline, below.\n  private storageTypes: ('storage' | 'read-only-storage')[] = [\n    'read-only-storage',\n    'read-only-storage',\n    'storage',\n  ];\n  getBindGroupLayout(index: number): GPUBindGroupLayout {\n    const type = this.storageTypes[index];\n    if (!this.commonBindGroupLayouts.has(type)) {\n      this.commonBindGroupLayouts.set(\n        type,\n        this.device.createBindGroupLayout({\n          entries: [\n            {\n              binding: 0,\n              visibility: GPUShaderStage.COMPUTE | GPUShaderStage.FRAGMENT,\n              buffer: { type },\n            },\n          ],\n        })\n      );\n    }\n    return this.commonBindGroupLayouts.get(type)!;\n  }\n\n  createBindGroup(buffer: GPUBuffer, index: number): GPUBindGroup {\n    return this.device.createBindGroup({\n      layout: this.getBindGroupLayout(index),\n      entries: [{ binding: 0, resource: { buffer } }],\n    });\n  }\n\n  setBindGroup(\n    encoder: GPUProgrammablePassEncoder,\n    index: number,\n    factory: (index: number) => GPUBindGroup\n  ) {\n    encoder.setBindGroup(index, factory(index));\n  }\n\n  // Create a compute pipeline that performs an operation on data from two bind groups,\n  // then writes the result to a third bind group.\n  createBindingStatePipeline<T extends EncoderType>(\n    encoderType: T,\n    groups: BindGroupIndices,\n    algorithm: string = 'a.value - b.value'\n  ): GPUComputePipeline | GPURenderPipeline {\n    switch (encoderType) {\n      case 'compute pass': {\n        const wgsl = `struct Data {\n            value : i32;\n          };\n\n          @group(${groups.a}) @binding(0) var<storage> a : Data;\n          @group(${groups.b}) @binding(0) var<storage> b : Data;\n          @group(${groups.out}) @binding(0) var<storage, read_write> out : Data;\n\n          @stage(compute) @workgroup_size(1) fn main() {\n            out.value = ${algorithm};\n            return;\n          }\n        `;\n\n        return this.device.createComputePipeline({\n          layout: this.device.createPipelineLayout({\n            bindGroupLayouts: [\n              this.getBindGroupLayout(0),\n              this.getBindGroupLayout(1),\n              this.getBindGroupLayout(2),\n            ],\n          }),\n          compute: {\n            module: this.device.createShaderModule({\n              code: wgsl,\n            }),\n            entryPoint: 'main',\n          },\n        });\n      }\n      case 'render pass':\n      case 'render bundle': {\n        const wgslShaders = {\n          vertex: `\n            @stage(vertex) fn vert_main() -> @builtin(position) vec4<f32> {\n              return vec4<f32>(0.5, 0.5, 0.0, 1.0);\n            }\n          `,\n\n          fragment: `\n            struct Data {\n              value : i32;\n            };\n\n            @group(${groups.a}) @binding(0) var<storage> a : Data;\n            @group(${groups.b}) @binding(0) var<storage> b : Data;\n            @group(${groups.out}) @binding(0) var<storage, read_write> out : Data;\n\n            @stage(fragment) fn frag_main() -> @location(0) vec4<f32> {\n              out.value = ${algorithm};\n              return vec4<f32>(1.0, 0.0, 0.0, 1.0);\n            }\n          `,\n        };\n\n        return this.device.createRenderPipeline({\n          layout: this.device.createPipelineLayout({\n            bindGroupLayouts: [\n              this.getBindGroupLayout(0),\n              this.getBindGroupLayout(1),\n              this.getBindGroupLayout(2),\n            ],\n          }),\n          vertex: {\n            module: this.device.createShaderModule({\n              code: wgslShaders.vertex,\n            }),\n            entryPoint: 'vert_main',\n          },\n          fragment: {\n            module: this.device.createShaderModule({\n              code: wgslShaders.fragment,\n            }),\n            entryPoint: 'frag_main',\n            targets: [{ format: 'rgba8unorm' }],\n          },\n          primitive: { topology: 'point-list' },\n        });\n      }\n      default:\n        unreachable();\n    }\n  }\n\n  setPipeline(pass: GPUProgrammablePassEncoder, pipeline: GPUComputePipeline | GPURenderPipeline) {\n    if (pass instanceof GPUComputePassEncoder) {\n      pass.setPipeline(pipeline as GPUComputePipeline);\n    } else if (pass instanceof GPURenderPassEncoder || pass instanceof GPURenderBundleEncoder) {\n      pass.setPipeline(pipeline as GPURenderPipeline);\n    }\n  }\n\n  dispatchOrDraw(pass: GPUProgrammablePassEncoder) {\n    if (pass instanceof GPUComputePassEncoder) {\n      pass.dispatch(1);\n    } else if (pass instanceof GPURenderPassEncoder) {\n      pass.draw(1);\n    } else if (pass instanceof GPURenderBundleEncoder) {\n      pass.draw(1);\n    }\n  }\n}\n"],"file":"programmable_state_test.js"}
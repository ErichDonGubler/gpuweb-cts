{"version":3,"sources":["../../../../../../src/webgpu/api/operation/command_buffer/render/state_tracking.spec.ts"],"names":["description","makeTestGroup","GPUTest","g","test","desc","fn","t","indexBuffer","makeBufferWithContents","Uint16Array","GPUBufferUsage","INDEX","kVertexAttributeSize","kVertexAttributesCount","vertexBuffer","device","createBuffer","usage","VERTEX","size","mappedAtCreation","trackForCleanup","vertexAttributes","getMappedRange","kPositions","kColors","Uint8Array","i","length","baseOffset","vertexPosition","Float32Array","vertexColor","set","lastOffset","lastVertexPosition","lastVertexColor","unmap","renderPipeline","createRenderPipeline","vertex","module","createShaderModule","code","entryPoint","buffers","arrayStride","attributes","format","offset","shaderLocation","fragment","targets","primitive","topology","outputTexture","createTexture","GPUTextureUsage","COPY_SRC","RENDER_ATTACHMENT","encoder","createCommandEncoder","renderPass","beginRenderPass","colorAttachments","view","createView","loadValue","storeOp","setPipeline","setVertexBuffer","setIndexBuffer","drawIndexed","endPass","queue","submit","finish","expectedColor","expectSinglePixelIn2DTexture","x","y","exp"],"mappings":";AAAA;AACA,GADA,OAAO,MAAMA,WAAW,GAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAbO,CAeP,SAASC,aAAT,QAA8B,+CAA9B;AACA,SAASC,OAAT,QAAwB,yBAAxB;;AAEA,OAAO,MAAMC,CAAC,GAAGF,aAAa,CAACC,OAAD,CAAvB;;AAEPC,CAAC,CAACC,IAAF,CAAO,0CAAP;AACGC,IADH;AAEK;AACL;AACA;AACA,CALA;;AAOGC,EAPH,CAOM,MAAMC,CAAN,IAAW;AACb;AACA,QAAMC,WAAW,GAAGD,CAAC,CAACE,sBAAF;AAClB,MAAIC,WAAJ,CAAgB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,CAAhB,CADkB;AAElBC,EAAAA,cAAc,CAACC,KAFG,CAApB;;;AAKA;AACA;AACA,QAAMC,oBAAoB,GAAG,CAA7B;AACA,QAAMC,sBAAsB,GAAG,UAAU,CAAzC;AACA,QAAMC,YAAY,GAAGR,CAAC,CAACS,MAAF,CAASC,YAAT,CAAsB;AACzCC,IAAAA,KAAK,EAAEP,cAAc,CAACQ,MADmB;AAEzCC,IAAAA,IAAI,EAAEP,oBAAoB,GAAGC,sBAFY;AAGzCO,IAAAA,gBAAgB,EAAE,IAHuB,EAAtB,CAArB;;AAKAd,EAAAA,CAAC,CAACe,eAAF,CAAkBP,YAAlB;AACA,QAAMQ,gBAAgB,GAAGR,YAAY,CAACS,cAAb,EAAzB;AACA,QAAMC,UAAU,GAAG,CAAC,CAAC,GAAF,EAAO,CAAC,GAAR,EAAa,GAAb,EAAkB,GAAlB,EAAuB,GAAvB,EAA4B,CAAC,GAA7B,CAAnB;AACA,QAAMC,OAAO,GAAG;AACd,MAAIC,UAAJ,CAAe,CAAC,GAAD,EAAM,CAAN,EAAS,CAAT,EAAY,GAAZ,CAAf,CADc;AAEd,MAAIA,UAAJ,CAAe,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,EAAgB,GAAhB,CAAf,CAFc;AAGd,MAAIA,UAAJ,CAAe,CAAC,CAAD,EAAI,CAAJ,EAAO,GAAP,EAAY,GAAZ,CAAf,CAHc;AAId,MAAIA,UAAJ,CAAe,CAAC,GAAD,EAAM,CAAN,EAAS,GAAT,EAAc,GAAd,CAAf,CAJc;AAKd,MAAIA,UAAJ,CAAe,CAAC,CAAD,EAAI,GAAJ,EAAS,GAAT,EAAc,GAAd,CAAf,CALc;AAMd,MAAIA,UAAJ,CAAe,CAAC,CAAD,EAAI,GAAJ,EAAS,CAAT,EAAY,GAAZ,CAAf,CANc,CAAhB;;AAQA;AACA;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,UAAU,CAACI,MAAX,GAAoB,CAAxC,EAA2C,EAAED,CAA7C,EAAgD;AAC9C,UAAME,UAAU,GAAGjB,oBAAoB,GAAGe,CAA1C;AACA,UAAMG,cAAc,GAAG,IAAIC,YAAJ,CAAiBT,gBAAjB,EAAmCO,UAAnC,EAA+C,CAA/C,CAAvB;AACAC,IAAAA,cAAc,CAAC,CAAD,CAAd,GAAoBN,UAAU,CAACG,CAAD,CAA9B;AACA,UAAMK,WAAW,GAAG,IAAIN,UAAJ,CAAeJ,gBAAf,EAAiCO,UAAU,GAAG,CAA9C,EAAiD,CAAjD,CAApB;AACAG,IAAAA,WAAW,CAACC,GAAZ,CAAgBR,OAAO,CAACE,CAAD,CAAvB;AACD;AACD;AACA,QAAMO,UAAU,GAAGtB,oBAAoB,IAAIC,sBAAsB,GAAG,CAA7B,CAAvC;AACA,QAAMsB,kBAAkB,GAAG,IAAIJ,YAAJ,CAAiBT,gBAAjB,EAAmCY,UAAnC,EAA+C,CAA/C,CAA3B;AACAC,EAAAA,kBAAkB,CAAC,CAAD,CAAlB,GAAwBX,UAAU,CAACA,UAAU,CAACI,MAAX,GAAoB,CAArB,CAAlC;AACA,QAAMQ,eAAe,GAAG,IAAIV,UAAJ,CAAeJ,gBAAf,EAAiCY,UAAU,GAAG,CAA9C,EAAiD,CAAjD,CAAxB;AACAE,EAAAA,eAAe,CAACH,GAAhB,CAAoBR,OAAO,CAACA,OAAO,CAACG,MAAR,GAAiB,CAAlB,CAA3B;;AAEAd,EAAAA,YAAY,CAACuB,KAAb;;AAEA,QAAMC,cAAc,GAAGhC,CAAC,CAACS,MAAF,CAASwB,oBAAT,CAA8B;AACnDC,IAAAA,MAAM,EAAE;AACNC,MAAAA,MAAM,EAAEnC,CAAC,CAACS,MAAF,CAAS2B,kBAAT,CAA4B;AAClCC,QAAAA,IAAI,EAAG;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAjB4C,EAA5B,CADF;;AAoBNC,MAAAA,UAAU,EAAE,MApBN;AAqBNC,MAAAA,OAAO,EAAE;AACP;AACEC,QAAAA,WAAW,EAAElC,oBADf;AAEEmC,QAAAA,UAAU,EAAE;AACV;AACEC,UAAAA,MAAM,EAAE,SADV;AAEEC,UAAAA,MAAM,EAAE,CAFV;AAGEC,UAAAA,cAAc,EAAE,CAHlB,EADU;;AAMV;AACEF,UAAAA,MAAM,EAAE,UADV;AAEEC,UAAAA,MAAM,EAAE,CAFV;AAGEC,UAAAA,cAAc,EAAE,CAHlB,EANU,CAFd,EADO,CArBH,EAD2C;;;;;;AAwCnDC,IAAAA,QAAQ,EAAE;AACRV,MAAAA,MAAM,EAAEnC,CAAC,CAACS,MAAF,CAAS2B,kBAAT,CAA4B;AAClCC,QAAAA,IAAI,EAAG;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,cAR4C,EAA5B,CADA;;AAWRC,MAAAA,UAAU,EAAE,MAXJ;AAYRQ,MAAAA,OAAO,EAAE,CAAC,EAAEJ,MAAM,EAAE,YAAV,EAAD,CAZD,EAxCyC;;AAsDnDK,IAAAA,SAAS,EAAE;AACTC,MAAAA,QAAQ,EAAE,YADD,EAtDwC,EAA9B,CAAvB;;;;AA2DA,QAAMC,aAAa,GAAGjD,CAAC,CAACS,MAAF,CAASyC,aAAT,CAAuB;AAC3CR,IAAAA,MAAM,EAAE,YADmC;AAE3C7B,IAAAA,IAAI,EAAE,CAACK,UAAU,CAACI,MAAX,GAAoB,CAArB,EAAwB,CAAxB,EAA2B,CAA3B,CAFqC;AAG3CX,IAAAA,KAAK,EAAEwC,eAAe,CAACC,QAAhB,GAA2BD,eAAe,CAACE,iBAHP,EAAvB,CAAtB;;;AAMA,QAAMC,OAAO,GAAGtD,CAAC,CAACS,MAAF,CAAS8C,oBAAT,EAAhB;AACA,QAAMC,UAAU,GAAGF,OAAO,CAACG,eAAR,CAAwB;AACzCC,IAAAA,gBAAgB,EAAE;AAChB;AACEC,MAAAA,IAAI,EAAEV,aAAa,CAACW,UAAd,EADR;AAEEC,MAAAA,SAAS,EAAE,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,CAFb;AAGEC,MAAAA,OAAO,EAAE,OAHX,EADgB,CADuB,EAAxB,CAAnB;;;;AASAN,EAAAA,UAAU,CAACO,WAAX,CAAuB/B,cAAvB;AACAwB,EAAAA,UAAU,CAACQ,eAAX,CAA2B,CAA3B,EAA8BxD,YAA9B;;AAEA;AACAgD,EAAAA,UAAU,CAACS,cAAX,CAA0BhE,WAA1B,EAAuC,QAAvC,EAAiD,CAAjD,EAAoD,CAApD;AACAuD,EAAAA,UAAU,CAACU,WAAX,CAAuB,CAAvB;;AAEA;AACAV,EAAAA,UAAU,CAACS,cAAX,CAA0BhE,WAA1B,EAAuC,QAAvC,EAAiD,CAAjD,EAAoD,CAApD;AACAuD,EAAAA,UAAU,CAACU,WAAX,CAAuB,CAAvB;;AAEA;AACAV,EAAAA,UAAU,CAACS,cAAX,CAA0BhE,WAA1B,EAAuC,QAAvC,EAAiD,CAAjD,EAAoD,CAApD;AACAuD,EAAAA,UAAU,CAACS,cAAX,CAA0BhE,WAA1B,EAAuC,QAAvC,EAAiD,CAAjD,EAAoD,CAApD;AACAuD,EAAAA,UAAU,CAACU,WAAX,CAAuB,CAAvB;;AAEA;AACAV,EAAAA,UAAU,CAACS,cAAX,CAA0BhE,WAA1B,EAAuC,QAAvC,EAAiD,CAAjD,EAAoD,CAApD;AACAuD,EAAAA,UAAU,CAACS,cAAX,CAA0BhE,WAA1B,EAAuC,QAAvC,EAAiD,CAAjD,EAAoD,CAApD;AACAuD,EAAAA,UAAU,CAACU,WAAX,CAAuB,CAAvB;;AAEAV,EAAAA,UAAU,CAACW,OAAX;AACAnE,EAAAA,CAAC,CAACoE,KAAF,CAAQC,MAAR,CAAe,CAACf,OAAO,CAACgB,MAAR,EAAD,CAAf;;AAEA,OAAK,IAAIjD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,UAAU,CAACI,MAAX,GAAoB,CAAxC,EAA2C,EAAED,CAA7C,EAAgD;AAC9C,UAAMkD,aAAa,GAAGlD,CAAC,KAAK,CAAN,GAAUF,OAAO,CAACD,UAAU,CAACI,MAAX,GAAoB,CAArB,CAAjB,GAA2CH,OAAO,CAACE,CAAD,CAAxE;AACArB,IAAAA,CAAC,CAACwE,4BAAF;AACEvB,IAAAA,aADF;AAEE,gBAFF;AAGE,MAAEwB,CAAC,EAAEpD,CAAL,EAAQqD,CAAC,EAAE,CAAX,EAHF;AAIE,MAAEC,GAAG,EAAEJ,aAAP,EAJF;;AAMD;AACF,CAhKH","sourcesContent":["export const description = `\nEnsure state is set correctly. Tries to stress state caching (setting different states multiple\ntimes in different orders) for setIndexBuffer and setVertexBuffer.\nEquivalent tests for setBindGroup and setPipeline are in programmable/state_tracking.spec.ts.\nEquivalent tests for viewport/scissor/blend/reference are in render/dynamic_state.spec.ts\n\nTODO: plan and implement\n- try setting states multiple times in different orders, check state is correct in a draw call.\n    - setVertexBuffer: specifically test changing the offset, size, without changing the buffer\n- try changing the pipeline {before,after} the vertex/index buffers.\n  (In D3D12, the vertex buffer stride is part of SetVertexBuffer instead of the pipeline.)\n- Test that drawing after having set vertex buffer slots not used by the pipeline.\n- Test that setting / not setting the index buffer does not impact a non-indexed draw.\n`;\n\nimport { makeTestGroup } from '../../../../../common/framework/test_group.js';\nimport { GPUTest } from '../../../../gpu_test.js';\n\nexport const g = makeTestGroup(GPUTest);\n\ng.test('set_index_buffer_without_changing_buffer')\n  .desc(\n    `\n  Test that setting index buffer states (index format, offset, size) multiple times in different\n  orders still keeps the correctness of each draw call.\n`\n  )\n  .fn(async t => {\n    // Initialize the index buffer with 5 uint16 indices (0, 1, 2, 3, 4).\n    const indexBuffer = t.makeBufferWithContents(\n      new Uint16Array([0, 1, 2, 3, 4]),\n      GPUBufferUsage.INDEX\n    );\n\n    // Initialize the vertex buffer with required vertex attributes (position: f32x2, color: f32x4)\n    // Note that the maximum index in the test is 0x10000.\n    const kVertexAttributeSize = 8;\n    const kVertexAttributesCount = 0x10000 + 1;\n    const vertexBuffer = t.device.createBuffer({\n      usage: GPUBufferUsage.VERTEX,\n      size: kVertexAttributeSize * kVertexAttributesCount,\n      mappedAtCreation: true,\n    });\n    t.trackForCleanup(vertexBuffer);\n    const vertexAttributes = vertexBuffer.getMappedRange();\n    const kPositions = [-0.8, -0.4, 0.0, 0.4, 0.8, -0.4];\n    const kColors = [\n      new Uint8Array([255, 0, 0, 255]),\n      new Uint8Array([255, 255, 255, 255]),\n      new Uint8Array([0, 0, 255, 255]),\n      new Uint8Array([255, 0, 255, 255]),\n      new Uint8Array([0, 255, 255, 255]),\n      new Uint8Array([0, 255, 0, 255]),\n    ];\n    // Set vertex attributes at index {0..4} in Uint16.\n    // Note that the vertex attribute at index 1 will not be used.\n    for (let i = 0; i < kPositions.length - 1; ++i) {\n      const baseOffset = kVertexAttributeSize * i;\n      const vertexPosition = new Float32Array(vertexAttributes, baseOffset, 1);\n      vertexPosition[0] = kPositions[i];\n      const vertexColor = new Uint8Array(vertexAttributes, baseOffset + 4, 4);\n      vertexColor.set(kColors[i]);\n    }\n    // Set vertex attributes at index 0x10000.\n    const lastOffset = kVertexAttributeSize * (kVertexAttributesCount - 1);\n    const lastVertexPosition = new Float32Array(vertexAttributes, lastOffset, 1);\n    lastVertexPosition[0] = kPositions[kPositions.length - 1];\n    const lastVertexColor = new Uint8Array(vertexAttributes, lastOffset + 4, 4);\n    lastVertexColor.set(kColors[kColors.length - 1]);\n\n    vertexBuffer.unmap();\n\n    const renderPipeline = t.device.createRenderPipeline({\n      vertex: {\n        module: t.device.createShaderModule({\n          code: `\n            struct Inputs {\n              [[location(0)]] vertexPosition : f32;\n              [[location(1)]] vertexColor : vec4<f32>;\n            };\n            struct Outputs {\n              [[builtin(position)]] position : vec4<f32>;\n              [[location(0)]] color : vec4<f32>;\n            };\n            [[stage(vertex)]]\n            fn main(input : Inputs)-> Outputs {\n              var outputs : Outputs;\n              outputs.position =\n                vec4<f32>(input.vertexPosition, 0.5, 0.0, 1.0);\n              outputs.color = input.vertexColor;\n              return outputs;\n            }`,\n        }),\n        entryPoint: 'main',\n        buffers: [\n          {\n            arrayStride: kVertexAttributeSize,\n            attributes: [\n              {\n                format: 'float32',\n                offset: 0,\n                shaderLocation: 0,\n              },\n              {\n                format: 'unorm8x4',\n                offset: 4,\n                shaderLocation: 1,\n              },\n            ],\n          },\n        ],\n      },\n      fragment: {\n        module: t.device.createShaderModule({\n          code: `\n            struct Input {\n              [[location(0)]] color : vec4<f32>;\n            };\n            [[stage(fragment)]]\n            fn main(input : Input) -> [[location(0)]] vec4<f32> {\n              return input.color;\n            }`,\n        }),\n        entryPoint: 'main',\n        targets: [{ format: 'rgba8unorm' }],\n      },\n      primitive: {\n        topology: 'point-list',\n      },\n    });\n\n    const outputTexture = t.device.createTexture({\n      format: 'rgba8unorm',\n      size: [kPositions.length - 1, 1, 1],\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    const renderPass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: outputTexture.createView(),\n          loadValue: [0, 0, 0, 1],\n          storeOp: 'store',\n        },\n      ],\n    });\n    renderPass.setPipeline(renderPipeline);\n    renderPass.setVertexBuffer(0, vertexBuffer);\n\n    // 1st draw: indexFormat = 'uint32', offset = 0, size = 4 (index value: 0x10000)\n    renderPass.setIndexBuffer(indexBuffer, 'uint32', 0, 4);\n    renderPass.drawIndexed(1);\n\n    // 2nd draw: indexFormat = 'uint16', offset = 0, size = 4 (index value: 0)\n    renderPass.setIndexBuffer(indexBuffer, 'uint16', 0, 4);\n    renderPass.drawIndexed(1);\n\n    // 3rd draw: indexFormat = 'uint16', offset = 4, size = 2 (index value: 2)\n    renderPass.setIndexBuffer(indexBuffer, 'uint16', 0, 2);\n    renderPass.setIndexBuffer(indexBuffer, 'uint16', 4, 2);\n    renderPass.drawIndexed(1);\n\n    // 4th draw: indexformat = 'uint16', offset = 6, size = 4 (index values: 3, 4)\n    renderPass.setIndexBuffer(indexBuffer, 'uint16', 6, 2);\n    renderPass.setIndexBuffer(indexBuffer, 'uint16', 6, 4);\n    renderPass.drawIndexed(2);\n\n    renderPass.endPass();\n    t.queue.submit([encoder.finish()]);\n\n    for (let i = 0; i < kPositions.length - 1; ++i) {\n      const expectedColor = i === 1 ? kColors[kPositions.length - 1] : kColors[i];\n      t.expectSinglePixelIn2DTexture(\n        outputTexture,\n        'rgba8unorm',\n        { x: i, y: 0 },\n        { exp: expectedColor }\n      );\n    }\n  });\n"],"file":"state_tracking.spec.js"}
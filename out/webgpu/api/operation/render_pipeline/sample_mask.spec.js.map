{"version":3,"file":"sample_mask.spec.js","names":["description","makeTestGroup","assert","GPUTest","TypeF32","TypeU32","makeTextureWithContents","TexelView","kColors","Uint8Array","kDepthClearValue","kDepthWriteValue","kStencilClearValue","kStencilReferenceValue","format","depthStencilFormat","kRenderTargetSize","hasSample","rasterizationMask","sampleMask","fragmentShaderOutputMask","sampleIndex","F","GetTargetTexture","sampleCount","kSampleTextureSize","sampleTexture","device","fromTexelsAsBytes","coord","id","x","y","size","usage","GPUTextureUsage","TEXTURE_BINDING","COPY_DST","RENDER_ATTACHMENT","sampler","createSampler","magFilter","minFilter","fragmentMaskUniformBuffer","createBuffer","GPUBufferUsage","UNIFORM","COPY_SRC","trackForCleanup","queue","writeBuffer","Uint32Array","pipeline","createRenderPipeline","layout","vertex","module","createShaderModule","code","entryPoint","fragment","targets","primitive","topology","multisample","count","mask","alphaToCoverageEnabled","depthStencil","depthWriteEnabled","depthCompare","stencilFront","compare","passOp","stencilBack","uniformBindGroup","createBindGroup","getBindGroupLayout","entries","binding","resource","createView","buffer","renderTargetTexture","createTexture","width","height","depthOrArrayLayers","mipLevelCount","resolveTargetTexture","depthStencilTexture","renderPassDescriptor","colorAttachments","view","resolveTarget","clearValue","r","g","b","a","loadOp","storeOp","depthStencilAttachment","depthClearValue","depthLoadOp","depthStoreOp","stencilClearValue","stencilLoadOp","stencilStoreOp","commandEncoder","createCommandEncoder","passEncoder","beginRenderPass","setPipeline","setBindGroup","setStencilReference","draw","end","submit","finish","color","CheckColorAttachmentResult","texture","copySinglePixelTextureToBufferUsingComputePass","expectedDstData","Float32Array","i","o","expectGPUBufferValuesEqual","CheckDepthStencilResult","aspect","s","test","desc","params","u","combine","expand","p","len","beginSubcases","fn","t"],"sources":["../../../../../src/webgpu/api/operation/render_pipeline/sample_mask.spec.ts"],"sourcesContent":["export const description = `\nTests that the final sample mask is the logical AND of all the relevant masks.\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { assert } from '../../../../common/util/util.js';\nimport { GPUTest } from '../../../gpu_test.js';\nimport { TypeF32, TypeU32 } from '../../../util/conversion.js';\nimport { makeTextureWithContents } from '../../../util/texture.js';\nimport { TexelView } from '../../../util/texture/texel_view.js';\n\nconst kColors = [\n  // Red\n  new Uint8Array([0xff, 0, 0, 0xff]),\n  // Green\n  new Uint8Array([0, 0xff, 0, 0xff]),\n  // Blue\n  new Uint8Array([0, 0, 0xff, 0xff]),\n  // Yellow\n  new Uint8Array([0xff, 0xff, 0, 0xff]),\n];\n\nconst kDepthClearValue = 1.0;\nconst kDepthWriteValue = 0.0;\nconst kStencilClearValue = 0;\nconst kStencilReferenceValue = 0xff;\n\n// Format of the render target and resolve target\nconst format = 'rgba8unorm';\n\n// Format of depth stencil attachment\nconst depthStencilFormat = 'depth24plus-stencil8';\n\nconst kRenderTargetSize = 1;\n\nfunction hasSample(\n  rasterizationMask: number,\n  sampleMask: number,\n  fragmentShaderOutputMask: number,\n  sampleIndex: number = 0\n): boolean {\n  return (rasterizationMask & sampleMask & fragmentShaderOutputMask & (1 << sampleIndex)) > 0;\n}\n\nclass F extends GPUTest {\n  GetTargetTexture(\n    sampleCount: number,\n    rasterizationMask: number,\n    sampleMask: number,\n    fragmentShaderOutputMask: number\n  ): { color: GPUTexture; depthStencil: GPUTexture } {\n    // Create a 2x2 color texture to sample from\n    // texel 0 - Red\n    // texel 1 - Green\n    // texel 2 - Blue\n    // texel 3 - Yellow\n    const kSampleTextureSize = 2;\n    const sampleTexture = makeTextureWithContents(\n      this.device,\n      TexelView.fromTexelsAsBytes(format, coord => {\n        const id = coord.x + coord.y * kSampleTextureSize;\n        return kColors[id];\n      }),\n      {\n        size: [kSampleTextureSize, kSampleTextureSize, 1],\n        usage:\n          GPUTextureUsage.TEXTURE_BINDING |\n          GPUTextureUsage.COPY_DST |\n          GPUTextureUsage.RENDER_ATTACHMENT,\n      }\n    );\n\n    const sampler = this.device.createSampler({\n      magFilter: 'nearest',\n      minFilter: 'nearest',\n    });\n\n    const fragmentMaskUniformBuffer = this.device.createBuffer({\n      size: 4,\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\n    });\n    this.trackForCleanup(fragmentMaskUniformBuffer);\n    this.device.queue.writeBuffer(\n      fragmentMaskUniformBuffer,\n      0,\n      new Uint32Array([fragmentShaderOutputMask])\n    );\n\n    const pipeline = this.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: {\n        module: this.device.createShaderModule({\n          code: `\n          struct VertexOutput {\n            @builtin(position) Position : vec4<f32>,\n            @location(0) @interpolate(perspective, sample) fragUV : vec2<f32>,\n          }\n\n          @vertex\n          fn main(@builtin(vertex_index) VertexIndex : u32) -> VertexOutput {\n            var pos = array<vec2<f32>, 30>(\n                // center quad\n                // only covers pixel center which is sample point when sampleCount === 1\n                // small enough to avoid covering any multi sample points\n                vec2<f32>( 0.2,  0.2),\n                vec2<f32>( 0.2, -0.2),\n                vec2<f32>(-0.2, -0.2),\n                vec2<f32>( 0.2,  0.2),\n                vec2<f32>(-0.2, -0.2),\n                vec2<f32>(-0.2,  0.2),\n\n                // Sub quads are representing rasterization mask and\n                // are slightly scaled to avoid covering the pixel center\n\n                // top-left quad\n                vec2<f32>( -0.01, 1.0),\n                vec2<f32>( -0.01, 0.01),\n                vec2<f32>(-1.0, 0.01),\n                vec2<f32>( -0.01, 1.0),\n                vec2<f32>(-1.0, 0.01),\n                vec2<f32>(-1.0, 1.0),\n\n                // top-right quad\n                vec2<f32>(1.0, 1.0),\n                vec2<f32>(1.0, 0.01),\n                vec2<f32>(0.01, 0.01),\n                vec2<f32>(1.0, 1.0),\n                vec2<f32>(0.01, 0.01),\n                vec2<f32>(0.01, 1.0),\n\n                // bottom-left quad\n                vec2<f32>( -0.01,  -0.01),\n                vec2<f32>( -0.01, -1.0),\n                vec2<f32>(-1.0, -1.0),\n                vec2<f32>( -0.01,  -0.01),\n                vec2<f32>(-1.0, -1.0),\n                vec2<f32>(-1.0,  -0.01),\n\n                // bottom-right quad\n                vec2<f32>(1.0,  -0.01),\n                vec2<f32>(1.0, -1.0),\n                vec2<f32>(0.01, -1.0),\n                vec2<f32>(1.0,  -0.01),\n                vec2<f32>(0.01, -1.0),\n                vec2<f32>(0.01,  -0.01)\n              );\n\n            var uv = array<vec2<f32>, 30>(\n                // center quad\n                vec2<f32>(1.0, 0.0),\n                vec2<f32>(1.0, 1.0),\n                vec2<f32>(0.0, 1.0),\n                vec2<f32>(1.0, 0.0),\n                vec2<f32>(0.0, 1.0),\n                vec2<f32>(0.0, 0.0),\n\n                // top-left quad (texel 0)\n                vec2<f32>(0.5, 0.0),\n                vec2<f32>(0.5, 0.5),\n                vec2<f32>(0.0, 0.5),\n                vec2<f32>(0.5, 0.0),\n                vec2<f32>(0.0, 0.5),\n                vec2<f32>(0.0, 0.0),\n\n                // top-right quad (texel 1)\n                vec2<f32>(1.0, 0.0),\n                vec2<f32>(1.0, 0.5),\n                vec2<f32>(0.5, 0.5),\n                vec2<f32>(1.0, 0.0),\n                vec2<f32>(0.5, 0.5),\n                vec2<f32>(0.5, 0.0),\n\n                // bottom-left quad (texel 2)\n                vec2<f32>(0.5, 0.5),\n                vec2<f32>(0.5, 1.0),\n                vec2<f32>(0.0, 1.0),\n                vec2<f32>(0.5, 0.5),\n                vec2<f32>(0.0, 1.0),\n                vec2<f32>(0.0, 0.5),\n\n                // bottom-right quad (texel 3)\n                vec2<f32>(1.0, 0.5),\n                vec2<f32>(1.0, 1.0),\n                vec2<f32>(0.5, 1.0),\n                vec2<f32>(1.0, 0.5),\n                vec2<f32>(0.5, 1.0),\n                vec2<f32>(0.5, 0.5)\n              );\n\n            var output : VertexOutput;\n            output.Position = vec4<f32>(pos[VertexIndex], ${kDepthWriteValue}, 1.0);\n            output.fragUV = uv[VertexIndex];\n            return output;\n          }`,\n        }),\n        entryPoint: 'main',\n      },\n      fragment: {\n        module: this.device.createShaderModule({\n          code: `\n          @group(0) @binding(0) var mySampler: sampler;\n          @group(0) @binding(1) var myTexture: texture_2d<f32>;\n          @group(0) @binding(2) var<uniform> fragMask: u32;\n\n          struct FragmentOutput {\n            @builtin(sample_mask) mask : u32,\n            @location(0) color : vec4<f32>,\n          }\n\n          @fragment\n          fn main(@location(0) @interpolate(perspective, sample) fragUV: vec2<f32>) -> FragmentOutput {\n            return FragmentOutput(fragMask, textureSample(myTexture, mySampler, fragUV));\n          }`,\n        }),\n        entryPoint: 'main',\n        targets: [{ format }],\n      },\n      primitive: { topology: 'triangle-list' },\n      multisample: {\n        count: sampleCount,\n        mask: sampleMask,\n        alphaToCoverageEnabled: false,\n      },\n      depthStencil: {\n        format: depthStencilFormat,\n        depthWriteEnabled: true,\n        depthCompare: 'always',\n\n        stencilFront: {\n          compare: 'always',\n          passOp: 'replace',\n        },\n        stencilBack: {\n          compare: 'always',\n          passOp: 'replace',\n        },\n      },\n    });\n\n    const uniformBindGroup = this.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        {\n          binding: 0,\n          resource: sampler,\n        },\n        {\n          binding: 1,\n          resource: sampleTexture.createView(),\n        },\n        {\n          binding: 2,\n          resource: {\n            buffer: fragmentMaskUniformBuffer,\n          },\n        },\n      ],\n    });\n\n    const renderTargetTexture = this.device.createTexture({\n      format,\n      size: {\n        width: kRenderTargetSize,\n        height: kRenderTargetSize,\n        depthOrArrayLayers: 1,\n      },\n      sampleCount,\n      mipLevelCount: 1,\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,\n    });\n    const resolveTargetTexture =\n      sampleCount === 1\n        ? null\n        : this.device.createTexture({\n            format,\n            size: {\n              width: kRenderTargetSize,\n              height: kRenderTargetSize,\n              depthOrArrayLayers: 1,\n            },\n            sampleCount: 1,\n            mipLevelCount: 1,\n            usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n          });\n\n    const depthStencilTexture = this.device.createTexture({\n      size: {\n        width: kRenderTargetSize,\n        height: kRenderTargetSize,\n      },\n      format: depthStencilFormat,\n      sampleCount,\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,\n    });\n\n    const renderPassDescriptor: GPURenderPassDescriptor = {\n      colorAttachments: [\n        {\n          view: renderTargetTexture.createView(),\n          resolveTarget: resolveTargetTexture?.createView(),\n\n          clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 0.0 },\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n      depthStencilAttachment: {\n        view: depthStencilTexture.createView(),\n        depthClearValue: kDepthClearValue,\n        depthLoadOp: 'clear',\n        depthStoreOp: 'store',\n        stencilClearValue: kStencilClearValue,\n        stencilLoadOp: 'clear',\n        stencilStoreOp: 'store',\n      },\n    };\n    const commandEncoder = this.device.createCommandEncoder();\n    const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n    passEncoder.setPipeline(pipeline);\n    passEncoder.setBindGroup(0, uniformBindGroup);\n    passEncoder.setStencilReference(kStencilReferenceValue);\n\n    if (sampleCount === 1) {\n      if ((rasterizationMask & 1) !== 0) {\n        // draw center quad\n        passEncoder.draw(6);\n      }\n    } else {\n      assert(sampleCount === 4);\n      if ((rasterizationMask & 1) !== 0) {\n        // draw top-left quad\n        passEncoder.draw(6, 1, 6);\n      }\n      if ((rasterizationMask & 2) !== 0) {\n        // draw top-right quad\n        passEncoder.draw(6, 1, 12);\n      }\n      if ((rasterizationMask & 4) !== 0) {\n        // draw bottom-left quad\n        passEncoder.draw(6, 1, 18);\n      }\n      if ((rasterizationMask & 8) !== 0) {\n        // draw bottom-right quad\n        passEncoder.draw(6, 1, 24);\n      }\n    }\n    passEncoder.end();\n    this.device.queue.submit([commandEncoder.finish()]);\n\n    return {\n      color: renderTargetTexture,\n      depthStencil: depthStencilTexture,\n    };\n  }\n\n  CheckColorAttachmentResult(\n    texture: GPUTexture,\n    sampleCount: number,\n    rasterizationMask: number,\n    sampleMask: number,\n    fragmentShaderOutputMask: number\n  ) {\n    const buffer = this.copySinglePixelTextureToBufferUsingComputePass(\n      TypeF32, // correspond to 'rgba8unorm' format\n      4,\n      texture.createView(),\n      sampleCount\n    );\n\n    const expectedDstData = new Float32Array(sampleCount * 4);\n    if (sampleCount === 1) {\n      if (hasSample(rasterizationMask, sampleMask, fragmentShaderOutputMask)) {\n        // Texel 3 is sampled at the pixel center\n        expectedDstData[0] = kColors[3][0] / 0xff;\n        expectedDstData[1] = kColors[3][1] / 0xff;\n        expectedDstData[2] = kColors[3][2] / 0xff;\n        expectedDstData[3] = kColors[3][3] / 0xff;\n      }\n    } else {\n      for (let i = 0; i < sampleCount; i++) {\n        if (hasSample(rasterizationMask, sampleMask, fragmentShaderOutputMask, i)) {\n          const o = i * 4;\n          expectedDstData[o + 0] = kColors[i][0] / 0xff;\n          expectedDstData[o + 1] = kColors[i][1] / 0xff;\n          expectedDstData[o + 2] = kColors[i][2] / 0xff;\n          expectedDstData[o + 3] = kColors[i][3] / 0xff;\n        }\n      }\n    }\n\n    this.expectGPUBufferValuesEqual(buffer, expectedDstData);\n  }\n\n  CheckDepthStencilResult(\n    aspect: 'depth-only' | 'stencil-only',\n    depthStencilTexture: GPUTexture,\n    sampleCount: number,\n    rasterizationMask: number,\n    sampleMask: number,\n    fragmentShaderOutputMask: number\n  ) {\n    const buffer = this.copySinglePixelTextureToBufferUsingComputePass(\n      // Use f32 as the scalar type for depth (depth24plus, depth32float)\n      // Use u32 as the scalar type for stencil (stencil8)\n      aspect === 'depth-only' ? TypeF32 : TypeU32,\n      1,\n      depthStencilTexture.createView({ aspect }),\n      sampleCount\n    );\n\n    const expectedDstData =\n      aspect === 'depth-only' ? new Float32Array(sampleCount) : new Uint32Array(sampleCount);\n    for (let i = 0; i < sampleCount; i++) {\n      const s = hasSample(rasterizationMask, sampleMask, fragmentShaderOutputMask, i);\n      if (aspect === 'depth-only') {\n        expectedDstData[i] = s ? kDepthWriteValue : kDepthClearValue;\n      } else {\n        expectedDstData[i] = s ? kStencilReferenceValue : kStencilClearValue;\n      }\n    }\n    this.expectGPUBufferValuesEqual(buffer, expectedDstData);\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('final_output')\n  .desc(\n    `\nTests that the final sample mask is the logical AND of all the relevant masks -- meaning that the samples\nnot included in the final mask are discarded on any attachments including\n- color outputs\n- depth tests\n- stencil operations\n\nThe test draws 0/1/1+ textured quads of which each sample in the standard 4-sample pattern results in a different color:\n- Sample 0, Texel 0, top-left: Red\n- Sample 1, Texel 1, top-left: Green\n- Sample 2, Texel 2, top-left: Blue\n- Sample 3, Texel 3, top-left: Yellow\n\nThe test checks each sample value of the render target texture and depth stencil texture using a compute pass to\ntextureLoad each sample index from the texture and write to a storage buffer to compare with expected values.\n\n- for sampleCount = { 1, 4 } and various combinations of:\n    - rasterization mask = { 0, ..., 2 ** sampleCount - 1 }\n    - sample mask = { 0, 0b0001, 0b0010, 0b0111, 0b1011, 0b1101, 0b1110, 0b1111, 0b11110 }\n    - fragment shader output @builtin(sample_mask) = { 0, 0b0001, 0b0010, 0b0111, 0b1011, 0b1101, 0b1110, 0b1111, 0b11110 }\n- [choosing 0b11110 because the 5th bit should be ignored]\n`\n  )\n  .params(u =>\n    u\n      .combine('sampleCount', [1, 4] as const)\n      .expand('rasterizationMask', function* (p) {\n        for (let i = 0, len = 2 ** p.sampleCount - 1; i <= len; i++) {\n          yield i;\n        }\n      })\n      .beginSubcases()\n      .combine('sampleMask', [\n        0,\n        0b0001,\n        0b0010,\n        0b0111,\n        0b1011,\n        0b1101,\n        0b1110,\n        0b1111,\n        0b11110,\n      ] as const)\n      .combine('fragmentShaderOutputMask', [\n        0,\n        0b0001,\n        0b0010,\n        0b0111,\n        0b1011,\n        0b1101,\n        0b1110,\n        0b1111,\n        0b11110,\n      ] as const)\n  )\n  .fn(t => {\n    const { sampleCount, rasterizationMask, sampleMask, fragmentShaderOutputMask } = t.params;\n\n    const { color, depthStencil } = t.GetTargetTexture(\n      sampleCount,\n      rasterizationMask,\n      sampleMask,\n      fragmentShaderOutputMask\n    );\n\n    t.CheckColorAttachmentResult(\n      color,\n      sampleCount,\n      rasterizationMask,\n      sampleMask,\n      fragmentShaderOutputMask\n    );\n\n    t.CheckDepthStencilResult(\n      'depth-only',\n      depthStencil,\n      sampleCount,\n      rasterizationMask,\n      sampleMask,\n      fragmentShaderOutputMask\n    );\n\n    t.CheckDepthStencilResult(\n      'stencil-only',\n      depthStencil,\n      sampleCount,\n      rasterizationMask,\n      sampleMask,\n      fragmentShaderOutputMask\n    );\n  });\n"],"mappings":"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"}
{"version":3,"file":"sample_mask.spec.js","names":["description","makeTestGroup","assert","GPUTest","makeTextureWithContents","TexelView","kColors","R","G","B","A","kEmptySample","format","F","GetResolvedTargetTexture","sampleCount","rasterizationMask","sampleMask","fragmentShaderOutputMask","kSampleTextureSize","sampleTexture","device","fromTexelsAsBytes","coord","id","x","y","Uint8Array","size","usage","GPUTextureUsage","TEXTURE_BINDING","COPY_DST","RENDER_ATTACHMENT","sampler","createSampler","magFilter","minFilter","fragmentMaskUniformBuffer","createBuffer","GPUBufferUsage","UNIFORM","COPY_SRC","trackForCleanup","queue","writeBuffer","Uint32Array","pipeline","createRenderPipeline","layout","vertex","module","createShaderModule","code","entryPoint","fragment","targets","primitive","topology","multisample","count","mask","alphaToCoverageEnabled","uniformBindGroup","createBindGroup","getBindGroupLayout","entries","binding","resource","createView","buffer","kRenderTargetSize","renderTargetTexture","createTexture","width","height","depthOrArrayLayers","mipLevelCount","resolveTargetTexture","renderPassDescriptor","colorAttachments","view","resolveTarget","clearValue","r","g","b","a","loadOp","storeOp","commandEncoder","createCommandEncoder","passEncoder","beginRenderPass","setPipeline","setBindGroup","draw","end","submit","finish","result","CheckSingleSampledResult","texture","expected","expectSingleColor","exp","CheckMultiSampledResult","i","m","s","expectSinglePixelBetweenTwoValuesIn2DTexture","Math","floor","ceil","test","desc","params","u","combine","beginSubcases","fn","t"],"sources":["../../../../../src/webgpu/api/operation/render_pipeline/sample_mask.spec.ts"],"sourcesContent":["export const description = `\nTests that the final sample mask is the logical AND of all the relevant masks.\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { assert } from '../../../../common/util/util.js';\nimport { GPUTest } from '../../../gpu_test.js';\nimport { makeTextureWithContents } from '../../../util/texture.js';\nimport { TexelView } from '../../../util/texture/texel_view.js';\n\nconst kColors = [\n  // Red\n  { R: 0xff, G: 0, B: 0, A: 0xff },\n  // Green\n  { R: 0, G: 0xff, B: 0, A: 0xff },\n  // Blue\n  { R: 0, G: 0, B: 0xff, A: 0xff },\n  // Yellow\n  { R: 0xff, G: 0xff, B: 0, A: 0xff },\n];\n\nconst kEmptySample = { R: 0, G: 0, B: 0, A: 0 };\n\n// Format of the render target and resolve target\nconst format = 'rgba8unorm';\n\nclass F extends GPUTest {\n  async GetResolvedTargetTexture(\n    sampleCount: number,\n    rasterizationMask: number,\n    sampleMask: number,\n    fragmentShaderOutputMask: number\n  ): Promise<GPUTexture> {\n    // Create a 2x2 color texture to sample from\n    // texel 0 - Red\n    // texel 1 - Green\n    // texel 2 - Blue\n    // texel 3 - Yellow\n    const kSampleTextureSize = 2;\n    const sampleTexture = makeTextureWithContents(\n      this.device,\n      TexelView.fromTexelsAsBytes(format, coord => {\n        const id = coord.x + coord.y * kSampleTextureSize;\n        return new Uint8Array([kColors[id].R, kColors[id].G, kColors[id].B, kColors[id].A]);\n      }),\n      {\n        size: [kSampleTextureSize, kSampleTextureSize, 1],\n        usage:\n          GPUTextureUsage.TEXTURE_BINDING |\n          GPUTextureUsage.COPY_DST |\n          GPUTextureUsage.RENDER_ATTACHMENT,\n      }\n    );\n\n    const sampler = this.device.createSampler({\n      magFilter: 'nearest',\n      minFilter: 'nearest',\n    });\n\n    const fragmentMaskUniformBuffer = this.device.createBuffer({\n      size: 4,\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\n    });\n    this.trackForCleanup(fragmentMaskUniformBuffer);\n    this.device.queue.writeBuffer(\n      fragmentMaskUniformBuffer,\n      0,\n      new Uint32Array([fragmentShaderOutputMask])\n    );\n\n    const pipeline = this.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: {\n        module: this.device.createShaderModule({\n          code: `\n          struct VertexOutput {\n            @builtin(position) Position : vec4<f32>,\n            @location(0) @interpolate(perspective, sample) fragUV : vec2<f32>,\n          }\n          \n          @vertex\n          fn main(@builtin(vertex_index) VertexIndex : u32) -> VertexOutput {\n            var pos = array<vec2<f32>, 30>(\n                // full screen quad\n                vec2<f32>( 1.0,  1.0),\n                vec2<f32>( 1.0, -1.0),\n                vec2<f32>(-1.0, -1.0),\n                vec2<f32>( 1.0,  1.0),\n                vec2<f32>(-1.0, -1.0),\n                vec2<f32>(-1.0,  1.0),\n\n                // Sub quads are representing rasterization mask and\n                // are slightly scaled to avoid covering the pixel center\n\n                // top-left quad\n                vec2<f32>( -0.01, 1.0),\n                vec2<f32>( -0.01, 0.01),\n                vec2<f32>(-1.0, 0.01),\n                vec2<f32>( -0.01, 1.0),\n                vec2<f32>(-1.0, 0.01),\n                vec2<f32>(-1.0, 1.0),\n\n                // top-right quad\n                vec2<f32>(1.0, 1.0),\n                vec2<f32>(1.0, 0.01),\n                vec2<f32>(0.01, 0.01),\n                vec2<f32>(1.0, 1.0),\n                vec2<f32>(0.01, 0.01),\n                vec2<f32>(0.01, 1.0),\n\n                // bottom-left quad\n                vec2<f32>( -0.01,  -0.01),\n                vec2<f32>( -0.01, -1.0),\n                vec2<f32>(-1.0, -1.0),\n                vec2<f32>( -0.01,  -0.01),\n                vec2<f32>(-1.0, -1.0),\n                vec2<f32>(-1.0,  -0.01),\n\n                // bottom-right quad\n                vec2<f32>(1.0,  -0.01),\n                vec2<f32>(1.0, -1.0),\n                vec2<f32>(0.01, -1.0),\n                vec2<f32>(1.0,  -0.01),\n                vec2<f32>(0.01, -1.0),\n                vec2<f32>(0.01,  -0.01)\n              );\n          \n            var uv = array<vec2<f32>, 30>(\n                // full screen quad\n                vec2<f32>(1.0, 0.0),\n                vec2<f32>(1.0, 1.0),\n                vec2<f32>(0.0, 1.0),\n                vec2<f32>(1.0, 0.0),\n                vec2<f32>(0.0, 1.0),\n                vec2<f32>(0.0, 0.0),\n\n                // top-left quad (texel 0)\n                vec2<f32>(0.5, 0.0),\n                vec2<f32>(0.5, 0.5),\n                vec2<f32>(0.0, 0.5),\n                vec2<f32>(0.5, 0.0),\n                vec2<f32>(0.0, 0.5),\n                vec2<f32>(0.0, 0.0),\n\n                // top-right quad (texel 1)\n                vec2<f32>(1.0, 0.0),\n                vec2<f32>(1.0, 0.5),\n                vec2<f32>(0.5, 0.5),\n                vec2<f32>(1.0, 0.0),\n                vec2<f32>(0.5, 0.5),\n                vec2<f32>(0.5, 0.0),\n\n                // bottom-left quad (texel 2)\n                vec2<f32>(0.5, 0.5),\n                vec2<f32>(0.5, 1.0),\n                vec2<f32>(0.0, 1.0),\n                vec2<f32>(0.5, 0.5),\n                vec2<f32>(0.0, 1.0),\n                vec2<f32>(0.0, 0.5),\n\n                // bottom-right quad (texel 3)\n                vec2<f32>(1.0, 0.5),\n                vec2<f32>(1.0, 1.0),\n                vec2<f32>(0.5, 1.0),\n                vec2<f32>(1.0, 0.5),\n                vec2<f32>(0.5, 1.0),\n                vec2<f32>(0.5, 0.5)\n              );\n          \n            var output : VertexOutput;\n            output.Position = vec4<f32>(pos[VertexIndex], 0.0, 1.0);\n            output.fragUV = uv[VertexIndex];\n            return output;\n          }`,\n        }),\n        entryPoint: 'main',\n      },\n      fragment: {\n        module: this.device.createShaderModule({\n          code: `\n          @group(0) @binding(0) var mySampler: sampler;\n          @group(0) @binding(1) var myTexture: texture_2d<f32>;\n          @group(0) @binding(2) var<uniform> fragMask: u32;\n\n          struct FragmentOutput {\n            @builtin(sample_mask) mask : u32,\n            @location(0) color : vec4<f32>,\n          }\n          \n          @fragment\n          fn main(@location(0) @interpolate(perspective, sample) fragUV: vec2<f32>) -> FragmentOutput {\n            return FragmentOutput(fragMask, textureSample(myTexture, mySampler, fragUV));\n          }`,\n        }),\n        entryPoint: 'main',\n        targets: [{ format }],\n      },\n      primitive: { topology: 'triangle-list' },\n      multisample: {\n        count: sampleCount,\n        mask: sampleMask,\n        alphaToCoverageEnabled: false,\n      },\n    });\n\n    const uniformBindGroup = this.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n        {\n          binding: 0,\n          resource: sampler,\n        },\n        {\n          binding: 1,\n          resource: sampleTexture.createView(),\n        },\n        {\n          binding: 2,\n          resource: {\n            buffer: fragmentMaskUniformBuffer,\n          },\n        },\n      ],\n    });\n\n    const kRenderTargetSize = 1;\n    const renderTargetTexture = this.device.createTexture({\n      format,\n      size: {\n        width: kRenderTargetSize,\n        height: kRenderTargetSize,\n        depthOrArrayLayers: 1,\n      },\n      sampleCount,\n      mipLevelCount: 1,\n      usage:\n        GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n    const resolveTargetTexture =\n      sampleCount === 1\n        ? null\n        : this.device.createTexture({\n            format,\n            size: {\n              width: kRenderTargetSize,\n              height: kRenderTargetSize,\n              depthOrArrayLayers: 1,\n            },\n            sampleCount: 1,\n            mipLevelCount: 1,\n            usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n          });\n\n    const renderPassDescriptor: GPURenderPassDescriptor = {\n      colorAttachments: [\n        {\n          view: renderTargetTexture.createView(),\n          resolveTarget: resolveTargetTexture?.createView(),\n\n          clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 0.0 },\n          loadOp: 'clear',\n          storeOp: 'store',\n        },\n      ],\n    };\n    const commandEncoder = this.device.createCommandEncoder();\n    const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n    passEncoder.setPipeline(pipeline);\n    passEncoder.setBindGroup(0, uniformBindGroup);\n\n    if (rasterizationMask === 15) {\n      // draw full screen quad\n      passEncoder.draw(6);\n    } else {\n      if ((rasterizationMask & 1) !== 0) {\n        // draw top-left quad\n        passEncoder.draw(6, 1, 6);\n      }\n      if ((rasterizationMask & 2) !== 0) {\n        // draw top-right quad\n        passEncoder.draw(6, 1, 12);\n      }\n      if ((rasterizationMask & 4) !== 0) {\n        // draw bottom-left quad\n        passEncoder.draw(6, 1, 18);\n      }\n      if ((rasterizationMask & 8) !== 0) {\n        // draw bottom-right quad\n        passEncoder.draw(6, 1, 24);\n      }\n    }\n    passEncoder.end();\n    this.device.queue.submit([commandEncoder.finish()]);\n\n    const result = sampleCount === 1 ? renderTargetTexture : resolveTargetTexture;\n    assert(result !== null);\n    return result;\n  }\n\n  CheckSingleSampledResult(\n    texture: GPUTexture,\n    rasterizationMask: number,\n    sampleMask: number,\n    fragmentShaderOutputMask: number\n  ) {\n    let expected: typeof kColors[number] = kEmptySample;\n\n    if (\n      // rasterization needs to cover the center of the pixel\n      (rasterizationMask & 15) >= 15 &&\n      // There is only one sample\n      (fragmentShaderOutputMask & sampleMask & 1) !== 0\n    ) {\n      // When full screen quad is drawn, Texel 3 is sampled at the pixel center\n      expected = kColors[3];\n    }\n\n    this.expectSingleColor(texture, format, {\n      size: [1, 1, 1],\n      exp: {\n        R: expected.R / 0xff,\n        G: expected.G / 0xff,\n        B: expected.B / 0xff,\n        A: expected.A / 0xff,\n      },\n    });\n  }\n\n  CheckMultiSampledResult(\n    texture: GPUTexture,\n    sampleCount: number,\n    rasterizationMask: number,\n    sampleMask: number,\n    fragmentShaderOutputMask: number\n  ) {\n    const expected = {\n      R: 0,\n      G: 0,\n      B: 0,\n      A: 0,\n    };\n\n    assert(sampleCount === 4);\n    for (let i = 0; i < 4; i++) {\n      const m = rasterizationMask & sampleMask & fragmentShaderOutputMask & (1 << i);\n      // WebGPU only support up to 4 samples, so samples after the first 4 should be ignored.\n      const s = (m & 0xf) === 0 ? kEmptySample : kColors[i];\n      expected.R += s.R;\n      expected.G += s.G;\n      expected.B += s.B;\n      expected.A += s.A;\n    }\n\n    this.expectSinglePixelBetweenTwoValuesIn2DTexture(\n      texture,\n      format,\n      { x: 0, y: 0 },\n      {\n        exp: [\n          new Uint8Array([\n            Math.floor(expected.R / sampleCount),\n            Math.floor(expected.G / sampleCount),\n            Math.floor(expected.B / sampleCount),\n            Math.floor(expected.A / sampleCount),\n          ]),\n          new Uint8Array([\n            Math.ceil(expected.R / sampleCount),\n            Math.ceil(expected.G / sampleCount),\n            Math.ceil(expected.B / sampleCount),\n            Math.ceil(expected.A / sampleCount),\n          ]),\n        ],\n      }\n    );\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('final_output')\n  .desc(\n    `\nTests that the final sample mask is the logical AND of all the relevant masks -- meaning that the samples\nnot included in the final mask are discarded on any attachments including\n- color outputs\nTODO:\n- depth tests\n- stencil operations\n\nThe test draws 0/1/1+ textured quads of which each sample in the standard 4-sample pattern results in a different color:\n- Sample 0, Texel 0, top-left: Red\n- Sample 1, Texel 1, top-left: Green\n- Sample 2, Texel 2, top-left: Blue\n- Sample 3, Texel 3, top-left: Yellow\n\nThe test checks which sample is passed by looking at the final color of the 1x1 resolve target texture, to see if that matches\nwhat is expected given by the rasterization mask, sample mask, and fragment shader output mask.\n\n- for sampleCount = { 1, 4 } and various combinations of:\n    - rasterization mask = { 0, 0b0001, 0b0010, 0b0111, 0b1011, 0b1101, 0b1110, 0b1000, 0b1111 }\n    - sample mask = { 0, 0b0001, 0b0010, 0b0111, 0b1011, 0b1101, 0b1110, 0b1111, 0b11110 }\n    - fragment shader output @builtin(sample_mask) = { 0, 0b0001, 0b0010, 0b0111, 0b1011, 0b1101, 0b1110, 0b1111, 0b11110 }\n- [choosing 0b11110 because the 5th bit should be ignored]\n`\n  )\n  .params(u =>\n    u\n      .combine('sampleCount', [1, 4] as const)\n      .combine('rasterizationMask', [\n        0,\n        0b0001,\n        0b0010,\n        0b0111,\n        0b1011,\n        0b1101,\n        0b1110,\n        0b1000,\n        0b1111,\n      ] as const)\n      .beginSubcases()\n      .combine('sampleMask', [\n        0,\n        0b0001,\n        0b0010,\n        0b0111,\n        0b1011,\n        0b1101,\n        0b1110,\n        0b1111,\n        0b11110,\n      ] as const)\n      .combine('fragmentShaderOutputMask', [\n        0,\n        0b0001,\n        0b0010,\n        0b0111,\n        0b1011,\n        0b1101,\n        0b1110,\n        0b1111,\n        0b11110,\n      ] as const)\n  )\n  .fn(async t => {\n    const { sampleCount, rasterizationMask, sampleMask, fragmentShaderOutputMask } = t.params;\n\n    const texture = await t.GetResolvedTargetTexture(\n      sampleCount,\n      rasterizationMask,\n      sampleMask,\n      fragmentShaderOutputMask\n    );\n\n    if (sampleCount === 1) {\n      t.CheckSingleSampledResult(texture, rasterizationMask, sampleMask, fragmentShaderOutputMask);\n    } else {\n      assert(sampleCount === 4);\n      t.CheckMultiSampledResult(\n        texture,\n        sampleCount,\n        rasterizationMask,\n        sampleMask,\n        fragmentShaderOutputMask\n      );\n    }\n  });\n"],"mappings":"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"}
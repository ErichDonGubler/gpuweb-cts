{"version":3,"sources":["../../../../../src/webgpu/api/operation/buffers/map_oom.spec.ts"],"names":["description","kUnitCaseParamsBuilder","makeTestGroup","kBufferUsages","GPUTest","kMaxSafeMultipleOf8","oomAndSizeParams","combine","expand","oom","g","test","desc","params","beginSubcases","fn","t","write","size","buffer","expectGPUError","device","createBuffer","usage","GPUBufferUsage","MAP_WRITE","MAP_READ","promise","mapAsync","GPUMapMode","WRITE","READ","shouldReject","shouldThrow","getMappedRange","unmap","arraybuffer","expect","byteLength","f","mappedAtCreation","mapping"],"mappings":"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","sourcesContent":["export const description =\n  'Test out-of-memory conditions creating large mappable/mappedAtCreation buffers.';\n\nimport { kUnitCaseParamsBuilder } from '../../../../common/framework/params_builder.js';\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { kBufferUsages } from '../../../capability_info.js';\nimport { GPUTest } from '../../../gpu_test.js';\nimport { kMaxSafeMultipleOf8 } from '../../../util/math.js';\n\nconst oomAndSizeParams = kUnitCaseParamsBuilder\n  .combine('oom', [false, true])\n  .expand('size', ({ oom }) => {\n    return oom\n      ? [\n          kMaxSafeMultipleOf8,\n          0x20_0000_0000, // 128 GB\n        ]\n      : [16];\n  });\n\nexport const g = makeTestGroup(GPUTest);\n\ng.test('mapAsync')\n  .desc(\n    `Test creating a large mappable buffer should produce an out-of-memory error if allocation fails.\n  - The resulting buffer is an error buffer, so mapAsync rejects and produces a validation error.\n  - Calling getMappedRange should throw an OperationError because the buffer is not in the mapped state.\n  - unmap() doesn't throw an error even if mapping failed, and otherwise should detach the ArrayBuffer.\n`\n  )\n  .params(\n    oomAndSizeParams //\n      .beginSubcases()\n      .combine('write', [false, true])\n  )\n  .fn(async t => {\n    const { oom, write, size } = t.params;\n\n    const buffer = t.expectGPUError(\n      'out-of-memory',\n      () =>\n        t.device.createBuffer({\n          size,\n          usage: write ? GPUBufferUsage.MAP_WRITE : GPUBufferUsage.MAP_READ,\n        }),\n      oom\n    );\n    const promise = t.expectGPUError(\n      'validation', // Should be a validation error since the buffer is invalid.\n      () => buffer.mapAsync(write ? GPUMapMode.WRITE : GPUMapMode.READ),\n      oom\n    );\n\n    if (oom) {\n      // Should also reject in addition to the validation error.\n      t.shouldReject('OperationError', promise);\n\n      // Should throw an OperationError because the buffer is not mapped.\n      // Note: not a RangeError because the state of the buffer is checked first.\n      t.shouldThrow('OperationError', () => {\n        buffer.getMappedRange();\n      });\n\n      // Should't be a validation error even if the buffer failed to be mapped.\n      buffer.unmap();\n    } else {\n      await promise;\n      const arraybuffer = buffer.getMappedRange();\n      t.expect(arraybuffer.byteLength === size);\n      buffer.unmap();\n      t.expect(arraybuffer.byteLength === 0, 'Mapping should be detached');\n    }\n  });\n\ng.test('mappedAtCreation')\n  .desc(\n    `Test creating a very large buffer mappedAtCreation buffer should throw a RangeError only\n     because such a large allocation cannot be created when we initialize an active buffer mapping.\n`\n  )\n  .params(\n    oomAndSizeParams //\n      .beginSubcases()\n      .combine('usage', kBufferUsages)\n  )\n  .fn(async t => {\n    const { oom, usage, size } = t.params;\n\n    const f = () => t.device.createBuffer({ mappedAtCreation: true, size, usage });\n\n    if (oom) {\n      // getMappedRange is normally valid on OOM buffers, but this one fails because the\n      // (default) range is too large to create the returned ArrayBuffer.\n      t.shouldThrow('RangeError', f);\n    } else {\n      const buffer = f();\n      const mapping = buffer.getMappedRange();\n      t.expect(mapping.byteLength === size, 'Mapping should be successful');\n      buffer.unmap();\n      t.expect(mapping.byteLength === 0, 'Mapping should be detached');\n    }\n  });\n"],"file":"map_oom.spec.js"}
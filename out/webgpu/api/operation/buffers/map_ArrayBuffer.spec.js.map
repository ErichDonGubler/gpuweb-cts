{"version":3,"sources":["../../../../../src/webgpu/api/operation/buffers/map_ArrayBuffer.spec.ts"],"names":["description","makeTestGroup","memcpy","GPUTest","checkElementsEqual","g","test","desc","params","u","combine","fn","t","transfer","mapMode","kSize","buf","device","createBuffer","size","usage","GPUBufferUsage","MAP_WRITE","MAP_READ","mapAsync","GPUMapMode","ab1","getMappedRange","expect","byteLength","initialData","Uint32Array","ArrayBuffer","i","length","src","dst","mc","MessageChannel","ab2Promise","Promise","resolve","port2","onmessage","ev","data","port1","postMessage","undefined","unmap","ab2","ab2Data","expectOK","ab1Data","abs2NewData","slice","reverse"],"mappings":"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","sourcesContent":["export const description = `\nTests for the behavior of ArrayBuffers returned by getMappedRange.\n\nTODO: Add tests that transfer to another thread instead of just using MessageChannel.\nTODO: Add tests for any other Web APIs that can detach ArrayBuffers.\n`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { memcpy } from '../../../../common/util/util.js';\nimport { GPUTest } from '../../../gpu_test.js';\nimport { checkElementsEqual } from '../../../util/check_contents.js';\n\nexport const g = makeTestGroup(GPUTest);\n\ng.test('postMessage')\n  .desc(\n    `Using postMessage to send a getMappedRange-returned ArrayBuffer always make a copy of\n    the ArrayBuffer. It should detach it if it is in the transfer list.\n    Test combinations of transfer={false, true}, mapMode={read,write}.`\n  )\n  .params(u =>\n    u //\n      .combine('transfer', [false, true])\n      .combine('mapMode', ['READ', 'WRITE'] as const)\n  )\n  .fn(async t => {\n    const { transfer, mapMode } = t.params;\n    const kSize = 1024;\n\n    const buf = t.device.createBuffer({\n      size: kSize,\n      usage: mapMode === 'WRITE' ? GPUBufferUsage.MAP_WRITE : GPUBufferUsage.MAP_READ,\n    });\n    await buf.mapAsync(GPUMapMode[mapMode]);\n    let ab1 = buf.getMappedRange();\n    t.expect(ab1.byteLength === kSize, 'ab1 should have the size of the buffer');\n\n    // Populate initial data.\n    const initialData = new Uint32Array(new ArrayBuffer(kSize));\n    for (let i = 0; i < initialData.length; ++i) {\n      initialData[i] = i;\n    }\n    memcpy({ src: initialData }, { dst: ab1 });\n\n    const mc = new MessageChannel();\n    const ab2Promise = new Promise<ArrayBuffer>(resolve => {\n      mc.port2.onmessage = ev => resolve(ev.data);\n    });\n\n    mc.port1.postMessage(ab1, transfer ? [ab1] : undefined);\n    if (transfer) {\n      t.expect(ab1.byteLength === 0, 'after postMessage, ab1 should be detached');\n      // Get the mapped range - again. So we can check that the data is not aliased\n      // with ab2. To do this, we need to unmap to reset the mapping state, and map\n      // again.\n      buf.unmap();\n      await buf.mapAsync(GPUMapMode[mapMode]);\n      ab1 = buf.getMappedRange();\n      t.expect(ab1.byteLength === kSize, 'ab1 should have the size of the buffer');\n    } else {\n      t.expect(ab1.byteLength === kSize, 'after postMessage, ab1 should not be detached');\n    }\n\n    const ab2 = await ab2Promise;\n    t.expect(ab2.byteLength === kSize, 'ab2 should be the same size');\n    const ab2Data = new Uint32Array(ab2, 0, initialData.length);\n    // ab2 should have the same initial contents.\n    t.expectOK(checkElementsEqual(ab2Data, initialData));\n\n    // Mutations to ab2 should not be visible in ab1.\n    const ab1Data = new Uint32Array(ab1, 0, initialData.length);\n    const abs2NewData = initialData.slice().reverse();\n    for (let i = 0; i < ab2Data.length; ++i) {\n      ab2Data[i] = abs2NewData[i];\n    }\n    t.expectOK(checkElementsEqual(ab1Data, initialData));\n    t.expectOK(checkElementsEqual(ab2Data, abs2NewData));\n\n    buf.unmap();\n    t.expect(ab1.byteLength === 0, 'after unmap, ab1 should be detached');\n  });\n"],"file":"map_ArrayBuffer.spec.js"}
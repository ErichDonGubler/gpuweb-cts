{"version":3,"file":"limit_utils.js","names":["kUnitCaseParamsBuilder","makeTestGroup","keysOf","getGPU","assert","kLimitInfo","GPUTestBase","CreatePipelineTypes","createRenderPipeline","createComputePipeline","kCreatePipelineTypes","CreatePipelineAsyncTypes","createRenderPipelineAsync","createComputePipelineAsync","kCreatePipelineAsyncTypes","EncoderTypes","compute","render","renderBundle","kEncoderTypes","TestValue","atLimit","overLimit","kTestValueKeys","getTestValue","limit","testValue","LimitValueTest","atDefault","underDefault","atMaximum","overMaximum","kLimitValueTestKeys","getLimitValue","defaultLimit","maximumLimit","limitValueTest","kLimitBaseParams","combine","beginSubcases","LimitTestsImpl","_device","undefined","device","requestDeviceWithLimits","adapter","requiredLimits","shouldReject","requestDevice","_getDeviceWithRequestedLimit","gpu","requestAdapter","default","limits","Number","isNaN","requestedLimit","actualLimit","expect","testDeviceWithRequestedLimits","limitTest","testValueName","fn","deviceAndLimits","shouldError","pushErrorScope","validationError","popErrorScope","outOfMemoryError","internalError","message","destroy","expectGPUErrorAsync","filter","msg","returnValue","Promise","error","shouldRejectConditionally","expectedName","p","shouldResolve","e","expectValidationError","expectNoValidationError","testForValidationErrorWithPossibleOutOfMemoryError","result","getGroupIndexWGSLForPipelineType","pipelineType","groupIndex","getBindingIndexWGSLForPipelineType","bindingIndex","createPipeline","createPipelineType","module","layout","vertex","entryPoint","createPipelineAsync","createPipelineAsyncType","_getGPUBindingCommandsMixin","encoderType","buffer","createBuffer","size","usage","GPUBufferUsage","UNIFORM","createBindGroupLayout","entries","binding","visibility","GPUShaderStage","COMPUTE","bindGroup","createBindGroup","resource","encoder","createCommandEncoder","mixin","beginComputePass","prep","end","test","finish","cleanup","texture","createTexture","format","GPUTextureUsage","RENDER_ATTACHMENT","VERTEX","beginRenderPass","colorAttachments","view","createView","loadOp","storeOp","createRenderBundleEncoder","colorFormats","testGPUBindingCommandsMixin","makeLimitTestFixture","LimitTests","makeLimitTestGroup","description","g"],"sources":["../../../../../../src/webgpu/api/validation/capability_checks/limits/limit_utils.ts"],"sourcesContent":["import { kUnitCaseParamsBuilder } from '../../../../../common/framework/params_builder.js';\nimport { makeTestGroup } from '../../../../../common/framework/test_group.js';\nimport { keysOf } from '../../../../../common/util/data_tables.js';\nimport { getGPU } from '../../../../../common/util/navigator_gpu.js';\nimport { assert } from '../../../../../common/util/util.js';\nimport { kLimitInfo } from '../../../../capability_info.js';\nimport { GPUTestBase } from '../../../../gpu_test.js';\n\ntype GPUSupportedLimit = keyof GPUSupportedLimits;\n\nconst CreatePipelineTypes = {\n  createRenderPipeline: true,\n  createComputePipeline: true,\n};\nexport type CreatePipelineType = keyof typeof CreatePipelineTypes;\n\nexport const kCreatePipelineTypes = [\n  'createRenderPipeline',\n  'createComputePipeline',\n] as CreatePipelineType[];\n\nconst CreatePipelineAsyncTypes = {\n  createRenderPipelineAsync: true,\n  createComputePipelineAsync: true,\n};\nexport type CreatePipelineAsyncType = keyof typeof CreatePipelineAsyncTypes;\n\nexport const kCreatePipelineAsyncTypes = [\n  'createRenderPipelineAsync',\n  'createComputePipelineAsync',\n] as CreatePipelineAsyncType[];\n\nconst EncoderTypes = {\n  compute: true,\n  render: true,\n  renderBundle: true,\n};\nexport type EncoderType = keyof typeof EncoderTypes;\nexport const kEncoderTypes = keysOf(EncoderTypes);\n\nexport const TestValue = {\n  atLimit: true,\n  overLimit: true,\n};\n\nexport const kTestValueKeys = keysOf(TestValue);\n\nexport function getTestValue(limit: number, testValue: keyof typeof TestValue) {\n  switch (testValue) {\n    case 'atLimit':\n      return limit;\n    case 'overLimit':\n      return limit + 1;\n  }\n}\n\nexport const LimitValueTest = {\n  atDefault: true,\n  underDefault: true,\n  atMaximum: true,\n  overMaximum: true,\n};\nexport const kLimitValueTestKeys = keysOf(LimitValueTest);\n\nfunction getLimitValue(\n  defaultLimit: number,\n  maximumLimit: number,\n  limitValueTest: keyof typeof LimitValueTest\n) {\n  switch (limitValueTest) {\n    case 'atDefault':\n      return defaultLimit;\n    case 'underDefault':\n      return defaultLimit - 1;\n    case 'atMaximum':\n      return maximumLimit;\n    case 'overMaximum':\n      return maximumLimit + 1;\n  }\n}\n\nexport type DeviceAndLimits = {\n  device: GPUDevice;\n  defaultLimit: number;\n  maximumLimit: number;\n  requestedLimit: number;\n  actualLimit: number;\n};\n\nexport type LimitTestInputs = DeviceAndLimits & {\n  testValueName: keyof typeof TestValue;\n  testValue: number;\n  shouldError: boolean;\n};\n\n/**\n * Adds the default parameters to a limit test\n */\nexport const kLimitBaseParams = kUnitCaseParamsBuilder\n  .combine('limitTest', kLimitValueTestKeys)\n  .beginSubcases()\n  .combine('testValueName', kTestValueKeys);\n\nexport class LimitTestsImpl extends GPUTestBase {\n  _device: GPUDevice | undefined = undefined;\n  limit: GPUSupportedLimit = '' as GPUSupportedLimit;\n\n  get device(): GPUDevice {\n    assert(\n      this._device !== undefined,\n      'device is only valid in testDeviceWithRequestedLimits callback'\n    );\n    return this._device;\n  }\n\n  async requestDeviceWithLimits(\n    limitValueTest: keyof typeof LimitValueTest,\n    adapter: GPUAdapter,\n    requiredLimits: Record<string, number>\n  ) {\n    switch (limitValueTest) {\n      case 'overMaximum':\n        this.shouldReject('OperationError', adapter.requestDevice({ requiredLimits }));\n        return undefined;\n      default:\n        return await adapter.requestDevice({ requiredLimits });\n    }\n  }\n\n  /**\n   * Gets a device with the adapter a requested limit and checks that that limit\n   * is correct or that the device failed to create if the requested limit is\n   * beyond the maximum supported by the device.\n   */\n  async _getDeviceWithRequestedLimit(\n    limitValueTest: keyof typeof LimitValueTest\n  ): Promise<DeviceAndLimits | undefined> {\n    const limit = this.limit;\n    const gpu = getGPU();\n    const adapter = await gpu.requestAdapter();\n    assert(!!adapter);\n\n    const defaultLimit = (kLimitInfo as Record<string, { default: number }>)[limit].default;\n    const maximumLimit = adapter.limits[limit] as number;\n    assert(!Number.isNaN(defaultLimit));\n    assert(!Number.isNaN(maximumLimit));\n\n    const requestedLimit = getLimitValue(defaultLimit, maximumLimit, limitValueTest);\n\n    const requiredLimits: Record<string, number> = {};\n    requiredLimits[limit] = requestedLimit;\n\n    const device = await this.requestDeviceWithLimits(limitValueTest, adapter, requiredLimits);\n    const actualLimit = (device ? device.limits[limit] : 0) as number;\n\n    switch (limitValueTest) {\n      case 'atDefault':\n        this.expect(!!device);\n        this.expect(actualLimit === defaultLimit);\n        break;\n      case 'underDefault':\n        this.expect(!!device);\n        this.expect(actualLimit === defaultLimit);\n        break;\n      case 'atMaximum':\n        this.expect(!!device);\n        this.expect(actualLimit === maximumLimit);\n        break;\n      case 'overMaximum':\n        this.expect(!device);\n        break;\n    }\n\n    return device ? { device, defaultLimit, maximumLimit, requestedLimit, actualLimit } : undefined;\n  }\n\n  /**\n   * Creates a device with the requested limits.\n   * If the limit of over the maximum we expect an exception\n   * If the device is created then we call a test function, checking\n   * that the function does not leak any GPU errors.\n   */\n  async testDeviceWithRequestedLimits(\n    limitTest: keyof typeof LimitValueTest,\n    testValueName: keyof typeof TestValue,\n    fn: (inputs: LimitTestInputs) => void | Promise<void>\n  ) {\n    assert(!this._device);\n\n    const deviceAndLimits = await this._getDeviceWithRequestedLimit(limitTest);\n    // If we request over the limit requestDevice will throw\n    if (!deviceAndLimits) {\n      return;\n    }\n\n    const { device, actualLimit } = deviceAndLimits;\n    this._device = device;\n    const testValue = getTestValue(actualLimit, testValueName);\n    const shouldError = testValueName === 'overLimit';\n\n    device.pushErrorScope('internal');\n    device.pushErrorScope('out-of-memory');\n    device.pushErrorScope('validation');\n\n    await fn({ ...deviceAndLimits, testValueName, testValue, shouldError });\n\n    const validationError = await device.popErrorScope();\n    const outOfMemoryError = await device.popErrorScope();\n    const internalError = await device.popErrorScope();\n\n    this.expect(!validationError, validationError?.message || '');\n    this.expect(!outOfMemoryError, outOfMemoryError?.message || '');\n    this.expect(!internalError, internalError?.message || '');\n\n    device.destroy();\n    this._device = undefined;\n  }\n\n  /**\n   * Calls a function that expects a GPU error if shouldError is true\n   */\n  // MAINTENANCE_TODO: Remove this duplicated code with GPUTest if possible\n  async expectGPUErrorAsync<R>(\n    filter: GPUErrorFilter,\n    fn: () => R,\n    shouldError: boolean = true,\n    msg = ''\n  ): Promise<R> {\n    const { device } = this;\n\n    device.pushErrorScope(filter);\n    const returnValue = fn();\n    if (returnValue instanceof Promise) {\n      await returnValue;\n    }\n\n    const error = await device.popErrorScope();\n    this.expect(\n      !!error === shouldError,\n      `${error?.message || 'no error when one was expected'}: ${msg}`\n    );\n\n    return returnValue;\n  }\n\n  /** Expect that the provided promise rejects, with the provided exception name. */\n  async shouldRejectConditionally(\n    expectedName: string,\n    p: Promise<unknown>,\n    shouldReject: boolean,\n    msg?: string\n  ): Promise<void> {\n    if (shouldReject) {\n      this.shouldReject(expectedName, p, msg);\n    } else {\n      this.shouldResolve(p, msg);\n    }\n\n    // We need to explicitly wait for the promise because the device may be\n    // destroyed immediately after returning from this function.\n    try {\n      await p;\n    } catch (e) {\n      //\n    }\n  }\n\n  /**\n   * Calls a function that expects a validation error if shouldError is true\n   */\n  async expectValidationError<R>(fn: () => R, shouldError: boolean = true, msg = ''): Promise<R> {\n    return this.expectGPUErrorAsync('validation', fn, shouldError, msg);\n  }\n\n  /**\n   * Calls a function that expects to not generate a validation error\n   */\n  async expectNoValidationError<R>(fn: () => R, msg = ''): Promise<R> {\n    return this.expectGPUErrorAsync('validation', fn, false, msg);\n  }\n\n  /**\n   * Calls a function that might expect a validation error.\n   * if shouldError is true then expect a validation error,\n   * if shouldError is false then ignore out-of-memory errors.\n   */\n  async testForValidationErrorWithPossibleOutOfMemoryError<R>(\n    fn: () => R,\n    shouldError: boolean = true,\n    msg = ''\n  ): Promise<R> {\n    const { device } = this;\n\n    if (!shouldError) {\n      device.pushErrorScope('out-of-memory');\n      const result = fn();\n      await device.popErrorScope();\n      return result;\n    }\n\n    // Validation should fail before out-of-memory so there is no need to check\n    // for out-of-memory here.\n    device.pushErrorScope('validation');\n    const returnValue = fn();\n    const validationError = await device.popErrorScope();\n\n    this.expect(\n      !!validationError,\n      `${validationError?.message || 'no error when one was expected'}: ${msg}`\n    );\n\n    return returnValue;\n  }\n\n  getGroupIndexWGSLForPipelineType(\n    pipelineType: CreatePipelineType | CreatePipelineAsyncType,\n    groupIndex: number\n  ) {\n    switch (pipelineType) {\n      case 'createRenderPipeline':\n      case 'createRenderPipelineAsync':\n        return `\n          @group(${groupIndex}) @binding(0) var<uniform> v: f32;\n          @vertex fn main() -> @builtin(position) vec4f {\n            return vec4f(v);\n          }\n        `;\n      case 'createComputePipeline':\n      case 'createComputePipelineAsync':\n        return `\n          @group(0) @binding(0) var<storage, read_write> d: f32;\n          @group(${groupIndex}) @binding(0) var<uniform> v: f32;\n          @compute @workgroup_size(1) fn main() {\n            d = v;\n          }\n        `;\n        break;\n    }\n  }\n\n  getBindingIndexWGSLForPipelineType(\n    pipelineType: CreatePipelineType | CreatePipelineAsyncType,\n    bindingIndex: number\n  ) {\n    switch (pipelineType) {\n      case 'createRenderPipeline':\n      case 'createRenderPipelineAsync':\n        return `\n          @group(0) @binding(${bindingIndex}) var<uniform> v: f32;\n          @vertex fn main() -> @builtin(position) vec4f {\n            return vec4f(v);\n          }\n        `;\n      case 'createComputePipeline':\n      case 'createComputePipelineAsync':\n        return `\n          @group(0) @binding(0) var<storage, read_write> d: f32;\n          @group(0) @binding(${bindingIndex}) var<uniform> v: f32;\n          @compute @workgroup_size(1) fn main() {\n            d = v;\n          }\n        `;\n        break;\n    }\n  }\n\n  createPipeline(createPipelineType: CreatePipelineType, module: GPUShaderModule) {\n    const { device } = this;\n\n    switch (createPipelineType) {\n      case 'createRenderPipeline':\n        return device.createRenderPipeline({\n          layout: 'auto',\n          vertex: {\n            module,\n            entryPoint: 'main',\n          },\n        });\n        break;\n      case 'createComputePipeline':\n        return device.createComputePipeline({\n          layout: 'auto',\n          compute: {\n            module,\n            entryPoint: 'main',\n          },\n        });\n        break;\n    }\n  }\n\n  createPipelineAsync(createPipelineAsyncType: CreatePipelineAsyncType, module: GPUShaderModule) {\n    const { device } = this;\n\n    switch (createPipelineAsyncType) {\n      case 'createRenderPipelineAsync':\n        return device.createRenderPipelineAsync({\n          layout: 'auto',\n          vertex: {\n            module,\n            entryPoint: 'main',\n          },\n        });\n      case 'createComputePipelineAsync':\n        return device.createComputePipelineAsync({\n          layout: 'auto',\n          compute: {\n            module,\n            entryPoint: 'main',\n          },\n        });\n    }\n  }\n\n  /**\n   * Creates an encoder that has GPUBindingCommandsMixin\n   */\n  _getGPUBindingCommandsMixin(encoderType: EncoderType) {\n    const { device } = this;\n\n    switch (encoderType) {\n      case 'compute': {\n        const buffer = device.createBuffer({\n          size: 16,\n          usage: GPUBufferUsage.UNIFORM,\n        });\n\n        const layout = device.createBindGroupLayout({\n          entries: [\n            {\n              binding: 0,\n              visibility: GPUShaderStage.COMPUTE,\n              buffer: {},\n            },\n          ],\n        });\n\n        const bindGroup = device.createBindGroup({\n          layout,\n          entries: [\n            {\n              binding: 0,\n              resource: { buffer },\n            },\n          ],\n        });\n\n        const encoder = device.createCommandEncoder();\n        const mixin = encoder.beginComputePass();\n        return {\n          mixin,\n          bindGroup,\n          prep() {\n            mixin.end();\n          },\n          test() {\n            encoder.finish();\n          },\n          cleanup() {\n            buffer.destroy();\n          },\n        };\n        break;\n      }\n\n      case 'render': {\n        const buffer = device.createBuffer({\n          size: 16,\n          usage: GPUBufferUsage.UNIFORM,\n        });\n\n        const texture = device.createTexture({\n          size: [1, 1],\n          format: 'rgba8unorm',\n          usage: GPUTextureUsage.RENDER_ATTACHMENT,\n        });\n\n        const layout = device.createBindGroupLayout({\n          entries: [\n            {\n              binding: 0,\n              visibility: GPUShaderStage.VERTEX,\n              buffer: {},\n            },\n          ],\n        });\n\n        const bindGroup = device.createBindGroup({\n          layout,\n          entries: [\n            {\n              binding: 0,\n              resource: { buffer },\n            },\n          ],\n        });\n\n        const encoder = device.createCommandEncoder();\n        const mixin = encoder.beginRenderPass({\n          colorAttachments: [\n            {\n              view: texture.createView(),\n              loadOp: 'clear',\n              storeOp: 'store',\n            },\n          ],\n        });\n\n        return {\n          mixin,\n          bindGroup,\n          prep() {\n            mixin.end();\n          },\n          test() {\n            encoder.finish();\n          },\n          cleanup() {\n            buffer.destroy();\n            texture.destroy();\n          },\n        };\n        break;\n      }\n\n      case 'renderBundle': {\n        const buffer = device.createBuffer({\n          size: 16,\n          usage: GPUBufferUsage.UNIFORM,\n        });\n\n        const layout = device.createBindGroupLayout({\n          entries: [\n            {\n              binding: 0,\n              visibility: GPUShaderStage.VERTEX,\n              buffer: {},\n            },\n          ],\n        });\n\n        const bindGroup = device.createBindGroup({\n          layout,\n          entries: [\n            {\n              binding: 0,\n              resource: { buffer },\n            },\n          ],\n        });\n\n        const mixin = device.createRenderBundleEncoder({\n          colorFormats: ['rgba8unorm'],\n        });\n\n        return {\n          mixin,\n          bindGroup,\n          prep() {},\n          test() {\n            mixin.finish();\n          },\n          cleanup() {\n            buffer.destroy();\n          },\n        };\n        break;\n      }\n    }\n  }\n\n  /**\n   * Tests a method on GPUBindingCommandsMixin\n   * The function pass will be called with the mixin and a bindGroup\n   */\n  async testGPUBindingCommandsMixin(\n    encoderType: EncoderType,\n    fn: ({ bindGroup }: { mixin: GPUBindingCommandsMixin; bindGroup: GPUBindGroup }) => void,\n    shouldError: boolean,\n    msg = ''\n  ) {\n    const { mixin, bindGroup, prep, test, cleanup } = this._getGPUBindingCommandsMixin(encoderType);\n    fn({ mixin, bindGroup });\n    prep();\n\n    await this.expectValidationError(test, shouldError, msg);\n\n    cleanup();\n  }\n}\n\n/**\n * Makes a new LimitTest class so that the tests have access to `limit`\n */\nfunction makeLimitTestFixture(limit: GPUSupportedLimit): typeof LimitTestsImpl {\n  class LimitTests extends LimitTestsImpl {\n    limit = limit;\n  }\n\n  return LimitTests;\n}\n\n/**\n * This is to avoid repeating yourself (D.R.Y.) as I ran into that issue multiple times\n * writing these tests where I'd copy a test, need to rename a limit in 3-4 places,\n * forget one place, and then spend 20-30 minutes wondering why the test was failing.\n */\nexport function makeLimitTestGroup(limit: GPUSupportedLimit) {\n  const description = `API Validation Tests for ${limit}.`;\n  const g = makeTestGroup(makeLimitTestFixture(limit));\n  return { g, description, limit };\n}\n"],"mappings":"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"}
{"version":3,"sources":["../../../../../../src/webgpu/api/validation/resource_usages/buffer/in_pass_encoder.spec.ts"],"names":["description","makeTestGroup","assert","unreachable","ValidationTest","kBoundBufferSize","F","createBindGroupLayoutForTest","type","resourceVisibility","bindGroupLayoutEntry","binding","visibility","GPUShaderStage","COMPUTE","FRAGMENT","buffer","device","createBindGroupLayout","entries","createBindGroupForTest","offset","createBindGroup","layout","resource","size","beginSimpleRenderPass","encoder","colorTexture","createTexture","format","usage","GPUTextureUsage","RENDER_ATTACHMENT","beginRenderPass","colorAttachments","view","createView","loadOp","storeOp","IsBufferUsageInBindGroup","bufferUsage","g","test","desc","params","u","combine","beginSubcases","unless","t","visibility0","usage0","visibility1","usage1","fn","inSamePass","hasOverlap","UseBufferOnRenderPassEncoder","index","bindGroupVisibility","renderPassEncoder","bindGroup","setBindGroup","setVertexBuffer","setIndexBuffer","renderPipeline","createNoOpRenderPipeline","setPipeline","drawIndirect","indexBuffer","createBuffer","GPUBufferUsage","INDEX","drawIndexedIndirect","createBufferWithState","UNIFORM","STORAGE","VERTEX","INDIRECT","createCommandEncoder","offset0","index0","offset1","index1","end","anotherRenderPassEncoder","fail","expectValidationError","finish","computePassEncoder","beginComputePass","bindGroup0","bindGroup1","filter","usage0AccessibleInDispatch","dispatchBeforeUsage1","usage1AccessibleInDispatch","pipelineLayout","undefined","bindGroupLayout0","createPipelineLayout","bindGroupLayouts","computePipeline","createNoOpComputePipeline","dispatchWorkgroups","dispatchWorkgroupsIndirect","bindGroupIndex","push","bindGroupLayout1","usageHasConflict","UseBufferOnComputePassEncoder","bindGroupLayout","anotherComputePassEncoder"],"mappings":"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","sourcesContent":["export const description = `\nBuffer Usages Validation Tests in Render Pass and Compute Pass.\n`;\n\nimport { makeTestGroup } from '../../../../../common/framework/test_group.js';\nimport { assert, unreachable } from '../../../../../common/util/util.js';\nimport { ValidationTest } from '../../validation_test.js';\n\nconst kBoundBufferSize = 256;\n\nclass F extends ValidationTest {\n  createBindGroupLayoutForTest(\n    type: 'uniform' | 'storage' | 'read-only-storage',\n    resourceVisibility: 'compute' | 'fragment'\n  ): GPUBindGroupLayout {\n    const bindGroupLayoutEntry: GPUBindGroupLayoutEntry = {\n      binding: 0,\n      visibility:\n        resourceVisibility === 'compute' ? GPUShaderStage.COMPUTE : GPUShaderStage.FRAGMENT,\n      buffer: {\n        type,\n      },\n    };\n    return this.device.createBindGroupLayout({\n      entries: [bindGroupLayoutEntry],\n    });\n  }\n\n  createBindGroupForTest(\n    buffer: GPUBuffer,\n    offset: number,\n    type: 'uniform' | 'storage' | 'read-only-storage',\n    resourceVisibility: 'compute' | 'fragment'\n  ): GPUBindGroup {\n    return this.device.createBindGroup({\n      layout: this.createBindGroupLayoutForTest(type, resourceVisibility),\n      entries: [\n        {\n          binding: 0,\n          resource: { buffer, offset, size: kBoundBufferSize },\n        },\n      ],\n    });\n  }\n\n  beginSimpleRenderPass(encoder: GPUCommandEncoder) {\n    const colorTexture = this.device.createTexture({\n      format: 'rgba8unorm',\n      usage: GPUTextureUsage.RENDER_ATTACHMENT,\n      size: [16, 16, 1],\n    });\n    return encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: colorTexture.createView(),\n          loadOp: 'load',\n          storeOp: 'store',\n        },\n      ],\n    });\n  }\n}\n\nfunction IsBufferUsageInBindGroup(\n  bufferUsage:\n    | 'uniform'\n    | 'storage'\n    | 'read-only-storage'\n    | 'vertex'\n    | 'index'\n    | 'indirect'\n    | 'indexedIndirect'\n): boolean {\n  switch (bufferUsage) {\n    case 'uniform':\n    case 'storage':\n    case 'read-only-storage':\n      return true;\n    case 'vertex':\n    case 'index':\n    case 'indirect':\n    case 'indexedIndirect':\n      return false;\n    default:\n      unreachable();\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('subresources,buffer_usage_in_render_pass')\n  .desc(\n    `\nTest that when one buffer is used in one render pass encoder, its list of internal usages within one\nusage scope (all the commands in the whole render pass) can only be a compatible usage list; while\nthere is no such restriction when it is used in different render pass encoders. The usage scope\nrules are not related to the buffer offset or the bind group layout visibilities.`\n  )\n  .params(u =>\n    u\n      .combine('inSamePass', [true, false])\n      .combine('hasOverlap', [true, false])\n      .beginSubcases()\n      .combine('usage0', [\n        'uniform',\n        'storage',\n        'read-only-storage',\n        'vertex',\n        'index',\n        'indirect',\n        'indexedIndirect',\n      ] as const)\n      .combine('visibility0', ['compute', 'fragment'] as const)\n      .unless(t => t.visibility0 === 'compute' && !IsBufferUsageInBindGroup(t.usage0))\n      .combine('usage1', [\n        'uniform',\n        'storage',\n        'read-only-storage',\n        'vertex',\n        'index',\n        'indirect',\n        'indexedIndirect',\n      ] as const)\n      .combine('visibility1', ['compute', 'fragment'] as const)\n      // The situation that the index buffer is reset by another setIndexBuffer call will be tested\n      // in another test case.\n      .unless(\n        t =>\n          (t.visibility1 === 'compute' && !IsBufferUsageInBindGroup(t.usage1)) ||\n          (t.usage0 === 'index' && t.usage1 === 'index')\n      )\n  )\n  .fn(async t => {\n    const { inSamePass, hasOverlap, usage0, visibility0, usage1, visibility1 } = t.params;\n\n    const UseBufferOnRenderPassEncoder = (\n      buffer: GPUBuffer,\n      index: number,\n      offset: number,\n      type:\n        | 'uniform'\n        | 'storage'\n        | 'read-only-storage'\n        | 'vertex'\n        | 'index'\n        | 'indirect'\n        | 'indexedIndirect',\n      bindGroupVisibility: 'compute' | 'fragment',\n      renderPassEncoder: GPURenderPassEncoder\n    ) => {\n      switch (type) {\n        case 'uniform':\n        case 'storage':\n        case 'read-only-storage': {\n          const bindGroup = t.createBindGroupForTest(buffer, offset, type, bindGroupVisibility);\n          renderPassEncoder.setBindGroup(index, bindGroup);\n          break;\n        }\n        case 'vertex': {\n          renderPassEncoder.setVertexBuffer(index, buffer, offset, kBoundBufferSize);\n          break;\n        }\n        case 'index': {\n          renderPassEncoder.setIndexBuffer(buffer, 'uint16', offset, kBoundBufferSize);\n          break;\n        }\n        case 'indirect': {\n          const renderPipeline = t.createNoOpRenderPipeline();\n          renderPassEncoder.setPipeline(renderPipeline);\n          renderPassEncoder.drawIndirect(buffer, offset);\n          break;\n        }\n        case 'indexedIndirect': {\n          const renderPipeline = t.createNoOpRenderPipeline();\n          renderPassEncoder.setPipeline(renderPipeline);\n          const indexBuffer = t.device.createBuffer({\n            size: 4,\n            usage: GPUBufferUsage.INDEX,\n          });\n          renderPassEncoder.setIndexBuffer(indexBuffer, 'uint16');\n          renderPassEncoder.drawIndexedIndirect(buffer, offset);\n          break;\n        }\n      }\n    };\n\n    const buffer = t.createBufferWithState('valid', {\n      size: kBoundBufferSize * 2,\n      usage:\n        GPUBufferUsage.UNIFORM |\n        GPUBufferUsage.STORAGE |\n        GPUBufferUsage.VERTEX |\n        GPUBufferUsage.INDEX |\n        GPUBufferUsage.INDIRECT,\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    const renderPassEncoder = t.beginSimpleRenderPass(encoder);\n    const offset0 = 0;\n    const index0 = 0;\n    UseBufferOnRenderPassEncoder(buffer, index0, offset0, usage0, visibility0, renderPassEncoder);\n    const offset1 = hasOverlap ? offset0 : kBoundBufferSize;\n    const index1 = 1;\n    if (inSamePass) {\n      UseBufferOnRenderPassEncoder(buffer, index1, offset1, usage1, visibility1, renderPassEncoder);\n      renderPassEncoder.end();\n    } else {\n      renderPassEncoder.end();\n      const anotherRenderPassEncoder = t.beginSimpleRenderPass(encoder);\n      UseBufferOnRenderPassEncoder(\n        buffer,\n        index1,\n        offset1,\n        usage1,\n        visibility1,\n        anotherRenderPassEncoder\n      );\n      anotherRenderPassEncoder.end();\n    }\n\n    const fail =\n      inSamePass &&\n      ((usage0 === 'storage' && usage1 !== 'storage') ||\n        (usage0 !== 'storage' && usage1 === 'storage'));\n    t.expectValidationError(() => {\n      encoder.finish();\n    }, fail);\n  });\n\ng.test('subresources,buffer_usage_in_one_compute_pass_with_no_dispatch')\n  .desc(\n    `\nTest that it is always allowed to set multiple bind groups with same buffer in a compute pass\nencoder without any dispatch calls as state-setting compute pass commands, like setBindGroup(index,\nbindGroup, dynamicOffsets), do not contribute directly to a usage scope.`\n  )\n  .params(u =>\n    u\n      .combine('usage0', ['uniform', 'storage', 'read-only-storage'] as const)\n      .combine('usage1', ['uniform', 'storage', 'read-only-storage'] as const)\n      .beginSubcases()\n      .combine('visibility0', ['compute', 'fragment'] as const)\n      .combine('visibility1', ['compute', 'fragment'] as const)\n      .combine('hasOverlap', [true, false])\n  )\n  .fn(async t => {\n    const { usage0, usage1, visibility0, visibility1, hasOverlap } = t.params;\n\n    const buffer = t.createBufferWithState('valid', {\n      size: kBoundBufferSize * 2,\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.STORAGE,\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    const computePassEncoder = encoder.beginComputePass();\n\n    const offset0 = 0;\n    const bindGroup0 = t.createBindGroupForTest(buffer, offset0, usage0, visibility0);\n    computePassEncoder.setBindGroup(0, bindGroup0);\n\n    const offset1 = hasOverlap ? offset0 : kBoundBufferSize;\n    const bindGroup1 = t.createBindGroupForTest(buffer, offset1, usage1, visibility1);\n    computePassEncoder.setBindGroup(1, bindGroup1);\n\n    computePassEncoder.end();\n\n    t.expectValidationError(() => {\n      encoder.finish();\n    }, false);\n  });\n\ng.test('subresources,buffer_usage_in_one_compute_pass_with_one_dispatch')\n  .desc(\n    `\nTest that when one buffer is used in one compute pass encoder, its list of internal usages within\none usage scope can only be a compatible usage list. According to WebGPU SPEC, within one dispatch,\nfor each bind group slot that is used by the current GPUComputePipeline's layout, every subresource\nreferenced by that bind group is \"used\" in the usage scope. `\n  )\n  .params(u =>\n    u\n      .combine('usage0AccessibleInDispatch', [true, false])\n      .combine('usage1AccessibleInDispatch', [true, false])\n      .combine('dispatchBeforeUsage1', [true, false])\n      .beginSubcases()\n      .combine('usage0', ['uniform', 'storage', 'read-only-storage', 'indirect'] as const)\n      .combine('visibility0', ['compute', 'fragment'] as const)\n      .filter(t => {\n        // The buffer with `indirect` usage is always accessible in the dispatch call.\n        if (\n          t.usage0 === 'indirect' &&\n          (!t.usage0AccessibleInDispatch || t.visibility0 !== 'compute' || !t.dispatchBeforeUsage1)\n        ) {\n          return false;\n        }\n        if (t.usage0AccessibleInDispatch && t.visibility0 !== 'compute') {\n          return false;\n        }\n        if (t.dispatchBeforeUsage1 && t.usage1AccessibleInDispatch) {\n          return false;\n        }\n        return true;\n      })\n      .combine('usage1', ['uniform', 'storage', 'read-only-storage', 'indirect'] as const)\n      .combine('visibility1', ['compute', 'fragment'] as const)\n      .filter(t => {\n        if (\n          t.usage1 === 'indirect' &&\n          (!t.usage1AccessibleInDispatch || t.visibility1 !== 'compute' || t.dispatchBeforeUsage1)\n        ) {\n          return false;\n        }\n        // When the first buffer usage is `indirect`, there has already been one dispatch call, so\n        // in this test we always make the second usage inaccessible in the dispatch call.\n        if (\n          t.usage1AccessibleInDispatch &&\n          (t.visibility1 !== 'compute' || t.usage0 === 'indirect')\n        ) {\n          return false;\n        }\n        return true;\n      })\n      .combine('hasOverlap', [true, false])\n  )\n  .fn(async t => {\n    const {\n      usage0AccessibleInDispatch,\n      usage1AccessibleInDispatch,\n      dispatchBeforeUsage1,\n      usage0,\n      visibility0,\n      usage1,\n      visibility1,\n      hasOverlap,\n    } = t.params;\n\n    const buffer = t.createBufferWithState('valid', {\n      size: kBoundBufferSize * 2,\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.STORAGE | GPUBufferUsage.INDIRECT,\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    const computePassEncoder = encoder.beginComputePass();\n\n    const offset0 = 0;\n    switch (usage0) {\n      case 'uniform':\n      case 'storage':\n      case 'read-only-storage': {\n        const bindGroup0 = t.createBindGroupForTest(buffer, offset0, usage0, visibility0);\n        computePassEncoder.setBindGroup(0, bindGroup0);\n\n        /*\n         * setBindGroup(bindGroup0);\n         * dispatchWorkgroups();\n         * setBindGroup(bindGroup1);\n         */\n        if (dispatchBeforeUsage1) {\n          let pipelineLayout: GPUPipelineLayout | undefined = undefined;\n          if (usage0AccessibleInDispatch) {\n            const bindGroupLayout0 = t.createBindGroupLayoutForTest(usage0, visibility0);\n            pipelineLayout = t.device.createPipelineLayout({\n              bindGroupLayouts: [bindGroupLayout0],\n            });\n          }\n          const computePipeline = t.createNoOpComputePipeline(pipelineLayout);\n          computePassEncoder.setPipeline(computePipeline);\n          computePassEncoder.dispatchWorkgroups(1);\n        }\n        break;\n      }\n      case 'indirect': {\n        /*\n         * dispatchWorkgroupsIndirect(buffer);\n         * setBindGroup(bindGroup1);\n         */\n        assert(dispatchBeforeUsage1);\n        const computePipeline = t.createNoOpComputePipeline();\n        computePassEncoder.setPipeline(computePipeline);\n        computePassEncoder.dispatchWorkgroupsIndirect(buffer, offset0);\n        break;\n      }\n    }\n\n    const offset1 = hasOverlap ? offset0 : kBoundBufferSize;\n    switch (usage1) {\n      case 'uniform':\n      case 'storage':\n      case 'read-only-storage': {\n        const bindGroup1 = t.createBindGroupForTest(buffer, offset1, usage1, visibility1);\n        const bindGroupIndex = usage0AccessibleInDispatch ? 1 : 0;\n        computePassEncoder.setBindGroup(bindGroupIndex, bindGroup1);\n\n        /*\n         * setBindGroup(bindGroup0);\n         * setBindGroup(bindGroup1);\n         * dispatchWorkgroups();\n         */\n        if (!dispatchBeforeUsage1) {\n          const bindGroupLayouts: GPUBindGroupLayout[] = [];\n          if (usage0AccessibleInDispatch && usage0 !== 'indirect') {\n            const bindGroupLayout0 = t.createBindGroupLayoutForTest(usage0, visibility0);\n            bindGroupLayouts.push(bindGroupLayout0);\n          }\n          if (usage1AccessibleInDispatch) {\n            const bindGroupLayout1 = t.createBindGroupLayoutForTest(usage1, visibility1);\n            bindGroupLayouts.push(bindGroupLayout1);\n          }\n          const pipelineLayout: GPUPipelineLayout | undefined = bindGroupLayouts\n            ? t.device.createPipelineLayout({\n                bindGroupLayouts,\n              })\n            : undefined;\n          const computePipeline = t.createNoOpComputePipeline(pipelineLayout);\n          computePassEncoder.setPipeline(computePipeline);\n          computePassEncoder.dispatchWorkgroups(1);\n        }\n        break;\n      }\n      case 'indirect': {\n        /*\n         * setBindGroup(bindGroup0);\n         * dispatchWorkgroupsIndirect(buffer);\n         */\n        assert(!dispatchBeforeUsage1);\n        let pipelineLayout: GPUPipelineLayout | undefined = undefined;\n        if (usage0AccessibleInDispatch) {\n          assert(usage0 !== 'indirect');\n          pipelineLayout = t.device.createPipelineLayout({\n            bindGroupLayouts: [t.createBindGroupLayoutForTest(usage0, visibility0)],\n          });\n        }\n        const computePipeline = t.createNoOpComputePipeline(pipelineLayout);\n        computePassEncoder.setPipeline(computePipeline);\n        computePassEncoder.dispatchWorkgroupsIndirect(buffer, offset1);\n        break;\n      }\n    }\n    computePassEncoder.end();\n\n    const usageHasConflict =\n      (usage0 === 'storage' && usage1 !== 'storage') ||\n      (usage0 !== 'storage' && usage1 === 'storage');\n    const fail =\n      usageHasConflict &&\n      visibility0 === 'compute' &&\n      visibility1 === 'compute' &&\n      usage0AccessibleInDispatch &&\n      usage1AccessibleInDispatch;\n    t.expectValidationError(() => {\n      encoder.finish();\n    }, fail);\n  });\n\ng.test('subresources,buffer_usage_in_compute_pass_with_two_dispatches')\n  .desc(\n    `\nTest that it is always allowed to use one buffer in different dispatch calls as in WebGPU SPEC,\nwithin one dispatch, for each bind group slot that is used by the current GPUComputePipeline's\nlayout, every subresource referenced by that bind group is \"used\" in the usage scope, and different\ndispatch calls refer to different usage scopes.`\n  )\n  .params(u =>\n    u\n      .combine('usage0', ['uniform', 'storage', 'read-only-storage', 'indirect'] as const)\n      .combine('usage1', ['uniform', 'storage', 'read-only-storage', 'indirect'] as const)\n      .beginSubcases()\n      .combine('inSamePass', [true, false])\n      .combine('hasOverlap', [true, false])\n  )\n  .fn(async t => {\n    const { usage0, usage1, inSamePass, hasOverlap } = t.params;\n\n    const UseBufferOnComputePassEncoder = (\n      computePassEncoder: GPUComputePassEncoder,\n      buffer: GPUBuffer,\n      usage: 'uniform' | 'storage' | 'read-only-storage' | 'indirect',\n      offset: number\n    ) => {\n      switch (usage) {\n        case 'uniform':\n        case 'storage':\n        case 'read-only-storage': {\n          const bindGroup = t.createBindGroupForTest(buffer, offset, usage, 'compute');\n          computePassEncoder.setBindGroup(0, bindGroup);\n\n          const bindGroupLayout = t.createBindGroupLayoutForTest(usage, 'compute');\n          const pipelineLayout = t.device.createPipelineLayout({\n            bindGroupLayouts: [bindGroupLayout],\n          });\n          const computePipeline = t.createNoOpComputePipeline(pipelineLayout);\n          computePassEncoder.setPipeline(computePipeline);\n          computePassEncoder.dispatchWorkgroups(1);\n          break;\n        }\n        case 'indirect': {\n          const computePipeline = t.createNoOpComputePipeline();\n          computePassEncoder.setPipeline(computePipeline);\n          computePassEncoder.dispatchWorkgroupsIndirect(buffer, offset);\n          break;\n        }\n        default:\n          unreachable();\n          break;\n      }\n    };\n\n    const buffer = t.createBufferWithState('valid', {\n      size: kBoundBufferSize * 2,\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.STORAGE | GPUBufferUsage.INDIRECT,\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    const computePassEncoder = encoder.beginComputePass();\n\n    const offset0 = 0;\n    const offset1 = hasOverlap ? offset0 : kBoundBufferSize;\n    UseBufferOnComputePassEncoder(computePassEncoder, buffer, usage0, offset0);\n\n    if (inSamePass) {\n      UseBufferOnComputePassEncoder(computePassEncoder, buffer, usage1, offset1);\n      computePassEncoder.end();\n    } else {\n      computePassEncoder.end();\n      const anotherComputePassEncoder = encoder.beginComputePass();\n      UseBufferOnComputePassEncoder(anotherComputePassEncoder, buffer, usage1, offset1);\n      anotherComputePassEncoder.end();\n    }\n\n    t.expectValidationError(() => {\n      encoder.finish();\n    }, false);\n  });\n\ng.test('subresources,buffer_usage_in_one_render_pass_with_no_draw')\n  .desc(\n    `\nTest that when one buffer is used in one render pass encoder, its list of internal usages within one\nusage scope (all the commands in the whole render pass) can only be a compatible usage list even if\nthere is no draw call in the render pass.\n    `\n  )\n  .params(u =>\n    u\n      .combine('usage0', ['uniform', 'storage', 'read-only-storage', 'vertex', 'index'] as const)\n      .combine('usage1', ['uniform', 'storage', 'read-only-storage', 'vertex', 'index'] as const)\n      .beginSubcases()\n      .combine('hasOverlap', [true, false])\n      .combine('visibility0', ['compute', 'fragment'] as const)\n      .unless(t => t.visibility0 === 'compute' && !IsBufferUsageInBindGroup(t.usage0))\n      .combine('visibility1', ['compute', 'fragment'] as const)\n      .unless(t => t.visibility1 === 'compute' && !IsBufferUsageInBindGroup(t.usage1))\n  )\n  .fn(async t => {\n    const { usage0, usage1, hasOverlap, visibility0, visibility1 } = t.params;\n\n    const UseBufferOnRenderPassEncoder = (\n      buffer: GPUBuffer,\n      offset: number,\n      type: 'uniform' | 'storage' | 'read-only-storage' | 'vertex' | 'index',\n      bindGroupVisibility: 'compute' | 'fragment',\n      renderPassEncoder: GPURenderPassEncoder\n    ) => {\n      switch (type) {\n        case 'uniform':\n        case 'storage':\n        case 'read-only-storage': {\n          const bindGroup = t.createBindGroupForTest(buffer, offset, type, bindGroupVisibility);\n          renderPassEncoder.setBindGroup(0, bindGroup);\n          break;\n        }\n        case 'vertex': {\n          renderPassEncoder.setVertexBuffer(0, buffer, offset, kBoundBufferSize);\n          break;\n        }\n        case 'index': {\n          renderPassEncoder.setIndexBuffer(buffer, 'uint16', offset, kBoundBufferSize);\n          break;\n        }\n      }\n    };\n\n    const buffer = t.createBufferWithState('valid', {\n      size: kBoundBufferSize * 2,\n      usage:\n        GPUBufferUsage.UNIFORM |\n        GPUBufferUsage.STORAGE |\n        GPUBufferUsage.VERTEX |\n        GPUBufferUsage.INDEX,\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    const renderPassEncoder = t.beginSimpleRenderPass(encoder);\n    const offset0 = 0;\n    UseBufferOnRenderPassEncoder(buffer, offset0, usage0, visibility0, renderPassEncoder);\n    const offset1 = hasOverlap ? offset0 : kBoundBufferSize;\n    UseBufferOnRenderPassEncoder(buffer, offset1, usage1, visibility1, renderPassEncoder);\n    renderPassEncoder.end();\n\n    const fail = (usage0 === 'storage') !== (usage1 === 'storage');\n    t.expectValidationError(() => {\n      encoder.finish();\n    }, fail);\n  });\n"],"file":"in_pass_encoder.spec.js"}
{"version":3,"sources":["../../../../../../src/webgpu/api/validation/resource_usages/buffer/in_pass_encoder.spec.ts"],"names":["description","makeTestGroup","unreachable","ValidationTest","kBoundBufferSize","F","createBindGroupForTest","buffer","offset","type","resourceVisibility","bindGroupLayoutEntry","binding","visibility","GPUShaderStage","COMPUTE","FRAGMENT","bindGroupLayout","device","createBindGroupLayout","entries","createBindGroup","layout","resource","size","beginSimpleRenderPass","encoder","colorTexture","createTexture","format","usage","GPUTextureUsage","RENDER_ATTACHMENT","beginRenderPass","colorAttachments","view","createView","loadOp","storeOp","IsBufferUsageInBindGroup","bufferUsage","g","test","desc","params","u","combine","unless","t","bindGroupVisibility0","bufferUsage0","bindGroupVisibility1","bufferUsage1","fn","inSamePass","hasOverlap","UseBufferOnRenderPassEncoder","bindGroupVisibility","renderPassEncoder","bindGroup","setBindGroup","setVertexBuffer","setIndexBuffer","renderPipeline","createNoOpRenderPipeline","setPipeline","drawIndirect","indexBuffer","createBuffer","GPUBufferUsage","INDEX","drawIndexedIndirect","UNIFORM","STORAGE","VERTEX","INDIRECT","createCommandEncoder","offset0","offset1","end","anotherRenderPassEncoder","fail","expectValidationError","finish"],"mappings":"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","sourcesContent":["export const description = `\nBuffer Usages Validation Tests in Render Pass and Compute Pass.\n`;\n\nimport { makeTestGroup } from '../../../../../common/framework/test_group.js';\nimport { unreachable } from '../../../../../common/util/util.js';\nimport { ValidationTest } from '../../validation_test.js';\n\nconst kBoundBufferSize = 256;\n\nclass F extends ValidationTest {\n  createBindGroupForTest(\n    buffer: GPUBuffer,\n    offset: number,\n    type: 'uniform' | 'storage' | 'read-only-storage',\n    resourceVisibility: 'compute' | 'fragment'\n  ) {\n    const bindGroupLayoutEntry: GPUBindGroupLayoutEntry = {\n      binding: 0,\n      visibility:\n        resourceVisibility === 'compute' ? GPUShaderStage.COMPUTE : GPUShaderStage.FRAGMENT,\n      buffer: {\n        type,\n      },\n    };\n    const bindGroupLayout = this.device.createBindGroupLayout({\n      entries: [bindGroupLayoutEntry],\n    });\n\n    return this.device.createBindGroup({\n      layout: bindGroupLayout,\n      entries: [\n        {\n          binding: 0,\n          resource: { buffer, offset, size: kBoundBufferSize },\n        },\n      ],\n    });\n  }\n\n  beginSimpleRenderPass(encoder: GPUCommandEncoder) {\n    const colorTexture = this.device.createTexture({\n      format: 'rgba8unorm',\n      usage: GPUTextureUsage.RENDER_ATTACHMENT,\n      size: [16, 16, 1],\n    });\n    return encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: colorTexture.createView(),\n          loadOp: 'load',\n          storeOp: 'store',\n        },\n      ],\n    });\n  }\n}\n\nfunction IsBufferUsageInBindGroup(\n  bufferUsage:\n    | 'uniform'\n    | 'storage'\n    | 'read-only-storage'\n    | 'vertex'\n    | 'index'\n    | 'drawIndirect'\n    | 'drawIndexedIndirect'\n): boolean {\n  switch (bufferUsage) {\n    case 'uniform':\n    case 'storage':\n    case 'read-only-storage':\n      return true;\n    case 'vertex':\n    case 'index':\n    case 'drawIndirect':\n    case 'drawIndexedIndirect':\n      return false;\n    default:\n      unreachable();\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('subresources,buffer_usage_in_render_pass_encoder')\n  .desc(\n    `\nTest that when one buffer is used in one render pass encoder, its list of internal usages within one\nusage scope can only be a compatible usage list; while there is no such restriction when it is used\nin different render pass encoders. The usage scope rules are not related to the buffer offset or the\nbind group layout visibility.`\n  )\n  .params(u =>\n    u\n      .combine('bufferUsage0', [\n        'uniform',\n        'storage',\n        'read-only-storage',\n        'vertex',\n        'index',\n        'drawIndirect',\n        'drawIndexedIndirect',\n      ] as const)\n      .combine('bindGroupVisibility0', ['compute', 'fragment'] as const)\n      .unless(\n        t => t.bindGroupVisibility0 === 'compute' && !IsBufferUsageInBindGroup(t.bufferUsage0)\n      )\n      .combine('bufferUsage1', [\n        'uniform',\n        'storage',\n        'read-only-storage',\n        'vertex',\n        'index',\n        'drawIndirect',\n        'drawIndexedIndirect',\n      ] as const)\n      .combine('bindGroupVisibility1', ['compute', 'fragment'] as const)\n      .unless(\n        t => t.bindGroupVisibility1 === 'compute' && !IsBufferUsageInBindGroup(t.bufferUsage1)\n      )\n      .combine('inSamePass', [true, false])\n      .combine('hasOverlap', [true, false])\n  )\n  .fn(async t => {\n    const {\n      bufferUsage0,\n      bindGroupVisibility0,\n      bufferUsage1,\n      bindGroupVisibility1,\n      inSamePass,\n      hasOverlap,\n    } = t.params;\n\n    const UseBufferOnRenderPassEncoder = (\n      buffer: GPUBuffer,\n      offset: number,\n      type:\n        | 'uniform'\n        | 'storage'\n        | 'read-only-storage'\n        | 'vertex'\n        | 'index'\n        | 'drawIndirect'\n        | 'drawIndexedIndirect',\n      bindGroupVisibility: 'compute' | 'fragment',\n      renderPassEncoder: GPURenderPassEncoder\n    ) => {\n      switch (type) {\n        case 'uniform':\n        case 'storage':\n        case 'read-only-storage': {\n          const bindGroup = t.createBindGroupForTest(buffer, offset, type, bindGroupVisibility);\n          renderPassEncoder.setBindGroup(0, bindGroup);\n          break;\n        }\n        case 'vertex': {\n          renderPassEncoder.setVertexBuffer(0, buffer, offset, kBoundBufferSize);\n          break;\n        }\n        case 'index': {\n          renderPassEncoder.setIndexBuffer(buffer, 'uint16', offset, kBoundBufferSize);\n          break;\n        }\n        case 'drawIndirect': {\n          const renderPipeline = t.createNoOpRenderPipeline();\n          renderPassEncoder.setPipeline(renderPipeline);\n          renderPassEncoder.drawIndirect(buffer, offset);\n          break;\n        }\n        case 'drawIndexedIndirect': {\n          const renderPipeline = t.createNoOpRenderPipeline();\n          renderPassEncoder.setPipeline(renderPipeline);\n          const indexBuffer = t.device.createBuffer({\n            size: 4,\n            usage: GPUBufferUsage.INDEX,\n          });\n          renderPassEncoder.setIndexBuffer(indexBuffer, 'uint16');\n          renderPassEncoder.drawIndexedIndirect(buffer, offset);\n          break;\n        }\n      }\n    };\n\n    const buffer = t.device.createBuffer({\n      size: kBoundBufferSize * 2,\n      usage:\n        GPUBufferUsage.UNIFORM |\n        GPUBufferUsage.STORAGE |\n        GPUBufferUsage.VERTEX |\n        GPUBufferUsage.INDEX |\n        GPUBufferUsage.INDIRECT,\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    const renderPassEncoder = t.beginSimpleRenderPass(encoder);\n    const offset0 = 0;\n    UseBufferOnRenderPassEncoder(\n      buffer,\n      offset0,\n      bufferUsage0,\n      bindGroupVisibility0,\n      renderPassEncoder\n    );\n    const offset1 = hasOverlap ? offset0 : kBoundBufferSize;\n    if (inSamePass) {\n      UseBufferOnRenderPassEncoder(\n        buffer,\n        offset1,\n        bufferUsage1,\n        bindGroupVisibility1,\n        renderPassEncoder\n      );\n      renderPassEncoder.end();\n    } else {\n      renderPassEncoder.end();\n      const anotherRenderPassEncoder = t.beginSimpleRenderPass(encoder);\n      UseBufferOnRenderPassEncoder(\n        buffer,\n        offset1,\n        bufferUsage1,\n        bindGroupVisibility1,\n        anotherRenderPassEncoder\n      );\n      anotherRenderPassEncoder.end();\n    }\n\n    const fail =\n      inSamePass &&\n      ((bufferUsage0 === 'storage' && bufferUsage1 !== 'storage') ||\n        (bufferUsage0 !== 'storage' && bufferUsage1 === 'storage'));\n    t.expectValidationError(() => {\n      encoder.finish();\n    }, fail);\n  });\n"],"file":"in_pass_encoder.spec.js"}
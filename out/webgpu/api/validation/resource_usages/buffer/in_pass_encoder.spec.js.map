{"version":3,"sources":["../../../../../../src/webgpu/api/validation/resource_usages/buffer/in_pass_encoder.spec.ts"],"names":["description","makeTestGroup","assert","unreachable","ValidationTest","kBoundBufferSize","kAllBufferUsages","F","createBindGroupLayoutForTest","type","resourceVisibility","bindGroupLayoutEntry","binding","visibility","GPUShaderStage","COMPUTE","FRAGMENT","buffer","device","createBindGroupLayout","entries","createBindGroupForTest","offset","createBindGroup","layout","resource","size","beginSimpleRenderPass","encoder","colorTexture","createTexture","format","usage","GPUTextureUsage","RENDER_ATTACHMENT","beginRenderPass","colorAttachments","view","createView","loadOp","storeOp","createRenderPipelineForTest","pipelineLayout","vertexBufferCount","vertexBuffers","i","push","arrayStride","attributes","shaderLocation","createRenderPipeline","vertex","module","createShaderModule","code","getNoOpShaderCode","entryPoint","buffers","fragment","targets","primitive","topology","IsBufferUsageInBindGroup","bufferUsage","g","test","desc","params","u","combine","beginSubcases","unless","t","visibility0","usage0","visibility1","usage1","fn","inSamePass","hasOverlap","UseBufferOnRenderPassEncoder","index","bindGroupVisibility","renderPassEncoder","bindGroup","setBindGroup","setVertexBuffer","setIndexBuffer","renderPipeline","createNoOpRenderPipeline","setPipeline","drawIndirect","indexBuffer","createBufferWithState","GPUBufferUsage","INDEX","drawIndexedIndirect","UNIFORM","STORAGE","VERTEX","INDIRECT","createCommandEncoder","offset0","index0","offset1","index1","end","anotherRenderPassEncoder","fail","expectValidationError","finish","computePassEncoder","beginComputePass","bindGroup0","bindGroup1","filter","usage0AccessibleInDispatch","dispatchBeforeUsage1","usage1AccessibleInDispatch","undefined","bindGroupLayout0","createPipelineLayout","bindGroupLayouts","computePipeline","createNoOpComputePipeline","dispatchWorkgroups","dispatchWorkgroupsIndirect","bindGroupIndex","bindGroupLayout1","usageHasConflict","UseBufferOnComputePassEncoder","bindGroupLayout","anotherComputePassEncoder","usage0AccessibleInDraw","drawBeforeUsage1","usage1AccessibleInDraw","bufferAccessibleInDraw","bufferIndex","usedBindGroupLayouts","MakeDrawCallWithOneUsage","draw","drawIndexed","createBuffer","bufferIndex0","pipeline","bufferIndex1"],"mappings":"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","sourcesContent":["export const description = `\nBuffer Usages Validation Tests in Render Pass and Compute Pass.\n`;\n\nimport { makeTestGroup } from '../../../../../common/framework/test_group.js';\nimport { assert, unreachable } from '../../../../../common/util/util.js';\nimport { ValidationTest } from '../../validation_test.js';\n\nconst kBoundBufferSize = 256;\n\ntype BufferUsage =\n  | 'uniform'\n  | 'storage'\n  | 'read-only-storage'\n  | 'vertex'\n  | 'index'\n  | 'indirect'\n  | 'indexedIndirect';\n\nconst kAllBufferUsages: BufferUsage[] = [\n  'uniform',\n  'storage',\n  'read-only-storage',\n  'vertex',\n  'index',\n  'indirect',\n  'indexedIndirect',\n];\n\nclass F extends ValidationTest {\n  createBindGroupLayoutForTest(\n    type: 'uniform' | 'storage' | 'read-only-storage',\n    resourceVisibility: 'compute' | 'fragment'\n  ): GPUBindGroupLayout {\n    const bindGroupLayoutEntry: GPUBindGroupLayoutEntry = {\n      binding: 0,\n      visibility:\n        resourceVisibility === 'compute' ? GPUShaderStage.COMPUTE : GPUShaderStage.FRAGMENT,\n      buffer: {\n        type,\n      },\n    };\n    return this.device.createBindGroupLayout({\n      entries: [bindGroupLayoutEntry],\n    });\n  }\n\n  createBindGroupForTest(\n    buffer: GPUBuffer,\n    offset: number,\n    type: 'uniform' | 'storage' | 'read-only-storage',\n    resourceVisibility: 'compute' | 'fragment'\n  ): GPUBindGroup {\n    return this.device.createBindGroup({\n      layout: this.createBindGroupLayoutForTest(type, resourceVisibility),\n      entries: [\n        {\n          binding: 0,\n          resource: { buffer, offset, size: kBoundBufferSize },\n        },\n      ],\n    });\n  }\n\n  beginSimpleRenderPass(encoder: GPUCommandEncoder) {\n    const colorTexture = this.device.createTexture({\n      format: 'rgba8unorm',\n      usage: GPUTextureUsage.RENDER_ATTACHMENT,\n      size: [16, 16, 1],\n    });\n    return encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: colorTexture.createView(),\n          loadOp: 'load',\n          storeOp: 'store',\n        },\n      ],\n    });\n  }\n\n  createRenderPipelineForTest(\n    pipelineLayout: GPUPipelineLayout | undefined,\n    vertexBufferCount: number\n  ): GPURenderPipeline {\n    const vertexBuffers: GPUVertexBufferLayout[] = [];\n    for (let i = 0; i < vertexBufferCount; ++i) {\n      vertexBuffers.push({\n        arrayStride: 4,\n        attributes: [\n          {\n            format: 'float32',\n            shaderLocation: i,\n            offset: 0,\n          },\n        ],\n      });\n    }\n\n    return this.device.createRenderPipeline({\n      layout: pipelineLayout,\n      vertex: {\n        module: this.device.createShaderModule({\n          code: this.getNoOpShaderCode('VERTEX'),\n        }),\n        entryPoint: 'main',\n        buffers: vertexBuffers,\n      },\n      fragment: {\n        module: this.device.createShaderModule({\n          code: `\n              @stage(fragment) fn main()\n                -> @location(0) vec4<f32> {\n                  return vec4<f32>(0.0, 0.0, 0.0, 1.0);\n              }`,\n        }),\n        entryPoint: 'main',\n        targets: [{ format: 'rgba8unorm' }],\n      },\n      primitive: { topology: 'point-list' },\n    });\n  }\n}\n\nfunction IsBufferUsageInBindGroup(bufferUsage: BufferUsage): boolean {\n  switch (bufferUsage) {\n    case 'uniform':\n    case 'storage':\n    case 'read-only-storage':\n      return true;\n    case 'vertex':\n    case 'index':\n    case 'indirect':\n    case 'indexedIndirect':\n      return false;\n    default:\n      unreachable();\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('subresources,buffer_usage_in_render_pass')\n  .desc(\n    `\nTest that when one buffer is used in one render pass encoder, its list of internal usages within one\nusage scope (all the commands in the whole render pass) can only be a compatible usage list; while\nthere is no such restriction when it is used in different render pass encoders. The usage scope\nrules are not related to the buffer offset or the bind group layout visibilities.`\n  )\n  .params(u =>\n    u\n      .combine('inSamePass', [true, false])\n      .combine('hasOverlap', [true, false])\n      .beginSubcases()\n      .combine('usage0', kAllBufferUsages)\n      .combine('visibility0', ['compute', 'fragment'] as const)\n      .unless(t => t.visibility0 === 'compute' && !IsBufferUsageInBindGroup(t.usage0))\n      .combine('usage1', kAllBufferUsages)\n      .combine('visibility1', ['compute', 'fragment'] as const)\n      // The situation that the index buffer is reset by another setIndexBuffer call will be tested\n      // in another test case.\n      .unless(\n        t =>\n          (t.visibility1 === 'compute' && !IsBufferUsageInBindGroup(t.usage1)) ||\n          (t.usage0 === 'index' && t.usage1 === 'index')\n      )\n  )\n  .fn(async t => {\n    const { inSamePass, hasOverlap, usage0, visibility0, usage1, visibility1 } = t.params;\n\n    const UseBufferOnRenderPassEncoder = (\n      buffer: GPUBuffer,\n      index: number,\n      offset: number,\n      type: BufferUsage,\n      bindGroupVisibility: 'compute' | 'fragment',\n      renderPassEncoder: GPURenderPassEncoder\n    ) => {\n      switch (type) {\n        case 'uniform':\n        case 'storage':\n        case 'read-only-storage': {\n          const bindGroup = t.createBindGroupForTest(buffer, offset, type, bindGroupVisibility);\n          renderPassEncoder.setBindGroup(index, bindGroup);\n          break;\n        }\n        case 'vertex': {\n          renderPassEncoder.setVertexBuffer(index, buffer, offset, kBoundBufferSize);\n          break;\n        }\n        case 'index': {\n          renderPassEncoder.setIndexBuffer(buffer, 'uint16', offset, kBoundBufferSize);\n          break;\n        }\n        case 'indirect': {\n          const renderPipeline = t.createNoOpRenderPipeline();\n          renderPassEncoder.setPipeline(renderPipeline);\n          renderPassEncoder.drawIndirect(buffer, offset);\n          break;\n        }\n        case 'indexedIndirect': {\n          const renderPipeline = t.createNoOpRenderPipeline();\n          renderPassEncoder.setPipeline(renderPipeline);\n          const indexBuffer = t.createBufferWithState('valid', {\n            size: 4,\n            usage: GPUBufferUsage.INDEX,\n          });\n          renderPassEncoder.setIndexBuffer(indexBuffer, 'uint16');\n          renderPassEncoder.drawIndexedIndirect(buffer, offset);\n          break;\n        }\n      }\n    };\n\n    const buffer = t.createBufferWithState('valid', {\n      size: kBoundBufferSize * 2,\n      usage:\n        GPUBufferUsage.UNIFORM |\n        GPUBufferUsage.STORAGE |\n        GPUBufferUsage.VERTEX |\n        GPUBufferUsage.INDEX |\n        GPUBufferUsage.INDIRECT,\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    const renderPassEncoder = t.beginSimpleRenderPass(encoder);\n    const offset0 = 0;\n    const index0 = 0;\n    UseBufferOnRenderPassEncoder(buffer, index0, offset0, usage0, visibility0, renderPassEncoder);\n    const offset1 = hasOverlap ? offset0 : kBoundBufferSize;\n    const index1 = 1;\n    if (inSamePass) {\n      UseBufferOnRenderPassEncoder(buffer, index1, offset1, usage1, visibility1, renderPassEncoder);\n      renderPassEncoder.end();\n    } else {\n      renderPassEncoder.end();\n      const anotherRenderPassEncoder = t.beginSimpleRenderPass(encoder);\n      UseBufferOnRenderPassEncoder(\n        buffer,\n        index1,\n        offset1,\n        usage1,\n        visibility1,\n        anotherRenderPassEncoder\n      );\n      anotherRenderPassEncoder.end();\n    }\n\n    const fail =\n      inSamePass &&\n      ((usage0 === 'storage' && usage1 !== 'storage') ||\n        (usage0 !== 'storage' && usage1 === 'storage'));\n    t.expectValidationError(() => {\n      encoder.finish();\n    }, fail);\n  });\n\ng.test('subresources,buffer_usage_in_one_compute_pass_with_no_dispatch')\n  .desc(\n    `\nTest that it is always allowed to set multiple bind groups with same buffer in a compute pass\nencoder without any dispatch calls as state-setting compute pass commands, like setBindGroup(index,\nbindGroup, dynamicOffsets), do not contribute directly to a usage scope.`\n  )\n  .params(u =>\n    u\n      .combine('usage0', ['uniform', 'storage', 'read-only-storage'] as const)\n      .combine('usage1', ['uniform', 'storage', 'read-only-storage'] as const)\n      .beginSubcases()\n      .combine('visibility0', ['compute', 'fragment'] as const)\n      .combine('visibility1', ['compute', 'fragment'] as const)\n      .combine('hasOverlap', [true, false])\n  )\n  .fn(async t => {\n    const { usage0, usage1, visibility0, visibility1, hasOverlap } = t.params;\n\n    const buffer = t.createBufferWithState('valid', {\n      size: kBoundBufferSize * 2,\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.STORAGE,\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    const computePassEncoder = encoder.beginComputePass();\n\n    const offset0 = 0;\n    const bindGroup0 = t.createBindGroupForTest(buffer, offset0, usage0, visibility0);\n    computePassEncoder.setBindGroup(0, bindGroup0);\n\n    const offset1 = hasOverlap ? offset0 : kBoundBufferSize;\n    const bindGroup1 = t.createBindGroupForTest(buffer, offset1, usage1, visibility1);\n    computePassEncoder.setBindGroup(1, bindGroup1);\n\n    computePassEncoder.end();\n\n    t.expectValidationError(() => {\n      encoder.finish();\n    }, false);\n  });\n\ng.test('subresources,buffer_usage_in_one_compute_pass_with_one_dispatch')\n  .desc(\n    `\nTest that when one buffer is used in one compute pass encoder, its list of internal usages within\none usage scope can only be a compatible usage list. According to WebGPU SPEC, within one dispatch,\nfor each bind group slot that is used by the current GPUComputePipeline's layout, every subresource\nreferenced by that bind group is \"used\" in the usage scope. `\n  )\n  .params(u =>\n    u\n      .combine('usage0AccessibleInDispatch', [true, false])\n      .combine('usage1AccessibleInDispatch', [true, false])\n      .combine('dispatchBeforeUsage1', [true, false])\n      .beginSubcases()\n      .combine('usage0', ['uniform', 'storage', 'read-only-storage', 'indirect'] as const)\n      .combine('visibility0', ['compute', 'fragment'] as const)\n      .filter(t => {\n        // The buffer with `indirect` usage is always accessible in the dispatch call.\n        if (\n          t.usage0 === 'indirect' &&\n          (!t.usage0AccessibleInDispatch || t.visibility0 !== 'compute' || !t.dispatchBeforeUsage1)\n        ) {\n          return false;\n        }\n        if (t.usage0AccessibleInDispatch && t.visibility0 !== 'compute') {\n          return false;\n        }\n        if (t.dispatchBeforeUsage1 && t.usage1AccessibleInDispatch) {\n          return false;\n        }\n        return true;\n      })\n      .combine('usage1', ['uniform', 'storage', 'read-only-storage', 'indirect'] as const)\n      .combine('visibility1', ['compute', 'fragment'] as const)\n      .filter(t => {\n        if (\n          t.usage1 === 'indirect' &&\n          (!t.usage1AccessibleInDispatch || t.visibility1 !== 'compute' || t.dispatchBeforeUsage1)\n        ) {\n          return false;\n        }\n        // When the first buffer usage is `indirect`, there has already been one dispatch call, so\n        // in this test we always make the second usage inaccessible in the dispatch call.\n        if (\n          t.usage1AccessibleInDispatch &&\n          (t.visibility1 !== 'compute' || t.usage0 === 'indirect')\n        ) {\n          return false;\n        }\n        return true;\n      })\n      .combine('hasOverlap', [true, false])\n  )\n  .fn(async t => {\n    const {\n      usage0AccessibleInDispatch,\n      usage1AccessibleInDispatch,\n      dispatchBeforeUsage1,\n      usage0,\n      visibility0,\n      usage1,\n      visibility1,\n      hasOverlap,\n    } = t.params;\n\n    const buffer = t.createBufferWithState('valid', {\n      size: kBoundBufferSize * 2,\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.STORAGE | GPUBufferUsage.INDIRECT,\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    const computePassEncoder = encoder.beginComputePass();\n\n    const offset0 = 0;\n    switch (usage0) {\n      case 'uniform':\n      case 'storage':\n      case 'read-only-storage': {\n        const bindGroup0 = t.createBindGroupForTest(buffer, offset0, usage0, visibility0);\n        computePassEncoder.setBindGroup(0, bindGroup0);\n\n        /*\n         * setBindGroup(bindGroup0);\n         * dispatchWorkgroups();\n         * setBindGroup(bindGroup1);\n         */\n        if (dispatchBeforeUsage1) {\n          let pipelineLayout: GPUPipelineLayout | undefined = undefined;\n          if (usage0AccessibleInDispatch) {\n            const bindGroupLayout0 = t.createBindGroupLayoutForTest(usage0, visibility0);\n            pipelineLayout = t.device.createPipelineLayout({\n              bindGroupLayouts: [bindGroupLayout0],\n            });\n          }\n          const computePipeline = t.createNoOpComputePipeline(pipelineLayout);\n          computePassEncoder.setPipeline(computePipeline);\n          computePassEncoder.dispatchWorkgroups(1);\n        }\n        break;\n      }\n      case 'indirect': {\n        /*\n         * dispatchWorkgroupsIndirect(buffer);\n         * setBindGroup(bindGroup1);\n         */\n        assert(dispatchBeforeUsage1);\n        const computePipeline = t.createNoOpComputePipeline();\n        computePassEncoder.setPipeline(computePipeline);\n        computePassEncoder.dispatchWorkgroupsIndirect(buffer, offset0);\n        break;\n      }\n    }\n\n    const offset1 = hasOverlap ? offset0 : kBoundBufferSize;\n    switch (usage1) {\n      case 'uniform':\n      case 'storage':\n      case 'read-only-storage': {\n        const bindGroup1 = t.createBindGroupForTest(buffer, offset1, usage1, visibility1);\n        const bindGroupIndex = usage0AccessibleInDispatch ? 1 : 0;\n        computePassEncoder.setBindGroup(bindGroupIndex, bindGroup1);\n\n        /*\n         * setBindGroup(bindGroup0);\n         * setBindGroup(bindGroup1);\n         * dispatchWorkgroups();\n         */\n        if (!dispatchBeforeUsage1) {\n          const bindGroupLayouts: GPUBindGroupLayout[] = [];\n          if (usage0AccessibleInDispatch && usage0 !== 'indirect') {\n            const bindGroupLayout0 = t.createBindGroupLayoutForTest(usage0, visibility0);\n            bindGroupLayouts.push(bindGroupLayout0);\n          }\n          if (usage1AccessibleInDispatch) {\n            const bindGroupLayout1 = t.createBindGroupLayoutForTest(usage1, visibility1);\n            bindGroupLayouts.push(bindGroupLayout1);\n          }\n          const pipelineLayout: GPUPipelineLayout | undefined = bindGroupLayouts\n            ? t.device.createPipelineLayout({\n                bindGroupLayouts,\n              })\n            : undefined;\n          const computePipeline = t.createNoOpComputePipeline(pipelineLayout);\n          computePassEncoder.setPipeline(computePipeline);\n          computePassEncoder.dispatchWorkgroups(1);\n        }\n        break;\n      }\n      case 'indirect': {\n        /*\n         * setBindGroup(bindGroup0);\n         * dispatchWorkgroupsIndirect(buffer);\n         */\n        assert(!dispatchBeforeUsage1);\n        let pipelineLayout: GPUPipelineLayout | undefined = undefined;\n        if (usage0AccessibleInDispatch) {\n          assert(usage0 !== 'indirect');\n          pipelineLayout = t.device.createPipelineLayout({\n            bindGroupLayouts: [t.createBindGroupLayoutForTest(usage0, visibility0)],\n          });\n        }\n        const computePipeline = t.createNoOpComputePipeline(pipelineLayout);\n        computePassEncoder.setPipeline(computePipeline);\n        computePassEncoder.dispatchWorkgroupsIndirect(buffer, offset1);\n        break;\n      }\n    }\n    computePassEncoder.end();\n\n    const usageHasConflict =\n      (usage0 === 'storage' && usage1 !== 'storage') ||\n      (usage0 !== 'storage' && usage1 === 'storage');\n    const fail =\n      usageHasConflict &&\n      visibility0 === 'compute' &&\n      visibility1 === 'compute' &&\n      usage0AccessibleInDispatch &&\n      usage1AccessibleInDispatch;\n    t.expectValidationError(() => {\n      encoder.finish();\n    }, fail);\n  });\n\ng.test('subresources,buffer_usage_in_compute_pass_with_two_dispatches')\n  .desc(\n    `\nTest that it is always allowed to use one buffer in different dispatch calls as in WebGPU SPEC,\nwithin one dispatch, for each bind group slot that is used by the current GPUComputePipeline's\nlayout, every subresource referenced by that bind group is \"used\" in the usage scope, and different\ndispatch calls refer to different usage scopes.`\n  )\n  .params(u =>\n    u\n      .combine('usage0', ['uniform', 'storage', 'read-only-storage', 'indirect'] as const)\n      .combine('usage1', ['uniform', 'storage', 'read-only-storage', 'indirect'] as const)\n      .beginSubcases()\n      .combine('inSamePass', [true, false])\n      .combine('hasOverlap', [true, false])\n  )\n  .fn(async t => {\n    const { usage0, usage1, inSamePass, hasOverlap } = t.params;\n\n    const UseBufferOnComputePassEncoder = (\n      computePassEncoder: GPUComputePassEncoder,\n      buffer: GPUBuffer,\n      usage: 'uniform' | 'storage' | 'read-only-storage' | 'indirect',\n      offset: number\n    ) => {\n      switch (usage) {\n        case 'uniform':\n        case 'storage':\n        case 'read-only-storage': {\n          const bindGroup = t.createBindGroupForTest(buffer, offset, usage, 'compute');\n          computePassEncoder.setBindGroup(0, bindGroup);\n\n          const bindGroupLayout = t.createBindGroupLayoutForTest(usage, 'compute');\n          const pipelineLayout = t.device.createPipelineLayout({\n            bindGroupLayouts: [bindGroupLayout],\n          });\n          const computePipeline = t.createNoOpComputePipeline(pipelineLayout);\n          computePassEncoder.setPipeline(computePipeline);\n          computePassEncoder.dispatchWorkgroups(1);\n          break;\n        }\n        case 'indirect': {\n          const computePipeline = t.createNoOpComputePipeline();\n          computePassEncoder.setPipeline(computePipeline);\n          computePassEncoder.dispatchWorkgroupsIndirect(buffer, offset);\n          break;\n        }\n        default:\n          unreachable();\n          break;\n      }\n    };\n\n    const buffer = t.createBufferWithState('valid', {\n      size: kBoundBufferSize * 2,\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.STORAGE | GPUBufferUsage.INDIRECT,\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    const computePassEncoder = encoder.beginComputePass();\n\n    const offset0 = 0;\n    const offset1 = hasOverlap ? offset0 : kBoundBufferSize;\n    UseBufferOnComputePassEncoder(computePassEncoder, buffer, usage0, offset0);\n\n    if (inSamePass) {\n      UseBufferOnComputePassEncoder(computePassEncoder, buffer, usage1, offset1);\n      computePassEncoder.end();\n    } else {\n      computePassEncoder.end();\n      const anotherComputePassEncoder = encoder.beginComputePass();\n      UseBufferOnComputePassEncoder(anotherComputePassEncoder, buffer, usage1, offset1);\n      anotherComputePassEncoder.end();\n    }\n\n    t.expectValidationError(() => {\n      encoder.finish();\n    }, false);\n  });\n\ng.test('subresources,buffer_usage_in_one_render_pass_with_no_draw')\n  .desc(\n    `\nTest that when one buffer is used in one render pass encoder, its list of internal usages within one\nusage scope (all the commands in the whole render pass) can only be a compatible usage list even if\nthere is no draw call in the render pass.\n    `\n  )\n  .params(u =>\n    u\n      .combine('usage0', ['uniform', 'storage', 'read-only-storage', 'vertex', 'index'] as const)\n      .combine('usage1', ['uniform', 'storage', 'read-only-storage', 'vertex', 'index'] as const)\n      .beginSubcases()\n      .combine('hasOverlap', [true, false])\n      .combine('visibility0', ['compute', 'fragment'] as const)\n      .unless(t => t.visibility0 === 'compute' && !IsBufferUsageInBindGroup(t.usage0))\n      .combine('visibility1', ['compute', 'fragment'] as const)\n      .unless(t => t.visibility1 === 'compute' && !IsBufferUsageInBindGroup(t.usage1))\n  )\n  .fn(async t => {\n    const { usage0, usage1, hasOverlap, visibility0, visibility1 } = t.params;\n\n    const UseBufferOnRenderPassEncoder = (\n      buffer: GPUBuffer,\n      offset: number,\n      type: BufferUsage,\n      bindGroupVisibility: 'compute' | 'fragment',\n      renderPassEncoder: GPURenderPassEncoder\n    ) => {\n      switch (type) {\n        case 'uniform':\n        case 'storage':\n        case 'read-only-storage': {\n          const bindGroup = t.createBindGroupForTest(buffer, offset, type, bindGroupVisibility);\n          renderPassEncoder.setBindGroup(0, bindGroup);\n          break;\n        }\n        case 'vertex': {\n          renderPassEncoder.setVertexBuffer(0, buffer, offset, kBoundBufferSize);\n          break;\n        }\n        case 'index': {\n          renderPassEncoder.setIndexBuffer(buffer, 'uint16', offset, kBoundBufferSize);\n          break;\n        }\n        case 'indirect':\n        case 'indexedIndirect':\n          unreachable();\n          break;\n      }\n    };\n\n    const buffer = t.createBufferWithState('valid', {\n      size: kBoundBufferSize * 2,\n      usage:\n        GPUBufferUsage.UNIFORM |\n        GPUBufferUsage.STORAGE |\n        GPUBufferUsage.VERTEX |\n        GPUBufferUsage.INDEX,\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    const renderPassEncoder = t.beginSimpleRenderPass(encoder);\n    const offset0 = 0;\n    UseBufferOnRenderPassEncoder(buffer, offset0, usage0, visibility0, renderPassEncoder);\n    const offset1 = hasOverlap ? offset0 : kBoundBufferSize;\n    UseBufferOnRenderPassEncoder(buffer, offset1, usage1, visibility1, renderPassEncoder);\n    renderPassEncoder.end();\n\n    const fail = (usage0 === 'storage') !== (usage1 === 'storage');\n    t.expectValidationError(() => {\n      encoder.finish();\n    }, fail);\n  });\n\ng.test('subresources,buffer_usage_in_one_render_pass_with_one_draw')\n  .desc(\n    `\nTest that when one buffer is used in one render pass encoder where there is one draw call, its list\nof internal usages within one usage scope (all the commands in the whole render pass) can only be a\ncompatible usage list. The usage scope rules are not related to the buffer offset or the bind group\nlayout visibilities.`\n  )\n  .params(u =>\n    u\n      .combine('usage0', kAllBufferUsages)\n      .combine('usage1', kAllBufferUsages)\n      .beginSubcases()\n      .combine('usage0AccessibleInDraw', [true, false])\n      .combine('usage1AccessibleInDraw', [true, false])\n      .combine('drawBeforeUsage1', [true, false])\n      .combine('visibility0', ['compute', 'fragment'] as const)\n      .filter(t => {\n        // The buffer with `indirect` or `indexedIndirect` usage is always accessible in the draw\n        // call.\n        if (\n          (t.usage0 === 'indirect' || t.usage0 === 'indexedIndirect') &&\n          (!t.usage0AccessibleInDraw || t.visibility0 !== 'fragment' || !t.drawBeforeUsage1)\n        ) {\n          return false;\n        }\n        // The bufer usages `vertex` and `index` do nothing with shader visibilities.\n        if ((t.usage0 === 'vertex' || t.usage0 === 'index') && t.visibility0 !== 'fragment') {\n          return false;\n        }\n\n        // As usage0 is accessible in the draw call, visibility0 can only be 'fragment'.\n        if (t.usage0AccessibleInDraw && t.visibility0 !== 'fragment') {\n          return false;\n        }\n        // As usage1 is accssible in the draw call, the draw call cannot be before usage1.\n        if (t.drawBeforeUsage1 && t.usage1AccessibleInDraw) {\n          return false;\n        }\n        return true;\n      })\n      .combine('visibility1', ['compute', 'fragment'] as const)\n      .filter(t => {\n        if (\n          (t.usage1 === 'indirect' || t.usage1 === 'indexedIndirect') &&\n          (!t.usage1AccessibleInDraw || t.visibility1 !== 'fragment' || t.drawBeforeUsage1)\n        ) {\n          return false;\n        }\n        if ((t.usage1 === 'vertex' || t.usage1 === 'index') && t.visibility1 !== 'fragment') {\n          return false;\n        }\n        // When the first buffer usage is `indirect` or `indexedIndirect`, there has already been\n        // one draw call, so in this test we always make the second usage inaccessible in the draw\n        // call.\n        if (\n          t.usage1AccessibleInDraw &&\n          (t.visibility1 !== 'fragment' ||\n            t.usage0 === 'indirect' ||\n            t.usage0 === 'indexedIndirect')\n        ) {\n          return false;\n        }\n        // When the first buffer usage is `index` and is accessible in the draw call, the second\n        // usage cannot be `indirect` (it should be `indexedIndirect` for the tests on indirect draw\n        // calls)\n        if (t.usage0 === 'index' && t.usage0AccessibleInDraw && t.usage1 === 'indirect') {\n          return false;\n        }\n        return true;\n      })\n      .combine('hasOverlap', [true, false])\n  )\n  .fn(async t => {\n    const {\n      // Buffer with usage0 will be \"used\" in the draw call if this value is true.\n      usage0AccessibleInDraw,\n      // Buffer with usage1 will be \"used\" in the draw call if this value is true.\n      usage1AccessibleInDraw,\n      // Whether we will have the draw call before setting the buffer usage as \"usage1\" or not.\n      // If it is true: set-usage0 -> draw -> set-usage1 or indirect-draw -> set-usage1\n      // Otherwise: set-usage0 -> set-usage1 -> draw or set-usage0 -> indirect-draw\n      drawBeforeUsage1,\n      usage0,\n      visibility0,\n      usage1,\n      visibility1,\n      hasOverlap,\n    } = t.params;\n    const buffer = t.createBufferWithState('valid', {\n      size: kBoundBufferSize * 2,\n      usage:\n        GPUBufferUsage.UNIFORM |\n        GPUBufferUsage.STORAGE |\n        GPUBufferUsage.VERTEX |\n        GPUBufferUsage.INDEX |\n        GPUBufferUsage.INDIRECT,\n    });\n\n    const UseBufferOnRenderPassEncoder = (\n      bufferAccessibleInDraw: boolean,\n      bufferIndex: number,\n      offset: number,\n      usage: BufferUsage,\n      bindGroupVisibility: 'compute' | 'fragment',\n      renderPassEncoder: GPURenderPassEncoder,\n      usedBindGroupLayouts: GPUBindGroupLayout[]\n    ) => {\n      switch (usage) {\n        case 'uniform':\n        case 'storage':\n        case 'read-only-storage': {\n          const bindGroup = t.createBindGroupForTest(buffer, offset, usage, bindGroupVisibility);\n          renderPassEncoder.setBindGroup(bufferIndex, bindGroup);\n          // To \"use\" the bind group we will set the corresponding bind group layout in the\n          // pipeline layout when creating the render pipeline.\n          if (bufferAccessibleInDraw && bindGroupVisibility === 'fragment') {\n            usedBindGroupLayouts.push(t.createBindGroupLayoutForTest(usage, bindGroupVisibility));\n          }\n          break;\n        }\n        case 'vertex': {\n          renderPassEncoder.setVertexBuffer(bufferIndex, buffer, offset);\n          break;\n        }\n        case 'index': {\n          renderPassEncoder.setIndexBuffer(buffer, 'uint16', offset);\n          break;\n        }\n        case 'indirect':\n        case 'indexedIndirect': {\n          // We will handle the indirect draw calls later.\n          break;\n        }\n      }\n    };\n\n    const MakeDrawCallWithOneUsage = (\n      usage: BufferUsage,\n      offset: number,\n      renderPassEncoder: GPURenderPassEncoder\n    ) => {\n      switch (usage) {\n        case 'uniform':\n        case 'read-only-storage':\n        case 'storage':\n        case 'vertex':\n          renderPassEncoder.draw(1);\n          break;\n        case 'index':\n          renderPassEncoder.drawIndexed(1);\n          break;\n        case 'indirect':\n          renderPassEncoder.drawIndirect(buffer, offset);\n          break;\n        case 'indexedIndirect': {\n          const indexBuffer = t.device.createBuffer({\n            size: 4,\n            usage: GPUBufferUsage.INDEX,\n          });\n          renderPassEncoder.setIndexBuffer(indexBuffer, 'uint16');\n          renderPassEncoder.drawIndexedIndirect(buffer, offset);\n          break;\n        }\n      }\n    };\n\n    const encoder = t.device.createCommandEncoder();\n    const renderPassEncoder = t.beginSimpleRenderPass(encoder);\n\n    // Set buffer with usage0\n    const offset0 = 0;\n    // Invisible bind groups or vertex buffers are all bound to the slot 1.\n    const bufferIndex0 = visibility0 === 'fragment' ? 0 : 1;\n    const usedBindGroupLayouts: GPUBindGroupLayout[] = [];\n\n    UseBufferOnRenderPassEncoder(\n      usage0AccessibleInDraw,\n      bufferIndex0,\n      offset0,\n      usage0,\n      visibility0,\n      renderPassEncoder,\n      usedBindGroupLayouts\n    );\n\n    let vertexBufferCount = 0;\n\n    // Set pipeline and do draw call if drawBeforeUsage1 === true\n    if (drawBeforeUsage1) {\n      const pipelineLayout = t.device.createPipelineLayout({\n        bindGroupLayouts: usedBindGroupLayouts,\n      });\n      // To \"use\" the vertex buffer we need to set the corresponding vertex buffer layout when\n      // creating the render pipeline.\n      if (usage0 === 'vertex' && usage0AccessibleInDraw) {\n        ++vertexBufferCount;\n      }\n      const pipeline = t.createRenderPipelineForTest(pipelineLayout, vertexBufferCount);\n      renderPassEncoder.setPipeline(pipeline);\n      if (!usage0AccessibleInDraw) {\n        renderPassEncoder.draw(1);\n      } else {\n        MakeDrawCallWithOneUsage(usage0, offset0, renderPassEncoder);\n      }\n    }\n\n    // Set buffer with usage1.\n    const offset1 = hasOverlap ? offset0 : kBoundBufferSize;\n    let bufferIndex1 = 0;\n    if (visibility1 !== 'fragment') {\n      // Invisible bind groups or vertex buffers are all bound to the slot 1.\n      bufferIndex1 = 1;\n    } else if (visibility0 === 'fragment' && usage0AccessibleInDraw) {\n      // When buffer is bound to different bind groups or bound as vertex buffers in one render pass\n      // encoder, the second buffer binding should consume the slot 1.\n      if (IsBufferUsageInBindGroup(usage0) && IsBufferUsageInBindGroup(usage1)) {\n        bufferIndex1 = 1;\n      } else if (usage0 === 'vertex' && usage1 === 'vertex') {\n        bufferIndex1 = 1;\n      }\n    }\n\n    UseBufferOnRenderPassEncoder(\n      usage1AccessibleInDraw,\n      bufferIndex1,\n      offset1,\n      usage1,\n      visibility1,\n      renderPassEncoder,\n      usedBindGroupLayouts\n    );\n\n    // Set pipeline and do draw call if drawBeforeUsage1 === false\n    if (!drawBeforeUsage1) {\n      const pipelineLayout = t.device.createPipelineLayout({\n        bindGroupLayouts: usedBindGroupLayouts,\n      });\n      if (usage1 === 'vertex' && usage1AccessibleInDraw) {\n        // To \"use\" the vertex buffer we need to set the corresponding vertex buffer layout when\n        // creating the render pipeline.\n        ++vertexBufferCount;\n      }\n      const pipeline = t.createRenderPipelineForTest(pipelineLayout, vertexBufferCount);\n      renderPassEncoder.setPipeline(pipeline);\n\n      assert(usage0 !== 'indirect');\n      if (!usage0AccessibleInDraw && !usage1AccessibleInDraw) {\n        renderPassEncoder.draw(1);\n      } else if (usage0AccessibleInDraw && !usage1AccessibleInDraw) {\n        MakeDrawCallWithOneUsage(usage0, offset0, renderPassEncoder);\n      } else if (!usage0AccessibleInDraw && usage1AccessibleInDraw) {\n        MakeDrawCallWithOneUsage(usage1, offset1, renderPassEncoder);\n      } else {\n        if (usage1 === 'indexedIndirect') {\n          // If the index buffer has already been set (as usage0), we won't need to set another\n          // index buffer.\n          if (usage0 !== 'index') {\n            const indexBuffer = t.createBufferWithState('valid', {\n              size: 4,\n              usage: GPUBufferUsage.INDEX,\n            });\n            renderPassEncoder.setIndexBuffer(indexBuffer, 'uint16');\n          }\n          renderPassEncoder.drawIndexedIndirect(buffer, offset1);\n        } else if (usage1 === 'indirect') {\n          assert(usage0 !== 'index');\n          renderPassEncoder.drawIndirect(buffer, offset1);\n        } else if (usage0 === 'index' || usage1 === 'index') {\n          // We need to call drawIndexed to \"use\" the index buffer (as usage0 or usage1).\n          renderPassEncoder.drawIndexed(1);\n        } else {\n          renderPassEncoder.draw(1);\n        }\n      }\n    }\n    renderPassEncoder.end();\n\n    const fail = (usage0 === 'storage') !== (usage1 === 'storage');\n    t.expectValidationError(() => {\n      encoder.finish();\n    }, fail);\n  });\n"],"file":"in_pass_encoder.spec.js"}
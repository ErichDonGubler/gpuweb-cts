{"version":3,"sources":["../../../src/webgpu/util/f32_interval.ts"],"names":["assert","kValue","correctlyRoundedF32","flushSubnormalNumber","isF32Finite","isSubnormalNumber","oneULP","F32Interval","constructor","begin","end","Number","isNaN","NEGATIVE_INFINITY","f32","negative","min","POSITIVE_INFINITY","positive","max","contains","n","i","toInterval","isPoint","span","intervals","length","forEach","Math","toString","infinite","_infinite","undefined","roundAndFlushPointToInterval","op","values","inputs","Set","map","results","impl","roundAndFlushBinaryToInterval","x","y","x_values","y_values","x_inputs","y_inputs","inner_x","inner_y","add","roundAndFlushTernaryToInterval","z","z_values","z_inputs","inner_z","runPointOp","extrema","runBinaryOp","runTernaryOp","correctlyRoundedInterval","impl_n","absoluteErrorInterval","error_range","ulpInterval","numULP","abs","ulp","absInterval","additionInterval","inner_op","sign","impl_x","impl_y","atanInterval","atan","atan2Interval","pi","whole","atan2","ceilInterval","ceil","cosInterval","cos","divisionInterval","Y","lower_bound","upper_bound","expInterval","exp","exp2Interval","pow","floorInterval","floor","logInterval","log","log2Interval","log2","maxInterval","minInterval","multiplicationInterval","appropriate_infinity","negationInterval","sinInterval","sin","subtractionInterval","result"],"mappings":"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","sourcesContent":["import { assert } from '../../common/util/util.js';\n\nimport { kValue } from './constants.js';\nimport {\n  correctlyRoundedF32,\n  flushSubnormalNumber,\n  isF32Finite,\n  isSubnormalNumber,\n  oneULP,\n} from './math.js';\n\n/** Represents a closed interval in the f32 range */\nexport class F32Interval {\n  public readonly begin: number;\n  public readonly end: number;\n  private static _infinite: F32Interval;\n\n  /** Constructor\n   *\n   * Bounds that are out of range for F32 are converted to appropriate edge or\n   * infinity values, so that all values above/below the f32 range are lumped\n   * together.\n   *\n   * @param begin number indicating the lower bound of the interval\n   * @param end number indicating the upper bound of the interval\n   */\n  public constructor(begin: number, end: number) {\n    assert(!Number.isNaN(begin) && !Number.isNaN(end), `bounds need to be non-NaN`);\n    assert(begin <= end, `begin (${begin}) must be equal or before end (${end})`);\n\n    if (begin === Number.NEGATIVE_INFINITY || begin < kValue.f32.negative.min) {\n      this.begin = Number.NEGATIVE_INFINITY;\n    } else if (begin === Number.POSITIVE_INFINITY || begin > kValue.f32.positive.max) {\n      this.begin = kValue.f32.positive.max;\n    } else {\n      this.begin = begin;\n    }\n\n    if (end === Number.POSITIVE_INFINITY || end > kValue.f32.positive.max) {\n      this.end = Number.POSITIVE_INFINITY;\n    } else if (end === Number.NEGATIVE_INFINITY || end < kValue.f32.negative.min) {\n      this.end = kValue.f32.negative.min;\n    } else {\n      this.end = end;\n    }\n  }\n\n  /** @returns if a point or interval is completely contained by this interval\n   *\n   * Due to values that are above/below the f32 range being indistinguishable\n   * from other values out of range in the same way, there some unintuitive\n   * behaviours here, for example:\n   *   [0, greater than max f32].contains(+∞) will return true.\n   */\n  public contains(n: number | F32Interval): boolean {\n    if (Number.isNaN(n)) {\n      // Being the infinite interval indicates that the accuracy is not defined\n      // for this test, so the test is just checking that this input doesn't\n      // cause the implementation to misbehave, so NaN is acceptable.\n      return this.begin === Number.NEGATIVE_INFINITY && this.end === Number.POSITIVE_INFINITY;\n    }\n    const i = toInterval(n);\n    return this.begin <= i.begin && this.end >= i.end;\n  }\n\n  /** @returns if this interval contains a single point */\n  public isPoint(): boolean {\n    return this.begin === this.end;\n  }\n\n  /** @returns an interval with the tightest bounds that includes all provided intervals */\n  static span(...intervals: F32Interval[]): F32Interval {\n    assert(intervals.length > 0, `span of an empty list of F32Intervals is not allowed`);\n    let begin = Number.POSITIVE_INFINITY;\n    let end = Number.NEGATIVE_INFINITY;\n    intervals.forEach(i => {\n      begin = Math.min(i.begin, begin);\n      end = Math.max(i.end, end);\n    });\n    return new F32Interval(begin, end);\n  }\n\n  /** @returns a string representation for logging purposes */\n  public toString(): string {\n    return `[${this.begin}, ${this.end}]`;\n  }\n\n  /** @returns a singleton for the infinite interval\n   * This interval is used in situations where accuracy is not defined, so any\n   * result is valid.\n   */\n  public static infinite(): F32Interval {\n    if (this._infinite === undefined) {\n      this._infinite = new F32Interval(Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY);\n    }\n    return this._infinite;\n  }\n}\n\n/** @returns an interval containing the point or the original interval */\nfunction toInterval(n: number | F32Interval): F32Interval {\n  if (n instanceof F32Interval) {\n    return n;\n  }\n  return new F32Interval(n, n);\n}\n\n/**\n * A function that converts a point to an acceptance interval.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface PointToInterval {\n  (x: number): F32Interval;\n}\n\n/** Operation used to implement a PointToInterval */\ninterface PointToIntervalOp {\n  /** @returns acceptance interval for a function at point x */\n  impl: (x: number) => F32Interval;\n\n  /**\n   * Calculates where in the domain defined by x the min/max extrema of impl\n   * occur and returns a span of those points to be used as the domain instead.\n   *\n   * If not defined the ends of the existing domain are assumed to be the\n   * extrema.\n   *\n   * This is only implemented for functions that meet all of the following\n   * criteria:\n   *   a) non-monotonic\n   *   b) used in inherited accuracy calculations\n   *   c) need to take in an interval for b)\n   *      i.e. fooInterval takes in x: number | F32Interval, not x: number\n   */\n  extrema?: (x: F32Interval) => F32Interval;\n}\n\n/**\n * A function that converts a pair of points to an acceptance interval.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface BinaryToInterval {\n  (x: number, y: number): F32Interval;\n}\n\n/** Operation used to implement a BinaryToInterval */\ninterface BinaryToIntervalOp {\n  /** @returns acceptance interval for a function at point (x, y) */\n  impl: (x: number, y: number) => F32Interval;\n  /**\n   * Calculates where in domain defined by x & y the min/max extrema of impl\n   * occur and returns spans of those points to be used as the domain instead.\n   *\n   * If not defined the ends of the existing domain are assumed to be the\n   * extrema.\n   *\n   * This is only implemented for functions that meet all of the following\n   * criteria:\n   *   a) non-monotonic\n   *   b) used in inherited accuracy calculations\n   *   c) need to take in an interval for b)\n   */\n  extrema?: (x: F32Interval, y: F32Interval) => [F32Interval, F32Interval];\n}\n\n/**\n * A function that converts a triplet of points to an acceptance interval.\n * This is the public facing API for builtin implementations that is called\n * from tests.\n */\nexport interface TernaryToInterval {\n  (x: number, y: number, z: number): F32Interval;\n}\n\n/** Operation used to implement a TernaryToInterval */\ninterface TernaryToIntervalOp {\n  /** @returns acceptance interval for a function at point (x, y, z) */\n  impl: (x: number, y: number, z: number) => F32Interval;\n  // All current ternary operations that are used in inheritance (clamp*) are\n  // monotonic, so extrema calculation isn't needed. Re-using the Op interface\n  // pattern for symmetry with the other operations\n}\n\n/** Converts a point to an acceptance interval, using a specific function\n *\n * This handles correctly rounding and flushing inputs as needed.\n * Duplicate inputs are pruned before invoking op.impl.\n * op.extrema is invoked before this point in the call stack.\n *\n * @param n value to flush & round then invoke op.impl on\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\nfunction roundAndFlushPointToInterval(n: number, op: PointToIntervalOp) {\n  assert(!Number.isNaN(n), `flush not defined for NaN`);\n  const values = correctlyRoundedF32(n);\n  const inputs = new Set<number>([...values, ...values.map(flushSubnormalNumber)]);\n  const results = new Set<F32Interval>([...inputs].map(op.impl));\n  return F32Interval.span(...results);\n}\n\n/** Converts a pair to an acceptance interval, using a specific function\n *\n * This handles correctly rounding and flushing inputs as needed.\n * Duplicate inputs are pruned before invoking op.impl.\n * All unique combinations of x & y are run.\n * op.extrema is invoked before this point in the call stack.\n *\n * @param x first param to flush & round then invoke op.impl on\n * @param y second param to flush & round then invoke op.impl on\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\nfunction roundAndFlushBinaryToInterval(x: number, y: number, op: BinaryToIntervalOp): F32Interval {\n  assert(!Number.isNaN(x), `flush not defined for NaN`);\n  assert(!Number.isNaN(y), `flush not defined for NaN`);\n  const x_values = correctlyRoundedF32(x);\n  const y_values = correctlyRoundedF32(y);\n  const x_inputs = new Set<number>([...x_values, ...x_values.map(flushSubnormalNumber)]);\n  const y_inputs = new Set<number>([...y_values, ...y_values.map(flushSubnormalNumber)]);\n  const intervals = new Set<F32Interval>();\n  x_inputs.forEach(inner_x => {\n    y_inputs.forEach(inner_y => {\n      intervals.add(op.impl(inner_x, inner_y));\n    });\n  });\n  return F32Interval.span(...intervals);\n}\n\n/** Converts a triplet to an acceptance interval, using a specific function\n *\n * This handles correctly rounding and flushing inputs as needed.\n * Duplicate inputs are pruned before invoking op.impl.\n * All unique combinations of x, y & z are run.\n * op.extrema is invoked before this point in the call stack.\n *\n * @param x first param to flush & round then invoke op.impl on\n * @param y second param to flush & round then invoke op.impl on\n * @param z third param to flush & round then invoke op.impl on\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\nfunction roundAndFlushTernaryToInterval(\n  x: number,\n  y: number,\n  z: number,\n  op: TernaryToIntervalOp\n): F32Interval {\n  assert(!Number.isNaN(x), `flush not defined for NaN`);\n  assert(!Number.isNaN(y), `flush not defined for NaN`);\n  assert(!Number.isNaN(z), `flush not defined for NaN`);\n  const x_values = correctlyRoundedF32(x);\n  const y_values = correctlyRoundedF32(y);\n  const z_values = correctlyRoundedF32(z);\n  const x_inputs = new Set<number>([...x_values, ...x_values.map(flushSubnormalNumber)]);\n  const y_inputs = new Set<number>([...y_values, ...y_values.map(flushSubnormalNumber)]);\n  const z_inputs = new Set<number>([...z_values, ...z_values.map(flushSubnormalNumber)]);\n  const intervals = new Set<F32Interval>();\n  // prettier-ignore\n  x_inputs.forEach(inner_x => {\n    y_inputs.forEach(inner_y => {\n      z_inputs.forEach(inner_z => {\n        intervals.add(op.impl(inner_x, inner_y, inner_z));\n      });\n    });\n  });\n\n  return F32Interval.span(...intervals);\n}\n\n/** Calculate the acceptance interval for a unary function over an interval\n *\n * If the interval is actually a point, this just decays to\n * roundAndFlushPointToInterval.\n *\n * The provided domain interval may be adjusted if the operation defines an\n * extrema function.\n *\n * @param x input domain interval\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\nfunction runPointOp(x: F32Interval, op: PointToIntervalOp): F32Interval {\n  if (x.isPoint()) {\n    return roundAndFlushPointToInterval(x.begin, op);\n  }\n\n  if (op.extrema !== undefined) {\n    x = op.extrema(x);\n  }\n  return F32Interval.span(\n    roundAndFlushPointToInterval(x.begin, op),\n    roundAndFlushPointToInterval(x.end, op)\n  );\n}\n\n/** Calculate the acceptance interval for a binary function over an interval\n *\n * The provided domain intervals may be adjusted if the operation defines an\n * extrema function.\n *\n * @param x first input domain interval\n * @param y second input domain interval\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\n// Will be used in test implementations\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction runBinaryOp(x: F32Interval, y: F32Interval, op: BinaryToIntervalOp): F32Interval {\n  if (op.extrema !== undefined) {\n    [x, y] = op.extrema(x, y);\n  }\n  const x_values = new Set<number>([x.begin, x.end]);\n  const y_values = new Set<number>([y.begin, y.end]);\n\n  const results = new Set<F32Interval>();\n  x_values.forEach(inner_x => {\n    y_values.forEach(inner_y => {\n      results.add(roundAndFlushBinaryToInterval(inner_x, inner_y, op));\n    });\n  });\n\n  return F32Interval.span(...results);\n}\n\n/** Calculate the acceptance interval for a ternary function over an interval\n *\n * The provided domain intervals may be adjusted if the operation defines an\n * extrema function.\n *\n * @param x first input domain interval\n * @param y second input domain interval\n * @param z third input domain interval\n * @param op operation defining the function being run\n * @returns a span over all of the outputs of op.impl\n */\n// Will be used in test implementations\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction runTernaryOp(\n  x: F32Interval,\n  y: F32Interval,\n  z: F32Interval,\n  op: TernaryToIntervalOp\n): F32Interval {\n  const x_values = new Set<number>([x.begin, x.end]);\n  const y_values = new Set<number>([y.begin, y.end]);\n  const z_values = new Set<number>([z.begin, z.end]);\n  const results = new Set<F32Interval>();\n  x_values.forEach(inner_x => {\n    y_values.forEach(inner_y => {\n      z_values.forEach(inner_z => {\n        results.add(roundAndFlushTernaryToInterval(inner_x, inner_y, inner_z, op));\n      });\n    });\n  });\n\n  return F32Interval.span(...results);\n}\n\n/** @returns an interval of the correctly rounded values around the point */\nexport function correctlyRoundedInterval(n: number): F32Interval {\n  return roundAndFlushPointToInterval(n, {\n    impl: (impl_n: number) => {\n      assert(!Number.isNaN(impl_n), `absolute not defined for NaN`);\n      return toInterval(impl_n);\n    },\n  });\n}\n\n/** @returns an interval of the absolute error around the point */\nexport function absoluteErrorInterval(n: number, error_range: number): F32Interval {\n  return roundAndFlushPointToInterval(n, {\n    impl: (impl_n: number) => {\n      assert(!Number.isNaN(n), `absolute not defined for NaN`);\n      if (!isF32Finite(n)) {\n        return toInterval(n);\n      }\n\n      return new F32Interval(impl_n - error_range, impl_n + error_range);\n    },\n  });\n}\n\n/** @returns an interval of N * ULP around the point */\nexport function ulpInterval(n: number, numULP: number): F32Interval {\n  numULP = Math.abs(numULP);\n  return roundAndFlushPointToInterval(n, {\n    impl: (impl_n: number) => {\n      if (!isF32Finite(n)) {\n        return toInterval(n);\n      }\n\n      const ulp = oneULP(impl_n);\n      const begin = impl_n - numULP * ulp;\n      const end = impl_n + numULP * ulp;\n\n      return new F32Interval(\n        Math.min(begin, flushSubnormalNumber(begin)),\n        Math.max(end, flushSubnormalNumber(end))\n      );\n    },\n  });\n}\n\n/** Calculate an acceptance interval for abs(n) */\nexport function absInterval(n: number): F32Interval {\n  const op: PointToIntervalOp = {\n    impl: (impl_n: number): F32Interval => {\n      return correctlyRoundedInterval(Math.abs(impl_n));\n    },\n  };\n\n  return runPointOp(toInterval(n), op);\n}\n\n/** Calculate an acceptance interval of x + y */\nexport function additionInterval(x: number | F32Interval, y: number | F32Interval): F32Interval {\n  const inner_op = {\n    impl: (inner_x: number, inner_y: number): F32Interval => {\n      if (!isF32Finite(inner_x) && isF32Finite(inner_y)) {\n        return correctlyRoundedInterval(inner_x);\n      }\n\n      if (isF32Finite(inner_x) && !isF32Finite(inner_y)) {\n        return correctlyRoundedInterval(inner_y);\n      }\n\n      if (!isF32Finite(inner_x) && !isF32Finite(inner_y)) {\n        if (Math.sign(inner_x) === Math.sign(inner_y)) {\n          return correctlyRoundedInterval(inner_x);\n        } else {\n          return F32Interval.infinite();\n        }\n      }\n      return correctlyRoundedInterval(inner_x + inner_y);\n    },\n  };\n\n  const op: BinaryToIntervalOp = {\n    impl: (impl_x: number, impl_y: number): F32Interval => {\n      return roundAndFlushBinaryToInterval(impl_x, impl_y, inner_op);\n    },\n  };\n\n  return runBinaryOp(toInterval(x), toInterval(y), op);\n}\n\n/** Calculate an acceptance interval of atan(x) */\nexport function atanInterval(n: number): F32Interval {\n  const op: PointToIntervalOp = {\n    impl: (impl_n: number): F32Interval => {\n      return ulpInterval(Math.atan(impl_n), 4096);\n    },\n  };\n\n  return runPointOp(toInterval(n), op);\n}\n\n/** Calculate an acceptance interval of atan2(y, x) */\nexport function atan2Interval(y: number | F32Interval, x: number | F32Interval): F32Interval {\n  const op: BinaryToIntervalOp = {\n    impl: (impl_y: number, impl_x: number): F32Interval => {\n      const numULP = 4096;\n      if (impl_y === 0) {\n        if (impl_x === 0) {\n          return F32Interval.infinite();\n        } else {\n          return F32Interval.span(\n            ulpInterval(kValue.f32.negative.pi.whole, numULP),\n            ulpInterval(kValue.f32.positive.pi.whole, numULP)\n          );\n        }\n      }\n      return ulpInterval(Math.atan2(impl_y, impl_x), numULP);\n    },\n    extrema: (y: F32Interval, x: F32Interval): [F32Interval, F32Interval] => {\n      if (y.contains(0)) {\n        if (x.contains(0)) {\n          return [toInterval(0), toInterval(0)];\n        }\n        return [toInterval(0), x];\n      }\n      return [y, x];\n    },\n  };\n\n  return runBinaryOp(toInterval(y), toInterval(x), op);\n}\n\n/** Calculate an acceptance interval of ceil(x) */\nexport function ceilInterval(n: number): F32Interval {\n  const op: PointToIntervalOp = {\n    impl: (impl_n: number): F32Interval => {\n      return correctlyRoundedInterval(Math.ceil(impl_n));\n    },\n  };\n\n  return runPointOp(toInterval(n), op);\n}\n\n/** Calculate an acceptance interval of cos(x) */\nexport function cosInterval(n: number): F32Interval {\n  const op: PointToIntervalOp = {\n    impl: (impl_n: number): F32Interval => {\n      return kValue.f32.negative.pi.whole <= impl_n && impl_n <= kValue.f32.positive.pi.whole\n        ? absoluteErrorInterval(Math.cos(impl_n), 2 ** -11)\n        : F32Interval.infinite();\n    },\n  };\n\n  return runPointOp(toInterval(n), op);\n}\n\n/** Calculate an acceptance interval of x / y */\nexport function divisionInterval(x: number | F32Interval, y: number | F32Interval): F32Interval {\n  const op: BinaryToIntervalOp = {\n    impl: (impl_x: number, impl_y: number): F32Interval => {\n      assert(\n        !isSubnormalNumber(impl_y),\n        `divisionInterval impl should never receive y === 0 or flush(y) === 0`\n      );\n      return ulpInterval(impl_x / impl_y, 2.5);\n    },\n  };\n\n  {\n    const Y = toInterval(y);\n    const lower_bound = 2 ** -126;\n    const upper_bound = 2 ** 126;\n    // division accuracy is not defined outside of |denominator| on [2 ** -126, 2 ** 126]\n    if (\n      !new F32Interval(-upper_bound, -lower_bound).contains(Y) &&\n      !new F32Interval(lower_bound, upper_bound).contains(Y)\n    ) {\n      return F32Interval.infinite();\n    }\n  }\n\n  return runBinaryOp(toInterval(x), toInterval(y), op);\n}\n\n/** Calculate an acceptance interval for exp(x) */\nexport function expInterval(x: number | F32Interval): F32Interval {\n  const op: PointToIntervalOp = {\n    impl: (impl_x: number): F32Interval => {\n      return ulpInterval(Math.exp(impl_x), 3 + 2 * Math.abs(impl_x));\n    },\n  };\n\n  return runPointOp(toInterval(x), op);\n}\n\n/** Calculate an acceptance interval for exp2(x) */\nexport function exp2Interval(x: number | F32Interval): F32Interval {\n  const op: PointToIntervalOp = {\n    impl: (impl_x: number): F32Interval => {\n      return ulpInterval(Math.pow(2, impl_x), 3 + 2 * Math.abs(impl_x));\n    },\n  };\n\n  return runPointOp(toInterval(x), op);\n}\n\n/** Calculate an acceptance interval of floor(x) */\nexport function floorInterval(n: number): F32Interval {\n  const op: PointToIntervalOp = {\n    impl: (impl_n: number): F32Interval => {\n      return correctlyRoundedInterval(Math.floor(impl_n));\n    },\n  };\n\n  return runPointOp(toInterval(n), op);\n}\n\n/** Calculate an acceptance interval of log(x) */\nexport function logInterval(x: number | F32Interval): F32Interval {\n  const op: PointToIntervalOp = {\n    impl: (impl_x: number): F32Interval => {\n      if (x >= 0.5 && x <= 2.0) {\n        return absoluteErrorInterval(Math.log(impl_x), 2 ** -21);\n      }\n      return ulpInterval(Math.log(impl_x), 3);\n    },\n  };\n\n  return runPointOp(toInterval(x), op);\n}\n\n/** Calculate an acceptance interval of log2(x) */\nexport function log2Interval(x: number | F32Interval): F32Interval {\n  const op: PointToIntervalOp = {\n    impl: (impl_x: number): F32Interval => {\n      if (x >= 0.5 && x <= 2.0) {\n        return absoluteErrorInterval(Math.log2(impl_x), 2 ** -21);\n      }\n      return ulpInterval(Math.log2(impl_x), 3);\n    },\n  };\n\n  return runPointOp(toInterval(x), op);\n}\n\n/** Calculate an acceptance interval of max(x, y) */\nexport function maxInterval(x: number | F32Interval, y: number | F32Interval): F32Interval {\n  const op: BinaryToIntervalOp = {\n    impl: (impl_x: number, impl_y: number): F32Interval => {\n      return correctlyRoundedInterval(Math.max(impl_x, impl_y));\n    },\n  };\n\n  return runBinaryOp(toInterval(x), toInterval(y), op);\n}\n\n/** Calculate an acceptance interval of min(x, y) */\nexport function minInterval(x: number | F32Interval, y: number | F32Interval): F32Interval {\n  const op: BinaryToIntervalOp = {\n    impl: (impl_x: number, impl_y: number): F32Interval => {\n      return correctlyRoundedInterval(Math.min(impl_x, impl_y));\n    },\n  };\n\n  return runBinaryOp(toInterval(x), toInterval(y), op);\n}\n\n/** Calculate an acceptance interval of x * y */\nexport function multiplicationInterval(\n  x: number | F32Interval,\n  y: number | F32Interval\n): F32Interval {\n  const inner_op = {\n    impl: (inner_x: number, inner_y: number): F32Interval => {\n      if (inner_x === 0 || inner_y === 0) {\n        return correctlyRoundedInterval(0);\n      }\n\n      const appropriate_infinity =\n        Math.sign(inner_x) === Math.sign(inner_y)\n          ? Number.POSITIVE_INFINITY\n          : Number.NEGATIVE_INFINITY;\n\n      if (!isF32Finite(inner_x) || !isF32Finite(inner_y)) {\n        return correctlyRoundedInterval(appropriate_infinity);\n      }\n\n      return correctlyRoundedInterval(inner_x * inner_y);\n    },\n  };\n\n  const op: BinaryToIntervalOp = {\n    impl: (impl_x: number, impl_y: number): F32Interval => {\n      return roundAndFlushBinaryToInterval(impl_x, impl_y, inner_op);\n    },\n  };\n\n  return runBinaryOp(toInterval(x), toInterval(y), op);\n}\n\n/** Calculate an acceptance interval of -x */\nexport function negationInterval(n: number): F32Interval {\n  const op: PointToIntervalOp = {\n    impl: (impl_n: number): F32Interval => {\n      return correctlyRoundedInterval(-impl_n);\n    },\n  };\n\n  return runPointOp(toInterval(n), op);\n}\n\n/** Calculate an acceptance interval of sin(x) */\nexport function sinInterval(n: number): F32Interval {\n  const op: PointToIntervalOp = {\n    impl: (impl_n: number): F32Interval => {\n      return kValue.f32.negative.pi.whole <= impl_n && impl_n <= kValue.f32.positive.pi.whole\n        ? absoluteErrorInterval(Math.sin(impl_n), 2 ** -11)\n        : F32Interval.infinite();\n    },\n  };\n\n  return runPointOp(toInterval(n), op);\n}\n\n/** Calculate an acceptance interval of x - y */\nexport function subtractionInterval(x: number | F32Interval, y: number | F32Interval): F32Interval {\n  const inner_op: BinaryToIntervalOp = {\n    impl: (inner_x: number, inner_y: number): F32Interval => {\n      if (!isF32Finite(inner_x) && isF32Finite(inner_y)) {\n        return correctlyRoundedInterval(inner_x);\n      }\n\n      if (isF32Finite(inner_x) && !isF32Finite(inner_y)) {\n        const result = Math.sign(inner_y) > 0 ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;\n        return correctlyRoundedInterval(result);\n      }\n\n      if (!isF32Finite(inner_x) && !isF32Finite(inner_y)) {\n        if (Math.sign(inner_x) === -Math.sign(inner_y)) {\n          return correctlyRoundedInterval(inner_x);\n        } else {\n          return F32Interval.infinite();\n        }\n      }\n      return correctlyRoundedInterval(inner_x - inner_y);\n    },\n  };\n\n  const op: BinaryToIntervalOp = {\n    impl: (impl_x: number, impl_y: number): F32Interval => {\n      return roundAndFlushBinaryToInterval(impl_x, impl_y, inner_op);\n    },\n  };\n\n  return runBinaryOp(toInterval(x), toInterval(y), op);\n}\n"],"file":"f32_interval.js"}
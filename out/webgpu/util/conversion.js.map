{"version":3,"sources":["../../../src/webgpu/util/conversion.ts"],"names":["Colors","assert","Float16Array","kBit","cartesianProduct","clamp","correctlyRoundedF16","isFiniteF16","isSubnormalNumberF16","isSubnormalNumberF32","floatAsNormalizedInteger","float","bits","signed","max","Math","pow","round","normalizedIntegerAsFloat","integer","Number","isInteger","float32ToFloatBits","n","signBits","exponentBits","mantissaBits","bias","isFinite","buf","DataView","ArrayBuffer","Float32Array","BYTES_PER_ELEMENT","setFloat32","getUint32","mantissaBitsToDiscard","sign","exp","newBiasedExp","newMantissa","float32ToFloat16Bits","float16BitsToFloat32","float16Bits","floatBitsToNumber","kFloat16Format","kFloat32Format","workingData","workingDataU32","Uint32Array","workingDataU16","Uint16Array","workingDataI16","Int16Array","workingDataF32","workingDataF16","float32BitsToNumber","numberToFloat32Bits","number","fmt","kNonSignBits","kNonSignBitsMask","expAndMantBits","f32BitsWithWrongBias","numberWithWrongBias","numberToFloatBits","floatBitsToNormalULPFromZero","mask_sign","mask_expt","mask_mant","mask_rest","rest","subnormal_or_zero","infinity_or_nan","abs_ulp_from_zero","packRGB9E5UFloat","r","g","b","v","extractMantissaAndExponent","biasedExponent","mantissa","rExp","rOrigMantissa","gExp","gOrigMantissa","bExp","bOrigMantissa","rMantissa","gMantissa","bMantissa","biasedExp","pack2x16float","x","y","generateU16s","contains_subnormals","n_f16s","some","n_u16s","map","f16","contains_poszero","u","positive","zero","contains_negzero","negative","push","undefined","u16_pairs","results","Array","p","length","pack2x16snorm","generateI16","floor","min","pack2x16unorm","generateU16","assertInIntegerRange","gammaCompress","gammaDecompress","float32ToUint32","f32","f32Arr","u32Arr","buffer","uint32ToFloat32","u32","float32ToInt32","i32Arr","Int32Array","uint32ToInt32","float16ToUint16","f16Arr","u16Arr","uint16ToFloat16","u16","float16ToInt16","i16Arr","ScalarType","constructor","kind","size","read","toString","VectorType","width","elementType","offset","elements","i","Vector","vectorTypes","Map","TypeVec","key","ty","get","set","TypeI32","i32","TypeU32","TypeF64","Float64Array","TypeF32","TypeI16","i16","TypeU16","TypeF16","f16Bits","TypeI8","i8","Int8Array","TypeU8","u8","Uint8Array","TypeBool","bool","scalarType","numElementsOf","Error","scalarTypeOf","Scalar","type","value","copyTo","wgsl","withPoint","str","indexOf","POSITIVE_INFINITY","NEGATIVE_INFINITY","bold","Infinity","hex","from","reverse","padStart","join","isFloatValue","valueOf","f64","arr","f32Bits","i32Bits","i16Bits","i8Bits","u32Bits","u16Bits","u8Bits","True","False","a","element","els","e","z","w","vec2","vec3","vec4","s"],"mappings":"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","sourcesContent":["import { Colors } from '../../common/util/colors.js';\nimport { assert, TypedArrayBufferView } from '../../common/util/util.js';\nimport { Float16Array } from '../../external/petamoriken/float16/float16.js';\n\nimport { kBit } from './constants.js';\nimport {\n  cartesianProduct,\n  clamp,\n  correctlyRoundedF16,\n  isFiniteF16,\n  isSubnormalNumberF16,\n  isSubnormalNumberF32,\n} from './math.js';\n\n/**\n * Encodes a JS `number` into a \"normalized\" (unorm/snorm) integer representation with `bits` bits.\n * Input must be between -1 and 1 if signed, or 0 and 1 if unsigned.\n *\n * MAINTENANCE_TODO: See if performance of texel_data improves if this function is pre-specialized\n * for a particular `bits`/`signed`.\n */\nexport function floatAsNormalizedInteger(float: number, bits: number, signed: boolean): number {\n  if (signed) {\n    assert(float >= -1 && float <= 1, () => `${float} out of bounds of snorm`);\n    const max = Math.pow(2, bits - 1) - 1;\n    return Math.round(float * max);\n  } else {\n    assert(float >= 0 && float <= 1, () => `${float} out of bounds of unorm`);\n    const max = Math.pow(2, bits) - 1;\n    return Math.round(float * max);\n  }\n}\n\n/**\n * Decodes a JS `number` from a \"normalized\" (unorm/snorm) integer representation with `bits` bits.\n * Input must be an integer in the range of the specified unorm/snorm type.\n */\nexport function normalizedIntegerAsFloat(integer: number, bits: number, signed: boolean): number {\n  assert(Number.isInteger(integer));\n  if (signed) {\n    const max = Math.pow(2, bits - 1) - 1;\n    assert(integer >= -max - 1 && integer <= max);\n    if (integer === -max - 1) {\n      integer = -max;\n    }\n    return integer / max;\n  } else {\n    const max = Math.pow(2, bits) - 1;\n    assert(integer >= 0 && integer <= max);\n    return integer / max;\n  }\n}\n\n/**\n * Encodes a JS `number` into an IEEE754 floating point number with the specified number of\n * sign, exponent, mantissa bits, and exponent bias.\n * Returns the result as an integer-valued JS `number`.\n *\n * Does not handle clamping, overflow, or denormal inputs.\n * On underflow (result is subnormal), rounds to (signed) zero.\n *\n * MAINTENANCE_TODO: Replace usages of this with numberToFloatBits.\n */\nexport function float32ToFloatBits(\n  n: number,\n  signBits: 0 | 1,\n  exponentBits: number,\n  mantissaBits: number,\n  bias: number\n): number {\n  assert(exponentBits <= 8);\n  assert(mantissaBits <= 23);\n  assert(Number.isFinite(n));\n\n  if (n === 0) {\n    return 0;\n  }\n\n  if (signBits === 0) {\n    assert(n >= 0);\n  }\n\n  const buf = new DataView(new ArrayBuffer(Float32Array.BYTES_PER_ELEMENT));\n  buf.setFloat32(0, n, true);\n  const bits = buf.getUint32(0, true);\n  // bits (32): seeeeeeeefffffffffffffffffffffff\n\n  const mantissaBitsToDiscard = 23 - mantissaBits;\n\n  // 0 or 1\n  const sign = (bits >> 31) & signBits;\n\n  // >> to remove mantissa, & to remove sign, - 127 to remove bias.\n  const exp = ((bits >> 23) & 0xff) - 127;\n\n  // Convert to the new biased exponent.\n  const newBiasedExp = bias + exp;\n  assert(newBiasedExp < 1 << exponentBits, () => `input number ${n} overflows target type`);\n\n  if (newBiasedExp <= 0) {\n    // Result is subnormal or zero. Round to (signed) zero.\n    return sign << (exponentBits + mantissaBits);\n  } else {\n    // Mask only the mantissa, and discard the lower bits.\n    const newMantissa = (bits & 0x7fffff) >> mantissaBitsToDiscard;\n    return (sign << (exponentBits + mantissaBits)) | (newBiasedExp << mantissaBits) | newMantissa;\n  }\n}\n\n/**\n * Encodes a JS `number` into an IEEE754 16 bit floating point number.\n * Returns the result as an integer-valued JS `number`.\n *\n * Does not handle clamping, overflow, or denormal inputs.\n * On underflow (result is subnormal), rounds to (signed) zero.\n */\nexport function float32ToFloat16Bits(n: number) {\n  return float32ToFloatBits(n, 1, 5, 10, 15);\n}\n\n/**\n * Decodes an IEEE754 16 bit floating point number into a JS `number` and returns.\n */\nexport function float16BitsToFloat32(float16Bits: number): number {\n  return floatBitsToNumber(float16Bits, kFloat16Format);\n}\n\ntype FloatFormat = { signed: 0 | 1; exponentBits: number; mantissaBits: number; bias: number };\n\n/** FloatFormat defining IEEE754 32-bit float. */\nexport const kFloat32Format = { signed: 1, exponentBits: 8, mantissaBits: 23, bias: 127 } as const;\n/** FloatFormat defining IEEE754 16-bit float. */\nexport const kFloat16Format = { signed: 1, exponentBits: 5, mantissaBits: 10, bias: 15 } as const;\n\n/** Once-allocated ArrayBuffer/views  to avoid overhead of allocation when converting between numeric formats */\nconst workingData = new ArrayBuffer(4);\nconst workingDataU32 = new Uint32Array(workingData);\nconst workingDataU16 = new Uint16Array(workingData);\nconst workingDataI16 = new Int16Array(workingData);\nconst workingDataF32 = new Float32Array(workingData);\nconst workingDataF16 = new Float16Array(workingData);\n\n/** Bitcast u32 (represented as integer Number) to f32 (represented as floating-point Number). */\nexport function float32BitsToNumber(bits: number): number {\n  workingDataU32[0] = bits;\n  return workingDataF32[0];\n}\n/** Bitcast f32 (represented as floating-point Number) to u32 (represented as integer Number). */\nexport function numberToFloat32Bits(number: number): number {\n  workingDataF32[0] = number;\n  return workingDataU32[0];\n}\n\n/**\n * Decodes an IEEE754 float with the supplied format specification into a JS number.\n *\n * The format MUST be no larger than a 32-bit float.\n */\nexport function floatBitsToNumber(bits: number, fmt: FloatFormat): number {\n  // Pad the provided bits out to f32, then convert to a `number` with the wrong bias.\n  // E.g. for f16 to f32:\n  // - f16: S    EEEEE MMMMMMMMMM\n  //        ^ 000^^^^^ ^^^^^^^^^^0000000000000\n  // - f32: S eeeEEEEE MMMMMMMMMMmmmmmmmmmmmmm\n\n  const kNonSignBits = fmt.exponentBits + fmt.mantissaBits;\n  const kNonSignBitsMask = (1 << kNonSignBits) - 1;\n  const expAndMantBits = bits & kNonSignBitsMask;\n  let f32BitsWithWrongBias = expAndMantBits << (kFloat32Format.mantissaBits - fmt.mantissaBits);\n  f32BitsWithWrongBias |= (bits << (31 - kNonSignBits)) & 0x8000_0000;\n  const numberWithWrongBias = float32BitsToNumber(f32BitsWithWrongBias);\n  return numberWithWrongBias * 2 ** (kFloat32Format.bias - fmt.bias);\n}\n\n/**\n * Encodes a JS `number` into an IEEE754 floating point number with the specified format.\n * Returns the result as an integer-valued JS `number`.\n *\n * Does not handle clamping, overflow, or denormal inputs.\n * On underflow (result is subnormal), rounds to (signed) zero.\n */\nexport function numberToFloatBits(number: number, fmt: FloatFormat): number {\n  return float32ToFloatBits(number, fmt.signed, fmt.exponentBits, fmt.mantissaBits, fmt.bias);\n}\n\n/**\n * Given a floating point number (as an integer representing its bits), computes how many ULPs it is\n * from zero.\n *\n * Subnormal numbers are skipped, so that 0 is one ULP from the minimum normal number.\n * Subnormal values are flushed to 0.\n * Positive and negative 0 are both considered to be 0 ULPs from 0.\n */\nexport function floatBitsToNormalULPFromZero(bits: number, fmt: FloatFormat): number {\n  const mask_sign = fmt.signed << (fmt.exponentBits + fmt.mantissaBits);\n  const mask_expt = ((1 << fmt.exponentBits) - 1) << fmt.mantissaBits;\n  const mask_mant = (1 << fmt.mantissaBits) - 1;\n  const mask_rest = mask_expt | mask_mant;\n\n  assert(fmt.exponentBits + fmt.mantissaBits <= 31);\n\n  const sign = bits & mask_sign ? -1 : 1;\n  const rest = bits & mask_rest;\n  const subnormal_or_zero = (bits & mask_expt) === 0;\n  const infinity_or_nan = (bits & mask_expt) === mask_expt;\n  assert(!infinity_or_nan, 'no ulp representation for infinity/nan');\n\n  // The first normal number is mask_mant+1, so subtract mask_mant to make min_normal - zero = 1ULP.\n  const abs_ulp_from_zero = subnormal_or_zero ? 0 : rest - mask_mant;\n  return sign * abs_ulp_from_zero;\n}\n\n/**\n * Encodes three JS `number` values into RGB9E5, returned as an integer-valued JS `number`.\n *\n * RGB9E5 represents three partial-precision floating-point numbers encoded into a single 32-bit\n * value all sharing the same 5-bit exponent.\n * There is no sign bit, and there is a shared 5-bit biased (15) exponent and a 9-bit\n * mantissa for each channel. The mantissa does NOT have an implicit leading \"1.\",\n * and instead has an implicit leading \"0.\".\n */\nexport function packRGB9E5UFloat(r: number, g: number, b: number): number {\n  for (const v of [r, g, b]) {\n    assert(v >= 0 && v < Math.pow(2, 16));\n  }\n\n  const buf = new DataView(new ArrayBuffer(Float32Array.BYTES_PER_ELEMENT));\n  const extractMantissaAndExponent = (n: number) => {\n    const mantissaBits = 9;\n    buf.setFloat32(0, n, true);\n    const bits = buf.getUint32(0, true);\n    // >> to remove mantissa, & to remove sign\n    let biasedExponent = (bits >> 23) & 0xff;\n    const mantissaBitsToDiscard = 23 - mantissaBits;\n    let mantissa = (bits & 0x7fffff) >> mantissaBitsToDiscard;\n\n    // RGB9E5UFloat has an implicit leading 0. instead of a leading 1.,\n    // so we need to move the 1. into the mantissa and bump the exponent.\n    // For float32 encoding, the leading 1 is only present if the biased\n    // exponent is non-zero.\n    if (biasedExponent !== 0) {\n      mantissa = (mantissa >> 1) | 0b100000000;\n      biasedExponent += 1;\n    }\n    return { biasedExponent, mantissa };\n  };\n\n  const { biasedExponent: rExp, mantissa: rOrigMantissa } = extractMantissaAndExponent(r);\n  const { biasedExponent: gExp, mantissa: gOrigMantissa } = extractMantissaAndExponent(g);\n  const { biasedExponent: bExp, mantissa: bOrigMantissa } = extractMantissaAndExponent(b);\n\n  // Use the largest exponent, and shift the mantissa accordingly\n  const exp = Math.max(rExp, gExp, bExp);\n  const rMantissa = rOrigMantissa >> (exp - rExp);\n  const gMantissa = gOrigMantissa >> (exp - gExp);\n  const bMantissa = bOrigMantissa >> (exp - bExp);\n\n  const bias = 15;\n  const biasedExp = exp === 0 ? 0 : exp - 127 + bias;\n  assert(biasedExp >= 0 && biasedExp <= 31);\n  return rMantissa | (gMantissa << 9) | (bMantissa << 18) | (biasedExp << 27);\n}\n\n/**\n * Quantizes two f32s to f16 and then packs them in a u32\n *\n * This should implement the same behaviour as the builtin `pack2x16float` from\n * WGSL.\n *\n * Caller is responsible to ensuring inputs are f32s\n *\n * @param x first f32 to be packed\n * @param y second f32 to be packed\n * @returns an array of possible results for pack2x16float. Elements are either\n *          a number or undefined.\n *          undefined indicates that any value is valid, since the input went\n *          out of bounds.\n */\nexport function pack2x16float(x: number, y: number): (number | undefined)[] {\n  // Generates all possible valid u16 bit fields for a given f32 to f16 conversion.\n  // Assumes FTZ for both the f32 and f16 value is allowed.\n  const generateU16s = (n: number): number[] => {\n    let contains_subnormals = isSubnormalNumberF32(n);\n    const n_f16s = correctlyRoundedF16(n);\n    contains_subnormals ||= n_f16s.some(isSubnormalNumberF16);\n\n    const n_u16s = n_f16s.map(f16 => {\n      workingDataF16[0] = f16;\n      return workingDataU16[0];\n    });\n\n    const contains_poszero = n_u16s.some(u => u === kBit.f16.positive.zero);\n    const contains_negzero = n_u16s.some(u => u === kBit.f16.negative.zero);\n    if (!contains_negzero && (contains_poszero || contains_subnormals)) {\n      n_u16s.push(kBit.f16.negative.zero);\n    }\n\n    if (!contains_poszero && (contains_negzero || contains_subnormals)) {\n      n_u16s.push(kBit.f16.positive.zero);\n    }\n\n    return n_u16s;\n  };\n\n  if (!isFiniteF16(x) || !isFiniteF16(y)) {\n    // This indicates any value is valid, so it isn't worth bothering\n    // calculating the more restrictive possibilities.\n    return [undefined];\n  }\n\n  const u16_pairs = cartesianProduct(generateU16s(x), generateU16s(y));\n\n  const results = new Array<number>();\n  for (const p of u16_pairs) {\n    assert(p.length === 2, 'cartesianProduct of 2 arrays returned an entry with not 2 elements');\n    workingDataU16[0] = p[0];\n    workingDataU16[1] = p[1];\n    results.push(workingDataU32[0]);\n  }\n\n  return results;\n}\n\n/**\n * Converts two normalized f32s to i16s and then packs them in a u32\n *\n * This should implement the same behaviour as the builtin `pack2x16snorm` from\n * WGSL.\n *\n * Caller is responsible to ensuring inputs are normalized f32s\n *\n * @param x first f32 to be packed\n * @param y second f32 to be packed\n * @returns a number that is expected result of pack2x16snorm.\n */\nexport function pack2x16snorm(x: number, y: number): number {\n  // Converts f32 to i16 via the pack2x16snorm formula.\n  // FTZ is not explicitly handled, because all subnormals will produce a value\n  // between 0 and 1, but significantly away from the edges, so floor goes to 0.\n  const generateI16 = (n: number): number => {\n    return Math.floor(0.5 + 32767 * Math.min(1, Math.max(-1, n)));\n  };\n\n  workingDataI16[0] = generateI16(x);\n  workingDataI16[1] = generateI16(y);\n  return workingDataU32[0];\n}\n\n/**\n * Converts two normalized f32s to u16s and then packs them in a u32\n *\n * This should implement the same behaviour as the builtin `pack2x16unorm` from\n * WGSL.\n *\n * Caller is responsible to ensuring inputs are normalized f32s\n *\n * @param x first f32 to be packed\n * @param y second f32 to be packed\n * @returns an number that is expected result of pack2x16unorm.\n */\nexport function pack2x16unorm(x: number, y: number): number {\n  // Converts f32 to u16 via the pack2x16unorm formula.\n  // FTZ is not explicitly handled, because all subnormals will produce a value\n  // between 0.5 and much less than 1, so floor goes to 0.\n  const generateU16 = (n: number): number => {\n    return Math.floor(0.5 + 65535 * Math.min(1, Math.max(0, n)));\n  };\n\n  workingDataU16[0] = generateU16(x);\n  workingDataU16[1] = generateU16(y);\n  return workingDataU32[0];\n}\n\n/**\n * Asserts that a number is within the representable (inclusive) of the integer type with the\n * specified number of bits and signedness.\n *\n * MAINTENANCE_TODO: Assert isInteger? Then this function \"asserts that a number is representable\"\n * by the type.\n */\nexport function assertInIntegerRange(n: number, bits: number, signed: boolean): void {\n  if (signed) {\n    const min = -Math.pow(2, bits - 1);\n    const max = Math.pow(2, bits - 1) - 1;\n    assert(n >= min && n <= max);\n  } else {\n    const max = Math.pow(2, bits) - 1;\n    assert(n >= 0 && n <= max);\n  }\n}\n\n/**\n * Converts a linear value into a \"gamma\"-encoded value using the sRGB-clamped transfer function.\n */\nexport function gammaCompress(n: number): number {\n  n = n <= 0.0031308 ? (323 * n) / 25 : (211 * Math.pow(n, 5 / 12) - 11) / 200;\n  return clamp(n, { min: 0, max: 1 });\n}\n\n/**\n * Converts a \"gamma\"-encoded value into a linear value using the sRGB-clamped transfer function.\n */\nexport function gammaDecompress(n: number): number {\n  n = n <= 0.04045 ? (n * 25) / 323 : Math.pow((200 * n + 11) / 211, 12 / 5);\n  return clamp(n, { min: 0, max: 1 });\n}\n\n/** Converts a 32-bit float value to a 32-bit unsigned integer value */\nexport function float32ToUint32(f32: number): number {\n  const f32Arr = new Float32Array(1);\n  f32Arr[0] = f32;\n  const u32Arr = new Uint32Array(f32Arr.buffer);\n  return u32Arr[0];\n}\n\n/** Converts a 32-bit unsigned integer value to a 32-bit float value */\nexport function uint32ToFloat32(u32: number): number {\n  const u32Arr = new Uint32Array(1);\n  u32Arr[0] = u32;\n  const f32Arr = new Float32Array(u32Arr.buffer);\n  return f32Arr[0];\n}\n\n/** Converts a 32-bit float value to a 32-bit signed integer value */\nexport function float32ToInt32(f32: number): number {\n  const f32Arr = new Float32Array(1);\n  f32Arr[0] = f32;\n  const i32Arr = new Int32Array(f32Arr.buffer);\n  return i32Arr[0];\n}\n\n/** Converts a 32-bit unsigned integer value to a 32-bit signed integer value */\nexport function uint32ToInt32(u32: number): number {\n  const u32Arr = new Uint32Array(1);\n  u32Arr[0] = u32;\n  const i32Arr = new Int32Array(u32Arr.buffer);\n  return i32Arr[0];\n}\n\n/** Converts a 16-bit float value to a 16-bit unsigned integer value */\nexport function float16ToUint16(f16: number): number {\n  const f16Arr = new Float16Array(1);\n  f16Arr[0] = f16;\n  const u16Arr = new Uint16Array(f16Arr.buffer);\n  return u16Arr[0];\n}\n\n/** Converts a 16-bit unsigned integer value to a 16-bit float value */\nexport function uint16ToFloat16(u16: number): number {\n  const u16Arr = new Uint16Array(1);\n  u16Arr[0] = u16;\n  const f16Arr = new Float16Array(u16Arr.buffer);\n  return f16Arr[0];\n}\n\n/** Converts a 16-bit float value to a 16-bit signed integer value */\nexport function float16ToInt16(f16: number): number {\n  const f16Arr = new Float16Array(1);\n  f16Arr[0] = f16;\n  const i16Arr = new Int16Array(f16Arr.buffer);\n  return i16Arr[0];\n}\n\n/** A type of number representable by Scalar. */\nexport type ScalarKind =\n  | 'f64'\n  | 'f32'\n  | 'f16'\n  | 'u32'\n  | 'u16'\n  | 'u8'\n  | 'i32'\n  | 'i16'\n  | 'i8'\n  | 'bool';\n\n/** ScalarType describes the type of WGSL Scalar. */\nexport class ScalarType {\n  readonly kind: ScalarKind; // The named type\n  readonly size: number; // In bytes\n  readonly read: (buf: Uint8Array, offset: number) => Scalar; // reads a scalar from a buffer\n\n  constructor(kind: ScalarKind, size: number, read: (buf: Uint8Array, offset: number) => Scalar) {\n    this.kind = kind;\n    this.size = size;\n    this.read = read;\n  }\n\n  public toString(): string {\n    return this.kind;\n  }\n}\n\n/** ScalarType describes the type of WGSL Vector. */\nexport class VectorType {\n  readonly width: number; // Number of elements in the vector\n  readonly elementType: ScalarType; // Element type\n\n  constructor(width: number, elementType: ScalarType) {\n    this.width = width;\n    this.elementType = elementType;\n  }\n\n  /**\n   * @returns a vector constructed from the values read from the buffer at the\n   * given byte offset\n   */\n  public read(buf: Uint8Array, offset: number): Vector {\n    const elements: Array<Scalar> = [];\n    for (let i = 0; i < this.width; i++) {\n      elements[i] = this.elementType.read(buf, offset);\n      offset += this.elementType.size;\n    }\n    return new Vector(elements);\n  }\n\n  public toString(): string {\n    return `vec${this.width}<${this.elementType}>`;\n  }\n}\n\n// Maps a string representation of a vector type to vector type.\nconst vectorTypes = new Map<string, VectorType>();\n\nexport function TypeVec(width: number, elementType: ScalarType): VectorType {\n  const key = `${elementType.toString()} ${width}}`;\n  let ty = vectorTypes.get(key);\n  if (ty !== undefined) {\n    return ty;\n  }\n  ty = new VectorType(width, elementType);\n  vectorTypes.set(key, ty);\n  return ty;\n}\n\n/** Type is a ScalarType or VectorType. */\nexport type Type = ScalarType | VectorType;\n\nexport const TypeI32 = new ScalarType('i32', 4, (buf: Uint8Array, offset: number) =>\n  i32(new Int32Array(buf.buffer, offset)[0])\n);\nexport const TypeU32 = new ScalarType('u32', 4, (buf: Uint8Array, offset: number) =>\n  u32(new Uint32Array(buf.buffer, offset)[0])\n);\nexport const TypeF64 = new ScalarType('f64', 8, (buf: Uint8Array, offset: number) =>\n  f32(new Float64Array(buf.buffer, offset)[0])\n);\nexport const TypeF32 = new ScalarType('f32', 4, (buf: Uint8Array, offset: number) =>\n  f32(new Float32Array(buf.buffer, offset)[0])\n);\nexport const TypeI16 = new ScalarType('i16', 2, (buf: Uint8Array, offset: number) =>\n  i16(new Int16Array(buf.buffer, offset)[0])\n);\nexport const TypeU16 = new ScalarType('u16', 2, (buf: Uint8Array, offset: number) =>\n  u16(new Uint16Array(buf.buffer, offset)[0])\n);\nexport const TypeF16 = new ScalarType('f16', 2, (buf: Uint8Array, offset: number) =>\n  f16Bits(new Uint16Array(buf.buffer, offset)[0])\n);\nexport const TypeI8 = new ScalarType('i8', 1, (buf: Uint8Array, offset: number) =>\n  i8(new Int8Array(buf.buffer, offset)[0])\n);\nexport const TypeU8 = new ScalarType('u8', 1, (buf: Uint8Array, offset: number) =>\n  u8(new Uint8Array(buf.buffer, offset)[0])\n);\nexport const TypeBool = new ScalarType('bool', 4, (buf: Uint8Array, offset: number) =>\n  bool(new Uint32Array(buf.buffer, offset)[0] !== 0)\n);\n\n/** @returns the ScalarType from the ScalarKind */\nexport function scalarType(kind: ScalarKind): ScalarType {\n  switch (kind) {\n    case 'f64':\n      return TypeF64;\n    case 'f32':\n      return TypeF32;\n    case 'f16':\n      return TypeF16;\n    case 'u32':\n      return TypeU32;\n    case 'u16':\n      return TypeU16;\n    case 'u8':\n      return TypeU8;\n    case 'i32':\n      return TypeI32;\n    case 'i16':\n      return TypeI16;\n    case 'i8':\n      return TypeI8;\n    case 'bool':\n      return TypeBool;\n  }\n}\n\n/** @returns the number of scalar (element) types of the given Type */\nexport function numElementsOf(ty: Type): number {\n  if (ty instanceof ScalarType) {\n    return 1;\n  }\n  if (ty instanceof VectorType) {\n    return ty.width;\n  }\n  throw new Error(`unhandled type ${ty}`);\n}\n\n/** @returns the scalar (element) type of the given Type */\nexport function scalarTypeOf(ty: Type): ScalarType {\n  if (ty instanceof ScalarType) {\n    return ty;\n  }\n  if (ty instanceof VectorType) {\n    return ty.elementType;\n  }\n  throw new Error(`unhandled type ${ty}`);\n}\n\n/** ScalarValue is the JS type that can be held by a Scalar */\ntype ScalarValue = Boolean | Number;\n\n/** Class that encapsulates a single scalar value of various types. */\nexport class Scalar {\n  readonly value: ScalarValue; // The scalar value\n  readonly type: ScalarType; // The type of the scalar\n  readonly bits: Uint8Array; // The scalar value packed in a Uint8Array\n\n  public constructor(type: ScalarType, value: ScalarValue, bits: TypedArrayBufferView) {\n    this.value = value;\n    this.type = type;\n    this.bits = new Uint8Array(bits.buffer);\n  }\n\n  /**\n   * Copies the scalar value to the Uint8Array buffer at the provided byte offset.\n   * @param buffer the destination buffer\n   * @param offset the byte offset within buffer\n   */\n  public copyTo(buffer: Uint8Array, offset: number) {\n    for (let i = 0; i < this.bits.length; i++) {\n      buffer[offset + i] = this.bits[i];\n    }\n  }\n\n  /**\n   * @returns the WGSL representation of this scalar value\n   */\n  public wgsl(): string {\n    const withPoint = (x: number) => {\n      const str = `${x}`;\n      return str.indexOf('.') > 0 || str.indexOf('e') > 0 ? str : `${str}.0`;\n    };\n    if (isFinite(this.value as number)) {\n      switch (this.type.kind) {\n        case 'f32':\n          return `${withPoint(this.value as number)}f`;\n        case 'f16':\n          return `${withPoint(this.value as number)}h`;\n        case 'u32':\n          return `${this.value}u`;\n        case 'i32':\n          return `${this.value}i`;\n        case 'bool':\n          return `${this.value}`;\n      }\n    } else if (this.value === Number.POSITIVE_INFINITY) {\n      switch (this.type.kind) {\n        case 'f32':\n          return `(1.f/0.f)`;\n        case 'f16':\n          return `(1.h/0.h)`;\n      }\n    } else if (this.value === Number.NEGATIVE_INFINITY) {\n      switch (this.type.kind) {\n        case 'f32':\n          return `(-1.f/0.f)`;\n        case 'f16':\n          return `(-1.h/0.h)`;\n      }\n    }\n    throw new Error(\n      `scalar of value ${this.value} and type ${this.type} has no WGSL representation`\n    );\n  }\n\n  public toString(): string {\n    if (this.type.kind === 'bool') {\n      return Colors.bold(this.value.toString());\n    }\n    switch (this.value) {\n      case Infinity:\n      case -Infinity:\n        return Colors.bold(this.value.toString());\n      default: {\n        // Uint8Array.map returns a Uint8Array, so cannot use .map directly\n        const hex = Array.from(this.bits)\n          .reverse()\n          .map(x => x.toString(16).padStart(2, '0'))\n          .join('');\n        const n = this.value as Number;\n        if (n !== null && isFloatValue(this)) {\n          let str = this.value.toString();\n          str = str.indexOf('.') > 0 || str.indexOf('e') > 0 ? str : `${str}.0`;\n          return isSubnormalNumberF32(n.valueOf())\n            ? `${Colors.bold(str)} (0x${hex} subnormal)`\n            : `${Colors.bold(str)} (0x${hex})`;\n        }\n        return `${Colors.bold(this.value.toString())} (0x${hex})`;\n      }\n    }\n  }\n}\n\n/** Create an f64 from a numeric value, a JS `number`. */\nexport function f64(value: number): Scalar {\n  const arr = new Float64Array([value]);\n  return new Scalar(TypeF64, arr[0], arr);\n}\n/** Create an f32 from a numeric value, a JS `number`. */\nexport function f32(value: number): Scalar {\n  const arr = new Float32Array([value]);\n  return new Scalar(TypeF32, arr[0], arr);\n}\n/** Create an f16 from a numeric value, a JS `number`. */\nexport function f16(value: number): Scalar {\n  const arr = new Float16Array([value]);\n  return new Scalar(TypeF16, arr[0], arr);\n}\n/** Create an f32 from a bit representation, a uint32 represented as a JS `number`. */\nexport function f32Bits(bits: number): Scalar {\n  const arr = new Uint32Array([bits]);\n  return new Scalar(TypeF32, new Float32Array(arr.buffer)[0], arr);\n}\n/** Create an f16 from a bit representation, a uint16 represented as a JS `number`. */\nexport function f16Bits(bits: number): Scalar {\n  const arr = new Uint16Array([bits]);\n  return new Scalar(TypeF16, new Float16Array(arr.buffer)[0], arr);\n}\n\n/** Create an i32 from a numeric value, a JS `number`. */\nexport function i32(value: number): Scalar {\n  const arr = new Int32Array([value]);\n  return new Scalar(TypeI32, arr[0], arr);\n}\n/** Create an i16 from a numeric value, a JS `number`. */\nexport function i16(value: number): Scalar {\n  const arr = new Int16Array([value]);\n  return new Scalar(TypeI16, arr[0], arr);\n}\n/** Create an i8 from a numeric value, a JS `number`. */\nexport function i8(value: number): Scalar {\n  const arr = new Int8Array([value]);\n  return new Scalar(TypeI8, arr[0], arr);\n}\n\n/** Create an i32 from a bit representation, a uint32 represented as a JS `number`. */\nexport function i32Bits(bits: number): Scalar {\n  const arr = new Uint32Array([bits]);\n  return new Scalar(TypeI32, new Int32Array(arr.buffer)[0], arr);\n}\n/** Create an i16 from a bit representation, a uint16 represented as a JS `number`. */\nexport function i16Bits(bits: number): Scalar {\n  const arr = new Uint16Array([bits]);\n  return new Scalar(TypeI16, new Int16Array(arr.buffer)[0], arr);\n}\n/** Create an i8 from a bit representation, a uint8 represented as a JS `number`. */\nexport function i8Bits(bits: number): Scalar {\n  const arr = new Uint8Array([bits]);\n  return new Scalar(TypeI8, new Int8Array(arr.buffer)[0], arr);\n}\n\n/** Create a u32 from a numeric value, a JS `number`. */\nexport function u32(value: number): Scalar {\n  const arr = new Uint32Array([value]);\n  return new Scalar(TypeU32, arr[0], arr);\n}\n/** Create a u16 from a numeric value, a JS `number`. */\nexport function u16(value: number): Scalar {\n  const arr = new Uint16Array([value]);\n  return new Scalar(TypeU16, arr[0], arr);\n}\n/** Create a u8 from a numeric value, a JS `number`. */\nexport function u8(value: number): Scalar {\n  const arr = new Uint8Array([value]);\n  return new Scalar(TypeU8, arr[0], arr);\n}\n\n/** Create an u32 from a bit representation, a uint32 represented as a JS `number`. */\nexport function u32Bits(bits: number): Scalar {\n  const arr = new Uint32Array([bits]);\n  return new Scalar(TypeU32, bits, arr);\n}\n/** Create an u16 from a bit representation, a uint16 represented as a JS `number`. */\nexport function u16Bits(bits: number): Scalar {\n  const arr = new Uint16Array([bits]);\n  return new Scalar(TypeU16, bits, arr);\n}\n/** Create an u8 from a bit representation, a uint8 represented as a JS `number`. */\nexport function u8Bits(bits: number): Scalar {\n  const arr = new Uint8Array([bits]);\n  return new Scalar(TypeU8, bits, arr);\n}\n\n/** Create a boolean value. */\nexport function bool(value: boolean): Scalar {\n  // WGSL does not support using 'bool' types directly in storage / uniform\n  // buffers, so instead we pack booleans in a u32, where 'false' is zero and\n  // 'true' is any non-zero value.\n  const arr = new Uint32Array([value ? 1 : 0]);\n  return new Scalar(TypeBool, value, arr);\n}\n\n/** A 'true' literal value */\nexport const True = bool(true);\n\n/** A 'false' literal value */\nexport const False = bool(false);\n\n/**\n * Class that encapsulates a vector value.\n */\nexport class Vector {\n  readonly elements: Array<Scalar>;\n  readonly type: VectorType;\n\n  public constructor(elements: Array<Scalar>) {\n    if (elements.length < 2 || elements.length > 4) {\n      throw new Error(`vector element count must be between 2 and 4, got ${elements.length}`);\n    }\n    for (let i = 1; i < elements.length; i++) {\n      const a = elements[0].type;\n      const b = elements[i].type;\n      if (a !== b) {\n        throw new Error(\n          `cannot mix vector element types. Found elements with types '${a}' and '${b}'`\n        );\n      }\n    }\n    this.elements = elements;\n    this.type = TypeVec(elements.length, elements[0].type);\n  }\n\n  /**\n   * Copies the vector value to the Uint8Array buffer at the provided byte offset.\n   * @param buffer the destination buffer\n   * @param offset the byte offset within buffer\n   */\n  public copyTo(buffer: Uint8Array, offset: number) {\n    for (const element of this.elements) {\n      element.copyTo(buffer, offset);\n      offset += this.type.elementType.size;\n    }\n  }\n\n  /**\n   * @returns the WGSL representation of this vector value\n   */\n  public wgsl(): string {\n    const els = this.elements.map(v => v.wgsl()).join(', ');\n    return `vec${this.type.width}(${els})`;\n  }\n\n  public toString(): string {\n    return `${this.type}(${this.elements.map(e => e.toString()).join(', ')})`;\n  }\n\n  public get x() {\n    assert(0 < this.elements.length);\n    return this.elements[0];\n  }\n\n  public get y() {\n    assert(1 < this.elements.length);\n    return this.elements[1];\n  }\n\n  public get z() {\n    assert(2 < this.elements.length);\n    return this.elements[2];\n  }\n\n  public get w() {\n    assert(3 < this.elements.length);\n    return this.elements[3];\n  }\n}\n\n/** Helper for constructing a new two-element vector with the provided values */\nexport function vec2(x: Scalar, y: Scalar) {\n  return new Vector([x, y]);\n}\n\n/** Helper for constructing a new three-element vector with the provided values */\nexport function vec3(x: Scalar, y: Scalar, z: Scalar) {\n  return new Vector([x, y, z]);\n}\n\n/** Helper for constructing a new four-element vector with the provided values */\nexport function vec4(x: Scalar, y: Scalar, z: Scalar, w: Scalar) {\n  return new Vector([x, y, z, w]);\n}\n\n/** Value is a Scalar or Vector value. */\nexport type Value = Scalar | Vector;\n\n/** @returns if the Value is a float scalar type */\nexport function isFloatValue(v: Value): boolean {\n  if (v instanceof Scalar) {\n    const s = v;\n    return s.type.kind === 'f64' || s.type.kind === 'f32' || s.type.kind === 'f16';\n  }\n  return false;\n}\n"],"file":"conversion.js"}
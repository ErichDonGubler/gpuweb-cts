{"version":3,"file":"math.js","names":["assert","Float16Array","kBit","kValue","f32","floatBitsToNumber","i32","kFloat16Format","kFloat32Format","u32","kMaxSafeMultipleOf8","Number","MAX_SAFE_INTEGER","align","n","alignment","isInteger","Math","ceil","roundDown","floor","clamp","min","max","flushSubnormalNumberF64","val","isSubnormalNumberF64","f64","negative","positive","flushSubnormalNumberF32","isSubnormalNumberF32","isFiniteF32","flushSubnormalNumberF16","isSubnormalNumberF16","f16","isFiniteF16","nextAfterF64Data","ArrayBuffer","nextAfterF64Int","BigUint64Array","nextAfterF64Float","Float64Array","nextAfterF64","dir","mode","isNaN","POSITIVE_INFINITY","infinity","NEGATIVE_INFINITY","subnormal","is_positive","nextAfterF32Data","nextAfterF32Int","Uint32Array","nextAfterF32Float","Float32Array","nextAfterF32","nextAfterF16Data","nextAfterF16Hex","Uint16Array","nextAfterF16Float","nextAfterF16","oneULPF64","target","NaN","nearest_max","nearest_min","before","after","oneULPF32","converted","correctlyRoundedF64","correctlyRoundedF32","n_32","other","correctlyRoundedF16","n_16","frexpData","frexpDataU32","frexpDataF32","frexp","fract","exp","lerp","a","b","t","isFinite","x","linearRange","num_steps","Array","from","keys","map","i","biasedRange","c","pow","fullF32Range","counts","pos_sub","pos_norm","neg_norm","undefined","neg_sub","bit_fields","trunc","hexToF32","sourceFilteredF32Range","source","low","high","filter","fullF16Range","hexToF16","kInterestingI32Values","sparseI32Range","kVectorI32Values","flatMap","f","vectorI32Range","dim","fullI32Range","kInterestingU32Values","sparseU32Range","kVectorU32Values","vectorU32Range","fullU32Range","count","kInterestingF32Values","sparseF32Range","kVectorF32Values","vectorF32Range","kSparseVectorF32Values","idx","sparseVectorF32Range","kSparseMatrixF32Values","sparseMatrixF32Range","r","multiplyMatrices","A","B","length","product","fill","m","p","signExtend","bits","shift","quantizeToF32","num","value","quantizeToI32","quantizeToU32","isPowerOfTwo","gcd","bTemp","lcm","hex","hexToF64","BigInt64Array","buffer","cartesianProductImpl","elements","intermediate","result","forEach","e","push","cartesianProduct","inputs","calculatePermutations","input","head","tail","slice","concat","permutations","flatten2DArray","every","j","unflatten2DArray","_","map2DArray","op"],"sources":["../../../src/webgpu/util/math.ts"],"sourcesContent":["import { assert } from '../../common/util/util.js';\nimport { Float16Array } from '../../external/petamoriken/float16/float16.js';\n\nimport { kBit, kValue } from './constants.js';\nimport { f32, floatBitsToNumber, i32, kFloat16Format, kFloat32Format, u32 } from './conversion.js';\n\n/**\n * A multiple of 8 guaranteed to be way too large to allocate (just under 8 pebibytes).\n * This is a \"safe\" integer (ULP <= 1.0) very close to MAX_SAFE_INTEGER.\n *\n * Note: allocations of this size are likely to exceed limitations other than just the system's\n * physical memory, so test cases are also needed to try to trigger \"true\" OOM.\n */\nexport const kMaxSafeMultipleOf8 = Number.MAX_SAFE_INTEGER - 7;\n\n/** Round `n` up to the next multiple of `alignment` (inclusive). */\n// MAINTENANCE_TODO: Rename to `roundUp`\nexport function align(n: number, alignment: number): number {\n  assert(Number.isInteger(n) && n >= 0, 'n must be a non-negative integer');\n  assert(Number.isInteger(alignment) && alignment > 0, 'alignment must be a positive integer');\n  return Math.ceil(n / alignment) * alignment;\n}\n\n/** Round `n` down to the next multiple of `alignment` (inclusive). */\nexport function roundDown(n: number, alignment: number): number {\n  assert(Number.isInteger(n) && n >= 0, 'n must be a non-negative integer');\n  assert(Number.isInteger(alignment) && alignment > 0, 'alignment must be a positive integer');\n  return Math.floor(n / alignment) * alignment;\n}\n\n/** Clamp a number to the provided range. */\nexport function clamp(n: number, { min, max }: { min: number; max: number }): number {\n  assert(max >= min);\n  return Math.min(Math.max(n, min), max);\n}\n\n/** @returns 0 if |val| is a subnormal f64 number, otherwise returns |val| */\nexport function flushSubnormalNumberF64(val: number): number {\n  return isSubnormalNumberF64(val) ? 0 : val;\n}\n\n/** @returns if number is within subnormal range of f64 */\nexport function isSubnormalNumberF64(n: number): boolean {\n  return n > kValue.f64.negative.max && n < kValue.f64.positive.min;\n}\n\n/** @returns 0 if |val| is a subnormal f32 number, otherwise returns |val| */\nexport function flushSubnormalNumberF32(val: number): number {\n  return isSubnormalNumberF32(val) ? 0 : val;\n}\n\n/** @returns if number is within subnormal range of f32 */\nexport function isSubnormalNumberF32(n: number): boolean {\n  return n > kValue.f32.negative.max && n < kValue.f32.positive.min;\n}\n\n/** @returns if number is in the finite range of f32 */\nexport function isFiniteF32(n: number) {\n  return n >= kValue.f32.negative.min && n <= kValue.f32.positive.max;\n}\n\n/** @returns 0 if |val| is a subnormal f16 number, otherwise returns |val| */\nexport function flushSubnormalNumberF16(val: number): number {\n  return isSubnormalNumberF16(val) ? 0 : val;\n}\n\n/** @returns if number is within subnormal range of f16 */\nexport function isSubnormalNumberF16(n: number): boolean {\n  return n > kValue.f16.negative.max && n < kValue.f16.positive.min;\n}\n\n/** @returns if number is in the finite range of f16 */\nexport function isFiniteF16(n: number) {\n  return n >= kValue.f16.negative.min && n <= kValue.f16.positive.max;\n}\n\n/** Should FTZ occur during calculations or not */\nexport type FlushMode = 'flush' | 'no-flush';\n\n/** Should nextAfter calculate towards positive infinity or negative infinity */\nexport type NextDirection = 'positive' | 'negative';\n\n/**\n * Once-allocated ArrayBuffer/views to avoid overhead of allocation when\n * converting between numeric formats\n *\n * Usage of a once-allocated pattern like this makes nextAfterF64 non-reentrant,\n * so cannot call itself directly or indirectly.\n */\nconst nextAfterF64Data = new ArrayBuffer(8);\nconst nextAfterF64Int = new BigUint64Array(nextAfterF64Data);\nconst nextAfterF64Float = new Float64Array(nextAfterF64Data);\n\n/**\n * @returns the next f64 value after |val|, towards +inf or -inf as specified by |dir|.\n\n * If |mode| is 'flush', all subnormal values will be flushed to 0,\n * before processing and for -/+0 the nextAfterF64 will be the closest normal in\n * the correct direction.\n\n * If |mode| is 'no-flush', the next subnormal will be calculated when appropriate,\n * and for -/+0 the nextAfterF64 will be the closest subnormal in the correct\n * direction.\n *\n * val needs to be in [min f64, max f64]\n */\nexport function nextAfterF64(val: number, dir: NextDirection, mode: FlushMode): number {\n  if (Number.isNaN(val)) {\n    return val;\n  }\n\n  if (val === Number.POSITIVE_INFINITY) {\n    return kValue.f64.infinity.positive;\n  }\n\n  if (val === Number.NEGATIVE_INFINITY) {\n    return kValue.f64.infinity.negative;\n  }\n\n  assert(\n    val <= kValue.f64.positive.max && val >= kValue.f64.negative.min,\n    `${val} is not in the range of f64`\n  );\n\n  val = mode === 'flush' ? flushSubnormalNumberF64(val) : val;\n\n  // -/+0 === 0 returns true\n  if (val === 0) {\n    if (dir === 'positive') {\n      return mode === 'flush' ? kValue.f64.positive.min : kValue.f64.subnormal.positive.min;\n    } else {\n      return mode === 'flush' ? kValue.f64.negative.max : kValue.f64.subnormal.negative.max;\n    }\n  }\n\n  nextAfterF64Float[0] = val;\n  const is_positive = (nextAfterF64Int[0] & 0x8000_0000_0000_0000n) === 0n;\n  if (is_positive === (dir === 'positive')) {\n    nextAfterF64Int[0] += 1n;\n  } else {\n    nextAfterF64Int[0] -= 1n;\n  }\n\n  // Checking for overflow\n  if ((nextAfterF64Int[0] & 0x7ff0_0000_0000_0000n) === 0x7ff0_0000_0000_0000n) {\n    if (dir === 'positive') {\n      return kValue.f64.infinity.positive;\n    } else {\n      return kValue.f64.infinity.negative;\n    }\n  }\n\n  return mode === 'flush' ? flushSubnormalNumberF64(nextAfterF64Float[0]) : nextAfterF64Float[0];\n}\n\n/**\n * Once-allocated ArrayBuffer/views to avoid overhead of allocation when\n * converting between numeric formats\n *\n * Usage of a once-allocated pattern like this makes nextAfterF32 non-reentrant,\n * so cannot call itself directly or indirectly.\n */\nconst nextAfterF32Data = new ArrayBuffer(4);\nconst nextAfterF32Int = new Uint32Array(nextAfterF32Data);\nconst nextAfterF32Float = new Float32Array(nextAfterF32Data);\n\n/**\n * @returns the next f32 value after |val|, towards +inf or -inf as specified by |dir|.\n\n * If |mode| is 'flush', all subnormal values will be flushed to 0,\n * before processing and for -/+0 the nextAfterF32 will be the closest normal in\n * the correct direction.\n\n * If |mode| is 'no-flush', the next subnormal will be calculated when appropriate,\n * and for -/+0 the nextAfterF32 will be the closest subnormal in the correct\n * direction.\n *\n * val needs to be in [min f32, max f32]\n */\nexport function nextAfterF32(val: number, dir: NextDirection, mode: FlushMode): number {\n  if (Number.isNaN(val)) {\n    return val;\n  }\n\n  if (val === Number.POSITIVE_INFINITY) {\n    return kValue.f32.infinity.positive;\n  }\n\n  if (val === Number.NEGATIVE_INFINITY) {\n    return kValue.f32.infinity.negative;\n  }\n\n  assert(\n    val <= kValue.f32.positive.max && val >= kValue.f32.negative.min,\n    `${val} is not in the range of f32`\n  );\n\n  val = mode === 'flush' ? flushSubnormalNumberF32(val) : val;\n\n  // -/+0 === 0 returns true\n  if (val === 0) {\n    if (dir === 'positive') {\n      return mode === 'flush' ? kValue.f32.positive.min : kValue.f32.subnormal.positive.min;\n    } else {\n      return mode === 'flush' ? kValue.f32.negative.max : kValue.f32.subnormal.negative.max;\n    }\n  }\n\n  nextAfterF32Float[0] = val; // This quantizes from number (f64) to f32\n  if (\n    (dir === 'positive' && nextAfterF32Float[0] <= val) ||\n    (dir === 'negative' && nextAfterF32Float[0] >= val)\n  ) {\n    // val is either f32 precise or quantizing rounded in the opposite direction\n    // from what is needed, so need to calculate the value in the correct\n    // direction.\n    const is_positive = (nextAfterF32Int[0] & 0x80000000) === 0;\n    if (is_positive === (dir === 'positive')) {\n      nextAfterF32Int[0] += 1;\n    } else {\n      nextAfterF32Int[0] -= 1;\n    }\n  }\n\n  // Checking for overflow\n  if ((nextAfterF32Int[0] & 0x7f800000) === 0x7f800000) {\n    if (dir === 'positive') {\n      return kValue.f32.infinity.positive;\n    } else {\n      return kValue.f32.infinity.negative;\n    }\n  }\n\n  return mode === 'flush' ? flushSubnormalNumberF32(nextAfterF32Float[0]) : nextAfterF32Float[0];\n}\n\n/**\n * Once-allocated ArrayBuffer/views to avoid overhead of allocation when\n * converting between numeric formats\n *\n * Usage of a once-allocated pattern like this makes nextAfterF16 non-reentrant,\n * so cannot call itself directly or indirectly.\n */\nconst nextAfterF16Data = new ArrayBuffer(2);\nconst nextAfterF16Hex = new Uint16Array(nextAfterF16Data);\nconst nextAfterF16Float = new Float16Array(nextAfterF16Data);\n\n/**\n * @returns the next f16 value after |val|, towards +inf or -inf as specified by |dir|.\n\n * If |mode| is 'flush', all subnormal values will be flushed to 0,\n * before processing and for -/+0 the nextAfterF16 will be the closest normal in\n * the correct direction.\n\n * If |mode| is 'no-flush', the next subnormal will be calculated when appropriate,\n * and for -/+0 the nextAfterF16 will be the closest subnormal in the correct\n * direction.\n *\n * val needs to be in [min f16, max f16]\n */\nexport function nextAfterF16(val: number, dir: NextDirection, mode: FlushMode): number {\n  if (Number.isNaN(val)) {\n    return val;\n  }\n\n  if (val === Number.POSITIVE_INFINITY) {\n    return kValue.f16.infinity.positive;\n  }\n\n  if (val === Number.NEGATIVE_INFINITY) {\n    return kValue.f16.infinity.negative;\n  }\n\n  assert(\n    val <= kValue.f16.positive.max && val >= kValue.f16.negative.min,\n    `${val} is not in the range of f16`\n  );\n\n  val = mode === 'flush' ? flushSubnormalNumberF16(val) : val;\n\n  // -/+0 === 0 returns true\n  if (val === 0) {\n    if (dir === 'positive') {\n      return mode === 'flush' ? kValue.f16.positive.min : kValue.f16.subnormal.positive.min;\n    } else {\n      return mode === 'flush' ? kValue.f16.negative.max : kValue.f16.subnormal.negative.max;\n    }\n  }\n\n  nextAfterF16Float[0] = val; // This quantizes from number (f64) to f16\n  if (\n    (dir === 'positive' && nextAfterF16Float[0] <= val) ||\n    (dir === 'negative' && nextAfterF16Float[0] >= val)\n  ) {\n    // val is either f16 precise or quantizing rounded in the opposite direction\n    // from what is needed, so need to calculate the value in the correct\n    // direction.\n    const is_positive = (nextAfterF16Hex[0] & 0x8000) === 0;\n    if (is_positive === (dir === 'positive')) {\n      nextAfterF16Hex[0] += 1;\n    } else {\n      nextAfterF16Hex[0] -= 1;\n    }\n  }\n\n  // Checking for overflow\n  if ((nextAfterF16Hex[0] & 0x7c00) === 0x7c00) {\n    if (dir === 'positive') {\n      return kValue.f16.infinity.positive;\n    } else {\n      return kValue.f16.infinity.negative;\n    }\n  }\n\n  return mode === 'flush' ? flushSubnormalNumberF16(nextAfterF16Float[0]) : nextAfterF16Float[0];\n}\n\n/**\n * @returns ulp(x), the unit of least precision for a specific number as a 64-bit float\n *\n * ulp(x) is the distance between the two floating point numbers nearest x.\n * This value is also called unit of last place, ULP, and 1 ULP.\n * See the WGSL spec and http://www.ens-lyon.fr/LIP/Pub/Rapports/RR/RR2005/RR2005-09.pdf\n * for a more detailed/nuanced discussion of the definition of ulp(x).\n *\n * @param target number to calculate ULP for\n * @param mode should FTZ occurring during calculation or not\n */\nexport function oneULPF64(target: number, mode: FlushMode = 'flush'): number {\n  if (Number.isNaN(target)) {\n    return Number.NaN;\n  }\n\n  target = mode === 'flush' ? flushSubnormalNumberF64(target) : target;\n\n  // For values at the edge of the range or beyond ulp(x) is defined as the\n  // distance between the two nearest f64 representable numbers to the\n  // appropriate edge.\n  if (target === Number.POSITIVE_INFINITY || target >= kValue.f64.positive.max) {\n    return kValue.f64.positive.max - kValue.f64.positive.nearest_max;\n  } else if (target === Number.NEGATIVE_INFINITY || target <= kValue.f64.negative.min) {\n    return kValue.f64.negative.nearest_min - kValue.f64.negative.min;\n  }\n\n  // ulp(x) is min(after - before), where\n  //     before <= x <= after\n  //     before =/= after\n  //     before and after are f64 representable\n  const before = nextAfterF64(target, 'negative', mode);\n  const after = nextAfterF64(target, 'positive', mode);\n  // Since number is internally a f64, |target| is always f64 representable, so\n  // either before or after will be x\n  return Math.min(target - before, after - target);\n}\n\n/**\n * @returns ulp(x), the unit of least precision for a specific number as a 32-bit float\n *\n * ulp(x) is the distance between the two floating point numbers nearest x.\n * This value is also called unit of last place, ULP, and 1 ULP.\n * See the WGSL spec and http://www.ens-lyon.fr/LIP/Pub/Rapports/RR/RR2005/RR2005-09.pdf\n * for a more detailed/nuanced discussion of the definition of ulp(x).\n *\n * @param target number to calculate ULP for\n * @param mode should FTZ occurring during calculation or not\n */\nexport function oneULPF32(target: number, mode: FlushMode = 'flush'): number {\n  if (Number.isNaN(target)) {\n    return Number.NaN;\n  }\n\n  target = mode === 'flush' ? flushSubnormalNumberF32(target) : target;\n\n  // For values at the edge of the range or beyond ulp(x) is defined as the\n  // distance between the two nearest f32 representable numbers to the\n  // appropriate edge.\n  if (target === Number.POSITIVE_INFINITY || target >= kValue.f32.positive.max) {\n    return kValue.f32.positive.max - kValue.f32.positive.nearest_max;\n  } else if (target === Number.NEGATIVE_INFINITY || target <= kValue.f32.negative.min) {\n    return kValue.f32.negative.nearest_min - kValue.f32.negative.min;\n  }\n\n  // ulp(x) is min(after - before), where\n  //     before <= x <= after\n  //     before =/= after\n  //     before and after are f32 representable\n  const before = nextAfterF32(target, 'negative', mode);\n  const after = nextAfterF32(target, 'positive', mode);\n  const converted: number = new Float32Array([target])[0];\n  if (converted === target) {\n    // |target| is f32 representable, so either before or after will be x\n    return Math.min(target - before, after - target);\n  } else {\n    // |target| is not f32 representable so taking distance of neighbouring f32s.\n    return after - before;\n  }\n}\n\n/**\n * Calculate the valid roundings when quantizing to 64-bit floats\n *\n * TS/JS's number type is internally a f64, so the supplied value will be\n * quanitized by definition. The only corner cases occur if a non-finite value\n * is provided, since the valid roundings include the appropriate min or max\n * value.\n *\n * @param n number to be quantized\n * @returns all of the acceptable roundings for quantizing to 64-bits in\n *          ascending order.\n */\nexport function correctlyRoundedF64(n: number): number[] {\n  assert(!Number.isNaN(n), `correctlyRoundedF32 not defined for NaN`);\n  // Above f64 range\n  if (n === Number.POSITIVE_INFINITY) {\n    return [kValue.f64.positive.max, Number.POSITIVE_INFINITY];\n  }\n\n  // Below f64 range\n  if (n === Number.NEGATIVE_INFINITY) {\n    return [Number.NEGATIVE_INFINITY, kValue.f64.negative.min];\n  }\n\n  return [n];\n}\n\n/**\n * Calculate the valid roundings when quantizing to 32-bit floats\n *\n * TS/JS's number type is internally a f64, so quantization needs to occur when\n * converting to f32 for WGSL. WGSL does not specify a specific rounding mode,\n * so if a number is not precisely representable in 32-bits, but in the\n * range, there are two possible valid quantizations. If it is precisely\n * representable, there is only one valid quantization. This function calculates\n * the valid roundings and returns them in an array.\n *\n * This function does not consider flushing mode, so subnormals are maintained.\n * The caller is responsible to flushing before and after as appropriate.\n *\n * Out of range values return the appropriate infinity and edge value.\n *\n * @param n number to be quantized\n * @returns all of the acceptable roundings for quantizing to 32-bits in\n *          ascending order.\n */\nexport function correctlyRoundedF32(n: number): number[] {\n  assert(!Number.isNaN(n), `correctlyRoundedF32 not defined for NaN`);\n  // Above f32 range\n  if (n === Number.POSITIVE_INFINITY || n > kValue.f32.positive.max) {\n    return [kValue.f32.positive.max, Number.POSITIVE_INFINITY];\n  }\n\n  // Below f32 range\n  if (n === Number.NEGATIVE_INFINITY || n < kValue.f32.negative.min) {\n    return [Number.NEGATIVE_INFINITY, kValue.f32.negative.min];\n  }\n\n  const n_32 = new Float32Array([n])[0];\n  const converted: number = n_32;\n  if (n === converted) {\n    // n is precisely expressible as a f32, so should not be rounded\n    return [n];\n  }\n\n  if (converted > n) {\n    // n_32 rounded towards +inf, so is after n\n    const other = nextAfterF32(n_32, 'negative', 'no-flush');\n    return [other, converted];\n  } else {\n    // n_32 rounded towards -inf, so is before n\n    const other = nextAfterF32(n_32, 'positive', 'no-flush');\n    return [converted, other];\n  }\n}\n\n/**\n * Calculate the valid roundings when quantizing to 16-bit floats\n *\n * TS/JS's number type is internally a f64, so quantization needs to occur when\n * converting to f16 for WGSL. WGSL does not specify a specific rounding mode,\n * so if a number is not precisely representable in 16-bits, but in the\n * range, there are two possible valid quantizations. If it is precisely\n * representable, there is only one valid quantization. This function calculates\n * the valid roundings and returns them in an array.\n *\n * This function does not consider flushing mode, so subnormals are maintained.\n * The caller is responsible to flushing before and after as appropriate.\n *\n * Out of range values return the appropriate infinity and edge value.\n *\n * @param n number to be quantized\n * @returns all of the acceptable roundings for quantizing to 16-bits in\n *          ascending order.\n */\nexport function correctlyRoundedF16(n: number): number[] {\n  assert(!Number.isNaN(n), `correctlyRoundedF16 not defined for NaN`);\n  // Above f16 range\n  if (n === Number.POSITIVE_INFINITY || n > kValue.f16.positive.max) {\n    return [kValue.f16.positive.max, Number.POSITIVE_INFINITY];\n  }\n\n  // Below f16 range\n  if (n === Number.NEGATIVE_INFINITY || n < kValue.f16.negative.min) {\n    return [Number.NEGATIVE_INFINITY, kValue.f16.negative.min];\n  }\n\n  const n_16 = new Float16Array([n])[0];\n  const converted: number = n_16;\n  if (n === converted) {\n    // n is precisely expressible as a f16, so should not be rounded\n    return [n];\n  }\n\n  if (converted > n) {\n    // n_16 rounded towards +inf, so is after n\n    const other = nextAfterF16(n_16, 'negative', 'no-flush');\n    return [other, converted];\n  } else {\n    // n_16 rounded towards -inf, so is before n\n    const other = nextAfterF16(n_16, 'positive', 'no-flush');\n    return [converted, other];\n  }\n}\n\n/**\n * Once-allocated ArrayBuffer/views to avoid overhead of allocation in frexp\n *\n * This makes frexp non-reentrant due to shared state between calls.\n */\nconst frexpData = new ArrayBuffer(4);\nconst frexpDataU32 = new Uint32Array(frexpData);\nconst frexpDataF32 = new Float32Array(frexpData);\n\n/**\n * Calculates WGSL frexp\n *\n * Splits val into a fraction and an exponent so that\n * val = fraction * 2 ^ exponent.\n * The fraction is 0.0 or its magnitude is in the range [0.5, 1.0).\n *\n * Inspired by golang's implementation of frexp.\n *\n * This code is non-reentrant due to the use of a non-local data buffer and\n * views.\n *\n * @param val the f32 to split\n * @returns the results of splitting val\n */\nexport function frexp(val: number): { fract: number; exp: number } {\n  frexpDataF32[0] = val;\n  // Do not directly use val after this point, so that changes are reflected in\n  // both the f32 and u32 views.\n\n  // Handles 0 and -0\n  if (frexpDataF32[0] === 0) {\n    return { fract: frexpDataF32[0], exp: 0 };\n  }\n\n  // Covers NaNs, OOB and Infinities\n  if (!isFiniteF32(frexpDataF32[0])) {\n    return { fract: frexpDataF32[0], exp: 0 };\n  }\n\n  // Normalize if subnormal\n  let exp = 0;\n  if (isSubnormalNumberF32(frexpDataF32[0])) {\n    frexpDataF32[0] = frexpDataF32[0] * (1 << 23);\n    exp = -23;\n  }\n  exp += ((frexpDataU32[0] >> 23) & 0xff) - 126; // shift & mask, minus the bias + 1\n\n  frexpDataU32[0] &= 0x807fffff; // mask the exponent bits\n  frexpDataU32[0] |= 0x3f000000; // extract the mantissa bits\n  const fract = frexpDataF32[0]; // Convert from bits to number\n  return { fract, exp };\n}\n\n/**\n * Calculates the linear interpolation between two values of a given fractional.\n *\n * If |t| is 0, |a| is returned, if |t| is 1, |b| is returned, otherwise\n * interpolation/extrapolation equivalent to a + t(b - a) is performed.\n *\n * Numerical stable version is adapted from http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0811r2.html\n */\nexport function lerp(a: number, b: number, t: number): number {\n  if (!Number.isFinite(a) || !Number.isFinite(b)) {\n    return Number.NaN;\n  }\n\n  if ((a <= 0.0 && b >= 0.0) || (a >= 0.0 && b <= 0.0)) {\n    return t * b + (1 - t) * a;\n  }\n\n  if (t === 1.0) {\n    return b;\n  }\n\n  const x = a + t * (b - a);\n  return t > 1.0 === b > a ? Math.max(b, x) : Math.min(b, x);\n}\n\n/** @returns a linear increasing range of numbers. */\nexport function linearRange(a: number, b: number, num_steps: number): Array<number> {\n  if (num_steps <= 0) {\n    return Array<number>();\n  }\n\n  // Avoid division by 0\n  if (num_steps === 1) {\n    return [a];\n  }\n\n  return Array.from(Array(num_steps).keys()).map(i => lerp(a, b, i / (num_steps - 1)));\n}\n\n/**\n * @returns a non-linear increasing range of numbers, with a bias towards the beginning.\n *\n * Generates a linear range on [0,1] with |num_steps|, then squares all the values to make the curve be quadratic,\n * thus biasing towards 0, but remaining on the [0, 1] range.\n * This biased range is then scaled to the desired range using lerp.\n * Different curves could be generated by changing c, where greater values of c will bias more towards 0.\n */\nexport function biasedRange(a: number, b: number, num_steps: number): Array<number> {\n  const c = 2;\n  if (num_steps <= 0) {\n    return Array<number>();\n  }\n\n  // Avoid division by 0\n  if (num_steps === 1) {\n    return [a];\n  }\n\n  return Array.from(Array(num_steps).keys()).map(i => lerp(a, b, Math.pow(i / (num_steps - 1), c)));\n}\n\n/**\n * @returns an ascending sorted array of numbers spread over the entire range of 32-bit floats\n *\n * Numbers are divided into 4 regions: negative normals, negative subnormals, positive subnormals & positive normals.\n * Zero is included.\n *\n * Numbers are generated via taking a linear spread of the bit field representations of the values in each region. This\n * means that number of precise f32 values between each returned value in a region should be about the same. This allows\n * for a wide range of magnitudes to be generated, instead of being extremely biased towards the edges of the f32 range.\n *\n * This function is intended to provide dense coverage of the f32 range, for a minimal list of values to use to cover\n * f32 behaviour, use sparseF32Range instead.\n *\n * @param counts structure param with 4 entries indicating the number of entries to be generated each region, entries\n *               must be 0 or greater.\n */\nexport function fullF32Range(\n  counts: {\n    neg_norm?: number;\n    neg_sub?: number;\n    pos_sub: number;\n    pos_norm: number;\n  } = { pos_sub: 10, pos_norm: 50 }\n): Array<number> {\n  counts.neg_norm = counts.neg_norm === undefined ? counts.pos_norm : counts.neg_norm;\n  counts.neg_sub = counts.neg_sub === undefined ? counts.pos_sub : counts.neg_sub;\n\n  // Generating bit fields first and then converting to f32, so that the spread across the possible f32 values is more\n  // even. Generating against the bounds of f32 values directly results in the values being extremely biased towards the\n  // extremes, since they are so much larger.\n  const bit_fields = [\n    ...linearRange(kBit.f32.negative.min, kBit.f32.negative.max, counts.neg_norm),\n    ...linearRange(\n      kBit.f32.subnormal.negative.min,\n      kBit.f32.subnormal.negative.max,\n      counts.neg_sub\n    ),\n    0,\n    ...linearRange(\n      kBit.f32.subnormal.positive.min,\n      kBit.f32.subnormal.positive.max,\n      counts.pos_sub\n    ),\n    ...linearRange(kBit.f32.positive.min, kBit.f32.positive.max, counts.pos_norm),\n  ].map(Math.trunc);\n  return bit_fields.map(hexToF32);\n}\n\n/**\n * @returns an ascending sorted array of numbers.\n *\n * The numbers returned are based on the `full32Range` as described above. The difference comes depending\n * on the `source` parameter. If the `source` is `const` then the numbers will be restricted to be\n * in the range `[low, high]`. This allows filtering out a set of `f32` values which are invalid for\n * const-evaluation but are needed to test the non-const implementation.\n *\n * @param source the input source for the test. If the `source` is `const` then the return will be filtered\n * @param low the lowest f32 value to permit when filtered\n * @param high the highest f32 value to permit when filtered\n */\nexport function sourceFilteredF32Range(source: String, low: number, high: number): Array<number> {\n  return fullF32Range().filter(x => source !== 'const' || (x >= low && x <= high));\n}\n\n/**\n * @returns an ascending sorted array of numbers spread over the entire range of 16-bit floats\n *\n * Numbers are divided into 4 regions: negative normals, negative subnormals, positive subnormals & positive normals.\n * Zero is included.\n *\n * Numbers are generated via taking a linear spread of the bit field representations of the values in each region. This\n * means that number of precise f16 values between each returned value in a region should be about the same. This allows\n * for a wide range of magnitudes to be generated, instead of being extremely biased towards the edges of the f16 range.\n *\n * This function is intended to provide dense coverage of the f16 range, for a minimal list of values to use to cover\n * f16 behaviour, use sparseF16Range instead.\n *\n * @param counts structure param with 4 entries indicating the number of entries to be generated each region, entries\n *               must be 0 or greater.\n */\nexport function fullF16Range(\n  counts: {\n    neg_norm?: number;\n    neg_sub?: number;\n    pos_sub: number;\n    pos_norm: number;\n  } = { pos_sub: 10, pos_norm: 50 }\n): Array<number> {\n  counts.neg_norm = counts.neg_norm === undefined ? counts.pos_norm : counts.neg_norm;\n  counts.neg_sub = counts.neg_sub === undefined ? counts.pos_sub : counts.neg_sub;\n\n  // Generating bit fields first and then converting to f16, so that the spread across the possible f16 values is more\n  // even. Generating against the bounds of f16 values directly results in the values being extremely biased towards the\n  // extremes, since they are so much larger.\n  const bit_fields = [\n    ...linearRange(kBit.f16.negative.min, kBit.f16.negative.max, counts.neg_norm),\n    ...linearRange(\n      kBit.f16.subnormal.negative.min,\n      kBit.f16.subnormal.negative.max,\n      counts.neg_sub\n    ),\n    0,\n    ...linearRange(\n      kBit.f16.subnormal.positive.min,\n      kBit.f16.subnormal.positive.max,\n      counts.pos_sub\n    ),\n    ...linearRange(kBit.f16.positive.min, kBit.f16.positive.max, counts.pos_norm),\n  ].map(Math.trunc);\n  return bit_fields.map(hexToF16);\n}\n\n/** Short list of i32 values of interest to test against */\nconst kInterestingI32Values: number[] = [\n  kValue.i32.negative.max,\n  kValue.i32.negative.max / 2,\n  -1,\n  0,\n  1,\n  kValue.i32.positive.max / 2,\n  kValue.i32.positive.max,\n];\n\n/** @returns minimal i32 values that cover the entire range of i32 behaviours\n *\n * This is used instead of fullI32Range when the number of test cases being\n * generated is a super linear function of the length of i32 values which is\n * leading to time outs.\n */\nexport function sparseI32Range(): number[] {\n  return kInterestingI32Values;\n}\n\nconst kVectorI32Values = {\n  2: kInterestingI32Values.flatMap(f => [\n    [f, 1],\n    [1, f],\n    [f, -1],\n    [-1, f],\n  ]),\n  3: kInterestingI32Values.flatMap(f => [\n    [f, 1, 2],\n    [1, f, 2],\n    [1, 2, f],\n    [f, -1, -2],\n    [-1, f, -2],\n    [-1, -2, f],\n  ]),\n  4: kInterestingI32Values.flatMap(f => [\n    [f, 1, 2, 3],\n    [1, f, 2, 3],\n    [1, 2, f, 3],\n    [1, 2, 3, f],\n    [f, -1, -2, -3],\n    [-1, f, -2, -3],\n    [-1, -2, f, -3],\n    [-1, -2, -3, f],\n  ]),\n};\n\n/**\n * Returns set of vectors, indexed by dimension containing interesting i32\n * values.\n *\n * The tests do not do the simple option for coverage of computing the cartesian\n * product of all of the interesting i32 values N times for vecN tests,\n * because that creates a huge number of tests for vec3 and vec4, leading to\n * time outs.\n *\n * Instead they insert the interesting i32 values into each location of the\n * vector to get a spread of testing over the entire range. This reduces the\n * number of cases being run substantially, but maintains coverage.\n */\nexport function vectorI32Range(dim: number): number[][] {\n  assert(dim === 2 || dim === 3 || dim === 4, 'vectorI32Range only accepts dimensions 2, 3, and 4');\n  return kVectorI32Values[dim];\n}\n\n/**\n * @returns an ascending sorted array of numbers spread over the entire range of 32-bit signed ints\n *\n * Numbers are divided into 2 regions: negatives, and positives, with their spreads biased towards 0\n * Zero is included in range.\n *\n * @param counts structure param with 2 entries indicating the number of entries to be generated each region, values must be 0 or greater.\n */\nexport function fullI32Range(\n  counts: {\n    negative?: number;\n    positive: number;\n  } = { positive: 50 }\n): Array<number> {\n  counts.negative = counts.negative === undefined ? counts.positive : counts.negative;\n  return [\n    ...biasedRange(kValue.i32.negative.min, -1, counts.negative),\n    0,\n    ...biasedRange(1, kValue.i32.positive.max, counts.positive),\n  ].map(Math.trunc);\n}\n\n/** Short list of u32 values of interest to test against */\nconst kInterestingU32Values: number[] = [0, 1, kValue.u32.max / 2, kValue.u32.max];\n\n/** @returns minimal u32 values that cover the entire range of u32 behaviours\n *\n * This is used instead of fullU32Range when the number of test cases being\n * generated is a super linear function of the length of u32 values which is\n * leading to time outs.\n */\nexport function sparseU32Range(): number[] {\n  return kInterestingU32Values;\n}\n\nconst kVectorU32Values = {\n  2: kInterestingU32Values.flatMap(f => [\n    [f, 1],\n    [1, f],\n  ]),\n  3: kInterestingU32Values.flatMap(f => [\n    [f, 1, 2],\n    [1, f, 2],\n    [1, 2, f],\n  ]),\n  4: kInterestingU32Values.flatMap(f => [\n    [f, 1, 2, 3],\n    [1, f, 2, 3],\n    [1, 2, f, 3],\n    [1, 2, 3, f],\n  ]),\n};\n\n/**\n * Returns set of vectors, indexed by dimension containing interesting u32\n * values.\n *\n * The tests do not do the simple option for coverage of computing the cartesian\n * product of all of the interesting u32 values N times for vecN tests,\n * because that creates a huge number of tests for vec3 and vec4, leading to\n * time outs.\n *\n * Instead they insert the interesting u32 values into each location of the\n * vector to get a spread of testing over the entire range. This reduces the\n * number of cases being run substantially, but maintains coverage.\n */\nexport function vectorU32Range(dim: number): number[][] {\n  assert(dim === 2 || dim === 3 || dim === 4, 'vectorU32Range only accepts dimensions 2, 3, and 4');\n  return kVectorU32Values[dim];\n}\n\n/**\n * @returns an ascending sorted array of numbers spread over the entire range of 32-bit unsigned ints\n *\n * Numbers are biased towards 0, and 0 is included in the range.\n *\n * @param count number of entries to include in the range, in addition to 0, must be greater than 0, defaults to 50\n */\nexport function fullU32Range(count: number = 50): Array<number> {\n  return [0, ...biasedRange(1, kValue.u32.max, count)].map(Math.trunc);\n}\n\n/** Short list of f32 values of interest to test against */\nconst kInterestingF32Values: number[] = [\n  kValue.f32.negative.min,\n  -10.0,\n  -1.0,\n  kValue.f32.negative.max,\n  kValue.f32.subnormal.negative.min,\n  kValue.f32.subnormal.negative.max,\n  0.0,\n  kValue.f32.subnormal.positive.min,\n  kValue.f32.subnormal.positive.max,\n  kValue.f32.positive.min,\n  1.0,\n  10.0,\n  kValue.f32.positive.max,\n];\n\n/** @returns minimal f32 values that cover the entire range of f32 behaviours\n *\n * Has specially selected values that cover edge cases, normals, and subnormals.\n * This is used instead of fullF32Range when the number of test cases being\n * generated is a super linear function of the length of f32 values which is\n * leading to time outs.\n *\n * These values have been chosen to attempt to test the widest range of f32\n * behaviours in the lowest number of entries, so may potentially miss function\n * specific values of interest. If there are known values of interest they\n * should be appended to this list in the test generation code.\n */\nexport function sparseF32Range(): number[] {\n  return kInterestingF32Values;\n}\n\nconst kVectorF32Values = {\n  2: sparseF32Range().flatMap(f => [\n    [f, 1.0],\n    [1.0, f],\n    [f, -1.0],\n    [-1.0, f],\n  ]),\n  3: sparseF32Range().flatMap(f => [\n    [f, 1.0, 2.0],\n    [1.0, f, 2.0],\n    [1.0, 2.0, f],\n    [f, -1.0, -2.0],\n    [-1.0, f, -2.0],\n    [-1.0, -2.0, f],\n  ]),\n  4: sparseF32Range().flatMap(f => [\n    [f, 1.0, 2.0, 3.0],\n    [1.0, f, 2.0, 3.0],\n    [1.0, 2.0, f, 3.0],\n    [1.0, 2.0, 3.0, f],\n    [f, -1.0, -2.0, -3.0],\n    [-1.0, f, -2.0, -3.0],\n    [-1.0, -2.0, f, -3.0],\n    [-1.0, -2.0, -3.0, f],\n  ]),\n};\n\n/**\n * Returns set of vectors, indexed by dimension containing interesting float\n * values.\n *\n * The tests do not do the simple option for coverage of computing the cartesian\n * product of all of the interesting float values N times for vecN tests,\n * because that creates a huge number of tests for vec3 and vec4, leading to\n * time outs.\n *\n * Instead they insert the interesting f32 values into each location of the\n * vector to get a spread of testing over the entire range. This reduces the\n * number of cases being run substantially, but maintains coverage.\n */\nexport function vectorF32Range(dim: number): number[][] {\n  assert(dim === 2 || dim === 3 || dim === 4, 'vectorF32Range only accepts dimensions 2, 3, and 4');\n  return kVectorF32Values[dim];\n}\n\nconst kSparseVectorF32Values = {\n  2: sparseF32Range().map((f, idx) => [idx % 2 === 0 ? f : idx, idx % 2 === 1 ? f : -idx]),\n  3: sparseF32Range().map((f, idx) => [\n    idx % 3 === 0 ? f : idx,\n    idx % 3 === 1 ? f : -idx,\n    idx % 3 === 2 ? f : idx,\n  ]),\n  4: sparseF32Range().map((f, idx) => [\n    idx % 4 === 0 ? f : idx,\n    idx % 4 === 1 ? f : -idx,\n    idx % 4 === 2 ? f : idx,\n    idx % 4 === 3 ? f : -idx,\n  ]),\n};\n\n/**\n * Minimal set of vectors, indexed by dimension, that contain interesting float\n * values.\n *\n * This is an even more stripped down version of `vectorF32Range` for when\n * pairs of vectors are being tested.\n * All of the interesting floats from sparseF32 are guaranteed to be tested, but\n * not in every position.\n */\nexport function sparseVectorF32Range(dim: number): number[][] {\n  assert(\n    dim === 2 || dim === 3 || dim === 4,\n    'sparseVectorF32Range only accepts dimensions 2, 3, and 4'\n  );\n  return kSparseVectorF32Values[dim];\n}\n\nconst kSparseMatrixF32Values = {\n  2: {\n    2: kInterestingF32Values.map((f, idx) => [\n      [idx % 4 === 0 ? f : idx, idx % 4 === 1 ? f : -idx],\n      [idx % 4 === 2 ? f : -idx, idx % 4 === 3 ? f : idx],\n    ]),\n    3: kInterestingF32Values.map((f, idx) => [\n      [idx % 6 === 0 ? f : idx, idx % 6 === 1 ? f : -idx, idx % 6 === 2 ? f : idx],\n      [idx % 6 === 3 ? f : -idx, idx % 6 === 4 ? f : idx, idx % 6 === 5 ? f : -idx],\n    ]),\n    4: kInterestingF32Values.map((f, idx) => [\n      [\n        idx % 8 === 0 ? f : idx,\n        idx % 8 === 1 ? f : -idx,\n        idx % 8 === 2 ? f : idx,\n        idx % 8 === 3 ? f : -idx,\n      ],\n      [\n        idx % 8 === 4 ? f : -idx,\n        idx % 8 === 5 ? f : idx,\n        idx % 8 === 6 ? f : -idx,\n        idx % 8 === 7 ? f : idx,\n      ],\n    ]),\n  },\n  3: {\n    2: kInterestingF32Values.map((f, idx) => [\n      [idx % 6 === 0 ? f : idx, idx % 6 === 1 ? f : -idx],\n      [idx % 6 === 2 ? f : -idx, idx % 6 === 3 ? f : idx],\n      [idx % 6 === 4 ? f : idx, idx % 6 === 5 ? f : -idx],\n    ]),\n    3: kInterestingF32Values.map((f, idx) => [\n      [idx % 9 === 0 ? f : idx, idx % 9 === 1 ? f : -idx, idx % 9 === 2 ? f : idx],\n      [idx % 9 === 3 ? f : -idx, idx % 9 === 4 ? f : idx, idx % 9 === 5 ? f : -idx],\n      [idx % 9 === 6 ? f : idx, idx % 9 === 7 ? f : -idx, idx % 9 === 8 ? f : idx],\n    ]),\n    4: kInterestingF32Values.map((f, idx) => [\n      [\n        idx % 12 === 0 ? f : idx,\n        idx % 12 === 1 ? f : -idx,\n        idx % 12 === 2 ? f : idx,\n        idx % 12 === 3 ? f : -idx,\n      ],\n      [\n        idx % 12 === 4 ? f : -idx,\n        idx % 12 === 5 ? f : idx,\n        idx % 12 === 6 ? f : -idx,\n        idx % 12 === 7 ? f : idx,\n      ],\n      [\n        idx % 12 === 8 ? f : idx,\n        idx % 12 === 9 ? f : -idx,\n        idx % 12 === 10 ? f : idx,\n        idx % 12 === 11 ? f : -idx,\n      ],\n    ]),\n  },\n  4: {\n    2: kInterestingF32Values.map((f, idx) => [\n      [idx % 8 === 0 ? f : idx, idx % 8 === 1 ? f : -idx],\n      [idx % 8 === 2 ? f : -idx, idx % 8 === 3 ? f : idx],\n      [idx % 8 === 4 ? f : idx, idx % 8 === 5 ? f : -idx],\n      [idx % 8 === 6 ? f : -idx, idx % 8 === 7 ? f : idx],\n    ]),\n    3: kInterestingF32Values.map((f, idx) => [\n      [idx % 12 === 0 ? f : idx, idx % 12 === 1 ? f : -idx, idx % 12 === 2 ? f : idx],\n      [idx % 12 === 3 ? f : -idx, idx % 12 === 4 ? f : idx, idx % 12 === 5 ? f : -idx],\n      [idx % 12 === 6 ? f : idx, idx % 12 === 7 ? f : -idx, idx % 12 === 8 ? f : idx],\n      [idx % 12 === 9 ? f : -idx, idx % 12 === 10 ? f : idx, idx % 12 === 11 ? f : -idx],\n    ]),\n    4: kInterestingF32Values.map((f, idx) => [\n      [\n        idx % 16 === 0 ? f : idx,\n        idx % 16 === 1 ? f : -idx,\n        idx % 16 === 2 ? f : idx,\n        idx % 16 === 3 ? f : -idx,\n      ],\n      [\n        idx % 16 === 4 ? f : -idx,\n        idx % 16 === 5 ? f : idx,\n        idx % 16 === 6 ? f : -idx,\n        idx % 16 === 7 ? f : idx,\n      ],\n      [\n        idx % 16 === 8 ? f : idx,\n        idx % 16 === 9 ? f : -idx,\n        idx % 16 === 10 ? f : idx,\n        idx % 16 === 11 ? f : -idx,\n      ],\n      [\n        idx % 16 === 12 ? f : -idx,\n        idx % 16 === 13 ? f : idx,\n        idx % 16 === 14 ? f : -idx,\n        idx % 16 === 15 ? f : idx,\n      ],\n    ]),\n  },\n};\n\n/**\n * Returns a minimal set of matrices, indexed by dimension containing interesting\n * float values.\n *\n * This is the matrix analogue of `sparseVectorF32Range`, so it is producing a\n * minimal coverage set of matrices that test all of the interesting f32 values.\n * There is not a more expansive set of matrices, since matrices are even more\n * expensive than vectors for increasing runtime with coverage.\n *\n * All of the interesting floats from sparseF32 are guaranteed to be tested, but\n * not in every position.\n */\nexport function sparseMatrixF32Range(c: number, r: number): number[][][] {\n  assert(\n    c === 2 || c === 3 || c === 4,\n    'sparseMatrixF32Range only accepts column counts of 2, 3, and 4'\n  );\n  assert(\n    r === 2 || r === 3 || r === 4,\n    'sparseMatrixF32Range only accepts row counts of 2, 3, and 4'\n  );\n  return kSparseMatrixF32Values[c][r];\n}\n\n/**\n * @returns the result matrix in Array<Array<number>> type.\n *\n * Matrix multiplication. A is m x n and B is n x p. Returns\n * m x p result.\n */\n// A is m x n. B is n x p. product is m x p.\nexport function multiplyMatrices(\n  A: Array<Array<number>>,\n  B: Array<Array<number>>\n): Array<Array<number>> {\n  assert(A.length > 0 && B.length > 0 && B[0].length > 0 && A[0].length === B.length);\n  const product = new Array<Array<number>>(A.length);\n  for (let i = 0; i < product.length; ++i) {\n    product[i] = new Array<number>(B[0].length).fill(0);\n  }\n\n  for (let m = 0; m < A.length; ++m) {\n    for (let p = 0; p < B[0].length; ++p) {\n      for (let n = 0; n < B.length; ++n) {\n        product[m][p] += A[m][n] * B[n][p];\n      }\n    }\n  }\n\n  return product;\n}\n\n/** Sign-extend the `bits`-bit number `n` to a 32-bit signed integer. */\nexport function signExtend(n: number, bits: number): number {\n  const shift = 32 - bits;\n  return (n << shift) >> shift;\n}\n\nexport interface QuantizeFunc {\n  (num: number): number;\n}\n\n/** @returns the closest 32-bit floating point value to the input */\nexport function quantizeToF32(num: number): number {\n  return f32(num).value as number;\n}\n\n/** @returns the closest 32-bit signed integer value to the input */\nexport function quantizeToI32(num: number): number {\n  return i32(num).value as number;\n}\n\n/** @returns the closest 32-bit signed integer value to the input */\nexport function quantizeToU32(num: number): number {\n  return u32(num).value as number;\n}\n\n/** @returns whether the number is an integer and a power of two */\nexport function isPowerOfTwo(n: number): boolean {\n  if (!Number.isInteger(n)) {\n    return false;\n  }\n  return n !== 0 && (n & (n - 1)) === 0;\n}\n\n/** @returns the Greatest Common Divisor (GCD) of the inputs */\nexport function gcd(a: number, b: number): number {\n  assert(Number.isInteger(a) && a > 0);\n  assert(Number.isInteger(b) && b > 0);\n\n  while (b !== 0) {\n    const bTemp = b;\n    b = a % b;\n    a = bTemp;\n  }\n\n  return a;\n}\n\n/** @returns the Least Common Multiplier (LCM) of the inputs */\nexport function lcm(a: number, b: number): number {\n  return (a * b) / gcd(a, b);\n}\n\n/** Converts a 32-bit hex value to a 32-bit float value */\nexport function hexToF32(hex: number): number {\n  return floatBitsToNumber(hex, kFloat32Format);\n}\n\n/** Converts a 16-bit hex value to a 16-bit float value */\nexport function hexToF16(hex: number): number {\n  return floatBitsToNumber(hex, kFloat16Format);\n}\n\n/** Converts 64-bit hex value to a 64-bit float value */\nexport function hexToF64(hex: bigint): number {\n  return new Float64Array(new BigInt64Array([hex]).buffer)[0];\n}\n\n/** @returns the cross of an array with the intermediate result of cartesianProduct\n *\n * @param elements array of values to cross with the intermediate result of\n *                 cartesianProduct\n * @param intermediate arrays of values representing the partial result of\n *                     cartesianProduct\n */\nfunction cartesianProductImpl<T>(elements: T[], intermediate: T[][]): T[][] {\n  const result: T[][] = [];\n  elements.forEach((e: T) => {\n    if (intermediate.length > 0) {\n      intermediate.forEach((i: T[]) => {\n        result.push([...i, e]);\n      });\n    } else {\n      result.push([e]);\n    }\n  });\n  return result;\n}\n\n/** @returns the cartesian product (NxMx...) of a set of arrays\n *\n * This is implemented by calculating the cross of a single input against an\n * intermediate result for each input to build up the final array of arrays.\n *\n * There are examples of doing this more succinctly using map & reduce online,\n * but they are a bit more opaque to read.\n *\n * @param inputs arrays of numbers to calculate cartesian product over\n */\nexport function cartesianProduct<T>(...inputs: T[][]): T[][] {\n  let result: T[][] = [];\n  inputs.forEach((i: T[]) => {\n    result = cartesianProductImpl<T>(i, result);\n  });\n\n  return result;\n}\n\n/** @returns all of the permutations of an array\n *\n * Recursively calculates all of the permutations, does not cull duplicate\n * entries.\n *\n * Only feasible for inputs of lengths 5 or so, since the number of permutations\n * is (input.length)!, so will cause the stack to explode for longer inputs.\n *\n * This code could be made iterative using something like\n * Steinhaus–Johnson–Trotter and additionally turned into a generator to reduce\n * the stack size, but there is still a fundamental combinatorial explosion\n * here that will affect runtime.\n *\n * @param input the array to get permutations of\n */\nexport function calculatePermutations<T>(input: T[]): T[][] {\n  if (input.length === 0) {\n    return [];\n  }\n\n  if (input.length === 1) {\n    return [input];\n  }\n\n  if (input.length === 2) {\n    return [input, [input[1], input[0]]];\n  }\n\n  const result: T[][] = [];\n  input.forEach((head, idx) => {\n    const tail = input.slice(0, idx).concat(input.slice(idx + 1));\n    const permutations = calculatePermutations(tail);\n    permutations.forEach(p => {\n      result.push([head, ...p]);\n    });\n  });\n\n  return result;\n}\n\n/**\n * Convert an Array of Arrays to linear array\n *\n * Caller is responsible to retaining the dimensions of the array for later\n * unflattening\n *\n * @param m Matrix to convert\n */\nexport function flatten2DArray<T>(m: T[][]): T[] {\n  const c = m.length;\n  const r = m[0].length;\n  assert(\n    m.every(c => c.length === r),\n    `Unexpectedly received jagged array to flatten`\n  );\n  const result: T[] = Array<T>(c * r);\n  for (let i = 0; i < c; i++) {\n    for (let j = 0; j < r; j++) {\n      result[j + i * r] = m[i][j];\n    }\n  }\n  return result;\n}\n\n/**\n * Convert linear array to an Array of Arrays\n * @param n an array to convert\n * @param c number of elements in the array containing arrays\n * @param r number of elements in the arrays that are contained\n */\nexport function unflatten2DArray<T>(n: T[], c: number, r: number): T[][] {\n  assert(\n    c > 0 && Number.isInteger(c) && r > 0 && Number.isInteger(r),\n    `columns (${c}) and rows (${r}) need to be positive integers`\n  );\n  assert(n.length === c * r, `m.length(${n.length}) should equal c * r (${c * r})`);\n  const result: T[][] = [...Array(c)].map(_ => [...Array(r)]);\n  for (let i = 0; i < c; i++) {\n    for (let j = 0; j < r; j++) {\n      result[i][j] = n[j + i * r];\n    }\n  }\n  return result;\n}\n\n/**\n * Performs a .map over a matrix and return the result\n * The shape of the input and output matrices will be the same\n *\n * @param m input matrix of type T\n * @param op operation that converts an element of type T to one of type S\n * @returns a matrix with elements of type S that are calculated by applying op element by element\n */\nexport function map2DArray<T, S>(m: T[][], op: (input: T) => S): S[][] {\n  const c = m.length;\n  const r = m[0].length;\n  assert(\n    m.every(c => c.length === r),\n    `Unexpectedly received jagged array to map`\n  );\n  const result: S[][] = [...Array(c)].map(_ => [...Array(r)]);\n  for (let i = 0; i < c; i++) {\n    for (let j = 0; j < r; j++) {\n      result[i][j] = op(m[i][j]);\n    }\n  }\n  return result;\n}\n"],"mappings":"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"}
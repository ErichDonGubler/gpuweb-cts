{"version":3,"sources":["../../../../src/webgpu/util/texture/layout.ts"],"names":["assert","memcpy","kTextureFormatInfo","align","reifyExtent3D","virtualMipSize","kBytesPerRowAlignment","kBufferCopyAlignment","kDefaultLayoutOptions","mipLevel","bytesPerRow","undefined","rowsPerImage","getTextureCopyLayout","format","dimension","baseSize","mipSize","layout","getTextureSubCopyLayout","copySize","blockWidth","blockHeight","bytesPerBlock","copySize_","width","height","depthOrArrayLayers","copySizeBlocks","minBytesPerRow","alignedMinBytesPerRow","bytesPerSlice","sliceSize","byteLength","fillTextureDataWithTexelValue","texelValue","outputBuffer","size","options","outputTexelValueBytes","Uint8Array","slice","row","col","byteOffset","src","dst","start","createTextureUploadBuffer","device","buffer","createBuffer","mappedAtCreation","usage","GPUBufferUsage","COPY_SRC","mapping","getMappedRange","unmap","kImageCopyTypes","bytesInACompleteRow","copyWidth","info","validateBytesPerRow","bytesInLastRow","sizeInBlocks","validateRowsPerImage","dataBytesForCopyOrFail","args","minDataSizeOrOverestimate","copyValid","dataBytesForCopyOrOverestimate","method","copyExtent","valid","offset","requiredBytesInCopy","bytesPerImage","bytesBeforeLastImage"],"mappings":";AAAA;AACA,GADA,SAASA,MAAT,EAAiBC,MAAjB,QAA+B,8BAA/B,CACA;AAEEC,kBAFF;;AAIO,0BAJP;AAKA,SAASC,KAAT,QAAsB,YAAtB;AACA,SAASC,aAAT,QAA8B,cAA9B;;AAEA,SAASC,cAAT,QAA+B,WAA/B;;AAEA;AACA,OAAO,MAAMC,qBAAqB,GAAG,GAA9B;AACP;AACA,OAAO,MAAMC,oBAAoB,GAAG,CAA7B;;AAEP;AACA;AACA;;;;;;;AAOA,MAAMC,qBAAqB,GAAG,EAAEC,QAAQ,EAAE,CAAZ,EAAeC,WAAW,EAAEC,SAA5B,EAAuCC,YAAY,EAAED,SAArD,EAA9B;;AAEA;;;;;;;;;;;;;;;;;;;;AAoBA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASE,oBAAT;AACLC,MADK;AAELC,SAFK;AAGLC,QAHK;AAIL,EAAEP,QAAF,EAAYC,WAAZ,EAAyBE,YAAzB,KAAyDJ,qBAJpD;AAKc;AACnB,QAAMS,OAAO,GAAGZ,cAAc,CAACU,SAAD,EAAYC,QAAZ,EAAsBP,QAAtB,CAA9B;;AAEA,QAAMS,MAAM,GAAGC,uBAAuB,CAACL,MAAD,EAASG,OAAT,EAAkB,EAAEP,WAAF,EAAeE,YAAf,EAAlB,CAAtC;AACA,SAAO,EAAE,GAAGM,MAAL,EAAaD,OAAb,EAAP;AACD;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASE,uBAAT;AACLL,MADK;AAELM,QAFK;AAGL;AACEV,EAAAA,WADF;AAEEE,EAAAA,YAFF;AAGuE,EANlE;AAOiB;AACtB,QAAM,EAAES,UAAF,EAAcC,WAAd,EAA2BC,aAA3B,KAA6CrB,kBAAkB,CAACY,MAAD,CAArE;;AAEA,QAAMU,SAAS,GAAGpB,aAAa,CAACgB,QAAD,CAA/B;AACApB,EAAAA,MAAM;AACJwB,EAAAA,SAAS,CAACC,KAAV,GAAkB,CAAlB,IAAuBD,SAAS,CAACE,MAAV,GAAmB,CAA1C,IAA+CF,SAAS,CAACG,kBAAV,GAA+B,CAD1E;AAEJ,sCAFI,CAAN;;AAIA3B,EAAAA,MAAM;AACJwB,EAAAA,SAAS,CAACC,KAAV,GAAkBJ,UAAlB,KAAiC,CAAjC,IAAsCG,SAAS,CAACE,MAAV,GAAmBJ,WAAnB,KAAmC,CADrE;AAEJ,iDAFI,CAAN;;AAIA,QAAMM,cAAc,GAAG;AACrBH,IAAAA,KAAK,EAAED,SAAS,CAACC,KAAV,GAAkBJ,UADJ;AAErBK,IAAAA,MAAM,EAAEF,SAAS,CAACE,MAAV,GAAmBJ,WAFN;AAGrBK,IAAAA,kBAAkB,EAAEH,SAAS,CAACG,kBAHT,EAAvB;;;AAMA,QAAME,cAAc,GAAGD,cAAc,CAACH,KAAf,GAAuBF,aAA9C;AACA,QAAMO,qBAAqB,GAAG3B,KAAK,CAAC0B,cAAD,EAAiBvB,qBAAjB,CAAnC;AACA,MAAII,WAAW,KAAKC,SAApB,EAA+B;AAC7BX,IAAAA,MAAM,CAACU,WAAW,IAAIoB,qBAAhB,CAAN;AACA9B,IAAAA,MAAM,CAACU,WAAW,GAAGJ,qBAAd,KAAwC,CAAzC,CAAN;AACD,GAHD,MAGO;AACLI,IAAAA,WAAW,GAAGoB,qBAAd;AACD;;AAED,MAAIlB,YAAY,KAAKD,SAArB,EAAgC;AAC9BX,IAAAA,MAAM,CAACY,YAAY,IAAIgB,cAAc,CAACF,MAAhC,CAAN;AACD,GAFD,MAEO;AACLd,IAAAA,YAAY,GAAGgB,cAAc,CAACF,MAA9B;AACD;;AAED,QAAMK,aAAa,GAAGrB,WAAW,GAAGE,YAApC;AACA,QAAMoB,SAAS;AACbtB,EAAAA,WAAW,IAAIkB,cAAc,CAACF,MAAf,GAAwB,CAA5B,CAAX,GAA4CH,aAAa,GAAGK,cAAc,CAACH,KAD7E;AAEA,QAAMQ,UAAU,GAAGF,aAAa,IAAIH,cAAc,CAACD,kBAAf,GAAoC,CAAxC,CAAb,GAA0DK,SAA7E;;AAEA,SAAO;AACLT,IAAAA,aADK;AAELU,IAAAA,UAAU,EAAE9B,KAAK,CAAC8B,UAAD,EAAa1B,oBAAb,CAFZ;AAGLsB,IAAAA,cAHK;AAILnB,IAAAA,WAJK;AAKLE,IAAAA,YALK,EAAP;;AAOD;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASsB,6BAAT;AACLC,UADK;AAELrB,MAFK;AAGLC,SAHK;AAILqB,YAJK;AAKLC,IALK;AAMLC,OAAsB,GAAG9B,qBANpB;AAOC;AACN,QAAM,EAAEa,UAAF,EAAcC,WAAd,EAA2BC,aAA3B,KAA6CrB,kBAAkB,CAACY,MAAD,CAArE;AACA;AACAd,EAAAA,MAAM,CAACqB,UAAU,KAAK,CAAhB,CAAN;AACArB,EAAAA,MAAM,CAACsB,WAAW,KAAK,CAAjB,CAAN;;AAEAtB,EAAAA,MAAM,CAACuB,aAAa,KAAKY,UAAU,CAACF,UAA9B,EAA0C,0CAA1C,CAAN;;AAEA,QAAM,EAAEA,UAAF,EAAcrB,YAAd,EAA4BF,WAA5B,KAA4CG,oBAAoB;AACpEC,EAAAA,MADoE;AAEpEC,EAAAA,SAFoE;AAGpEsB,EAAAA,IAHoE;AAIpEC,EAAAA,OAJoE,CAAtE;;;AAOAtC,EAAAA,MAAM,CAACiC,UAAU,IAAIG,YAAY,CAACH,UAA5B,CAAN;;AAEA,QAAMhB,OAAO,GAAGZ,cAAc,CAACU,SAAD,EAAYsB,IAAZ,EAAkBC,OAAO,CAAC7B,QAA1B,CAA9B;;AAEA,QAAM8B,qBAAqB,GAAG,IAAIC,UAAJ,CAAeJ,YAAf,CAA9B;AACA,OAAK,IAAIK,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAGxB,OAAO,CAAC,CAAD,CAAnC,EAAwC,EAAEwB,KAA1C,EAAiD;AAC/C,SAAK,IAAIC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGzB,OAAO,CAAC,CAAD,CAA/B,EAAoCyB,GAAG,IAAIpB,WAA3C,EAAwD;AACtD,WAAK,IAAIqB,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAG1B,OAAO,CAAC,CAAD,CAA/B,EAAoC0B,GAAG,IAAItB,UAA3C,EAAuD;AACrD,cAAMuB,UAAU;AACdH,QAAAA,KAAK,GAAG7B,YAAR,GAAuBF,WAAvB,GAAqCgC,GAAG,GAAGhC,WAA3C,GAAyDiC,GAAG,GAAGR,UAAU,CAACF,UAD5E;AAEAhC,QAAAA,MAAM,CAAC,EAAE4C,GAAG,EAAEV,UAAP,EAAD,EAAsB,EAAEW,GAAG,EAAEP,qBAAP,EAA8BQ,KAAK,EAAEH,UAArC,EAAtB,CAAN;AACD;AACF;AACF;AACF;;AAED;AACA;AACA;AACA;AACA,OAAO,SAASI,yBAAT;AACLb,UADK;AAELc,MAFK;AAGLnC,MAHK;AAILC,SAJK;AAKLsB,IALK;AAMLC,OAAsB,GAAG9B,qBANpB;;;;;AAWL;AACA,QAAM,EAAEyB,UAAF,EAAcvB,WAAd,EAA2BE,YAA3B,EAAyCW,aAAzC,KAA2DV,oBAAoB;AACnFC,EAAAA,MADmF;AAEnFC,EAAAA,SAFmF;AAGnFsB,EAAAA,IAHmF;AAInFC,EAAAA,OAJmF,CAArF;;;AAOA,QAAMY,MAAM,GAAGD,MAAM,CAACE,YAAP,CAAoB;AACjCC,IAAAA,gBAAgB,EAAE,IADe;AAEjCf,IAAAA,IAAI,EAAEJ,UAF2B;AAGjCoB,IAAAA,KAAK,EAAEC,cAAc,CAACC,QAHW,EAApB,CAAf;;AAKA,QAAMC,OAAO,GAAGN,MAAM,CAACO,cAAP,EAAhB;;AAEAzD,EAAAA,MAAM,CAACmC,UAAU,CAACF,UAAX,KAA0BV,aAA3B,CAAN;AACAW,EAAAA,6BAA6B,CAACC,UAAD,EAAarB,MAAb,EAAqBC,SAArB,EAAgCyC,OAAhC,EAAyCnB,IAAzC,EAA+CC,OAA/C,CAA7B;AACAY,EAAAA,MAAM,CAACQ,KAAP;;AAEA,SAAO;AACLR,IAAAA,MADK;AAELxC,IAAAA,WAFK;AAGLE,IAAAA,YAHK,EAAP;;AAKD;;;AAGD,OAAO,MAAM+C,eAAyC,GAAG;AACvD,cADuD;AAEvD,SAFuD;AAGvD,SAHuD,CAAlD;;;AAMP;AACA;AACA;AACA,OAAO,SAASC,mBAAT,CAA6BC,SAA7B,EAAgD/C,MAAhD,EAAoF;AACzF,QAAMgD,IAAI,GAAG5D,kBAAkB,CAACY,MAAD,CAA/B;AACAd,EAAAA,MAAM,CAAC6D,SAAS,GAAGC,IAAI,CAACzC,UAAjB,KAAgC,CAAjC,CAAN;AACA,SAAQyC,IAAI,CAACvC,aAAL,GAAqBsC,SAAtB,GAAmCC,IAAI,CAACzC,UAA/C;AACD;;AAED,SAAS0C,mBAAT,CAA6B;AAC3BrD,EAAAA,WAD2B;AAE3BsD,EAAAA,cAF2B;AAG3BC,EAAAA,YAH2B,EAA7B;;;;;AAQG;AACD;AACA,MAAIvD,WAAW,KAAKC,SAAhB,IAA6BD,WAAW,GAAGsD,cAA/C,EAA+D;AAC7D,WAAO,KAAP;AACD;AACD;AACA;AACA;AACEtD,EAAAA,WAAW,KAAKC,SAAhB;AACCsD,EAAAA,YAAY,CAACvC,MAAb,GAAsB,CAAtB,IAA2BuC,YAAY,CAACtC,kBAAb,GAAkC,CAD9D,CADF;AAGE;AACA,WAAO,KAAP;AACD;AACD,SAAO,IAAP;AACD;;AAED,SAASuC,oBAAT,CAA8B;AAC5BtD,EAAAA,YAD4B;AAE5BqD,EAAAA,YAF4B,EAA9B;;;;AAMG;AACD;AACA,MAAIrD,YAAY,KAAKD,SAAjB,IAA8BC,YAAY,GAAGqD,YAAY,CAACvC,MAA9D,EAAsE;AACpE,WAAO,KAAP;AACD;AACD;AACA,MAAId,YAAY,KAAKD,SAAjB,IAA8BsD,YAAY,CAACtC,kBAAb,GAAkC,CAApE,EAAuE;AACrE,WAAO,KAAP;AACD;AACD,SAAO,IAAP;AACD;;;;;;;;;AASD;AACA;AACA;AACA,OAAO,SAASwC,sBAAT,CAAgCC,IAAhC,EAAoE;AACzE,QAAM,EAAEC,yBAAF,EAA6BC,SAA7B,KAA2CC,8BAA8B,CAACH,IAAD,CAA/E;AACApE,EAAAA,MAAM,CAACsE,SAAD,EAAY,kBAAZ,CAAN;AACA,SAAOD,yBAAP;AACD;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASE,8BAAT,CAAwC;AAC7CrD,EAAAA,MAD6C;AAE7CJ,EAAAA,MAF6C;AAG7CM,EAAAA,QAAQ,EAAEI,SAHmC;AAI7CgD,EAAAA,MAJ6C,EAAxC;AAK6E;AAClF,QAAMC,UAAU,GAAGrE,aAAa,CAACoB,SAAD,CAAhC;;AAEA,QAAMsC,IAAI,GAAG5D,kBAAkB,CAACY,MAAD,CAA/B;AACAd,EAAAA,MAAM,CAACyE,UAAU,CAAChD,KAAX,GAAmBqC,IAAI,CAACzC,UAAxB,KAAuC,CAAxC,CAAN;AACArB,EAAAA,MAAM,CAACyE,UAAU,CAAC/C,MAAX,GAAoBoC,IAAI,CAACxC,WAAzB,KAAyC,CAA1C,CAAN;AACA,QAAM2C,YAAY,GAAG;AACnBxC,IAAAA,KAAK,EAAEgD,UAAU,CAAChD,KAAX,GAAmBqC,IAAI,CAACzC,UADZ;AAEnBK,IAAAA,MAAM,EAAE+C,UAAU,CAAC/C,MAAX,GAAoBoC,IAAI,CAACxC,WAFd;AAGnBK,IAAAA,kBAAkB,EAAE8C,UAAU,CAAC9C,kBAHZ,EAArB;;AAKA,QAAMqC,cAAc,GAAGC,YAAY,CAACxC,KAAb,GAAqBqC,IAAI,CAACvC,aAAjD;;AAEA,MAAImD,KAAK,GAAG,IAAZ;AACA,QAAMC,MAAM,GAAGzD,MAAM,CAACyD,MAAP,IAAiB,CAAhC;AACA,MAAIH,MAAM,KAAK,cAAf,EAA+B;AAC7B,QAAIG,MAAM,GAAGb,IAAI,CAACvC,aAAd,KAAgC,CAApC,EAAuCmD,KAAK,GAAG,KAAR;AACvC,QAAIxD,MAAM,CAACR,WAAP,IAAsBQ,MAAM,CAACR,WAAP,GAAqB,GAArB,KAA6B,CAAvD,EAA0DgE,KAAK,GAAG,KAAR;AAC3D;;AAED,MAAIE,mBAAmB,GAAG,CAA1B;AACA;AACE,QAAI,EAAElE,WAAF,EAAeE,YAAf,KAAgCM,MAApC;;AAEA;AACA;AACA;AACA;AACA,QAAI,CAAC6C,mBAAmB,CAAC,EAAErD,WAAF,EAAesD,cAAf,EAA+BC,YAA/B,EAAD,CAAxB,EAAyE;AACvEvD,MAAAA,WAAW,GAAGC,SAAd;AACA+D,MAAAA,KAAK,GAAG,KAAR;AACD;AACD,QAAI,CAACR,oBAAoB,CAAC,EAAEtD,YAAF,EAAgBqD,YAAhB,EAAD,CAAzB,EAA2D;AACzDrD,MAAAA,YAAY,GAAGD,SAAf;AACA+D,MAAAA,KAAK,GAAG,KAAR;AACD;AACD;AACAhE,IAAAA,WAAW,KAAKP,KAAK,CAAC2D,IAAI,CAACvC,aAAL,GAAqB0C,YAAY,CAACxC,KAAnC,EAA0C,GAA1C,CAArB;AACAb,IAAAA,YAAY,KAAKqD,YAAY,CAACvC,MAA9B;;AAEA,QAAI+C,UAAU,CAAC9C,kBAAX,GAAgC,CAApC,EAAuC;AACrC,YAAMkD,aAAa,GAAGnE,WAAW,GAAGE,YAApC;AACA,YAAMkE,oBAAoB,GAAGD,aAAa,IAAIJ,UAAU,CAAC9C,kBAAX,GAAgC,CAApC,CAA1C;AACAiD,MAAAA,mBAAmB,IAAIE,oBAAvB;AACD;AACD,QAAIL,UAAU,CAAC9C,kBAAX,GAAgC,CAApC,EAAuC;AACrC,UAAIsC,YAAY,CAACvC,MAAb,GAAsB,CAA1B,EAA6BkD,mBAAmB,IAAIlE,WAAW,IAAIuD,YAAY,CAACvC,MAAb,GAAsB,CAA1B,CAAlC;AAC7B,UAAIuC,YAAY,CAACvC,MAAb,GAAsB,CAA1B,EAA6BkD,mBAAmB,IAAIZ,cAAvB;AAC9B;AACF;;AAED,SAAO,EAAEK,yBAAyB,EAAEM,MAAM,GAAGC,mBAAtC,EAA2DN,SAAS,EAAEI,KAAtE,EAAP;AACD","sourcesContent":["import { assert, memcpy } from '../../../common/util/util.js';\nimport {\n  EncodableTextureFormat,\n  kTextureFormatInfo,\n  SizedTextureFormat,\n} from '../../capability_info.js';\nimport { align } from '../math.js';\nimport { reifyExtent3D } from '../unions.js';\n\nimport { virtualMipSize } from './base.js';\n\n/** The minimum `bytesPerRow` alignment, per spec. */\nexport const kBytesPerRowAlignment = 256;\n/** The minimum buffer copy alignment, per spec. */\nexport const kBufferCopyAlignment = 4;\n\n/**\n * Overridable layout options for {@link getTextureCopyLayout}.\n */\nexport interface LayoutOptions {\n  mipLevel: number;\n  bytesPerRow?: number;\n  rowsPerImage?: number;\n}\n\nconst kDefaultLayoutOptions = { mipLevel: 0, bytesPerRow: undefined, rowsPerImage: undefined };\n\n/** The info returned by {@link getTextureSubCopyLayout}. */\nexport interface TextureSubCopyLayout {\n  bytesPerBlock: number;\n  byteLength: number;\n  /** Number of bytes in each row, not accounting for {@link kBytesPerRowAlignment}. */\n  minBytesPerRow: number;\n  /**\n   * Actual value of bytesPerRow, defaulting to `align(minBytesPerRow, kBytesPerRowAlignment}`\n   * if not overridden.\n   */\n  bytesPerRow: number;\n  /** Actual value of rowsPerImage, defaulting to `mipSize[1]` if not overridden. */\n  rowsPerImage: number;\n}\n\n/** The info returned by {@link getTextureCopyLayout}. */\nexport interface TextureCopyLayout extends TextureSubCopyLayout {\n  mipSize: [number, number, number];\n}\n\n/**\n * Computes layout information for a copy of the whole subresource at `mipLevel` of a GPUTexture\n * of size `baseSize` with the provided `format` and `dimension`.\n *\n * Computes default values for `bytesPerRow` and `rowsPerImage` if not specified.\n */\nexport function getTextureCopyLayout(\n  format: SizedTextureFormat,\n  dimension: GPUTextureDimension,\n  baseSize: readonly [number, number, number],\n  { mipLevel, bytesPerRow, rowsPerImage }: LayoutOptions = kDefaultLayoutOptions\n): TextureCopyLayout {\n  const mipSize = virtualMipSize(dimension, baseSize, mipLevel);\n\n  const layout = getTextureSubCopyLayout(format, mipSize, { bytesPerRow, rowsPerImage });\n  return { ...layout, mipSize };\n}\n\n/**\n * Computes layout information for a copy of size `copySize` to/from a GPUTexture with the provided\n * `format`.\n *\n * Computes default values for `bytesPerRow` and `rowsPerImage` if not specified.\n */\nexport function getTextureSubCopyLayout(\n  format: SizedTextureFormat,\n  copySize: GPUExtent3D,\n  {\n    bytesPerRow,\n    rowsPerImage,\n  }: { readonly bytesPerRow?: number; readonly rowsPerImage?: number } = {}\n): TextureSubCopyLayout {\n  const { blockWidth, blockHeight, bytesPerBlock } = kTextureFormatInfo[format];\n\n  const copySize_ = reifyExtent3D(copySize);\n  assert(\n    copySize_.width > 0 && copySize_.height > 0 && copySize_.depthOrArrayLayers > 0,\n    'not implemented for empty copySize'\n  );\n  assert(\n    copySize_.width % blockWidth === 0 && copySize_.height % blockHeight === 0,\n    'copySize must be a multiple of the block size'\n  );\n  const copySizeBlocks = {\n    width: copySize_.width / blockWidth,\n    height: copySize_.height / blockHeight,\n    depthOrArrayLayers: copySize_.depthOrArrayLayers,\n  };\n\n  const minBytesPerRow = copySizeBlocks.width * bytesPerBlock;\n  const alignedMinBytesPerRow = align(minBytesPerRow, kBytesPerRowAlignment);\n  if (bytesPerRow !== undefined) {\n    assert(bytesPerRow >= alignedMinBytesPerRow);\n    assert(bytesPerRow % kBytesPerRowAlignment === 0);\n  } else {\n    bytesPerRow = alignedMinBytesPerRow;\n  }\n\n  if (rowsPerImage !== undefined) {\n    assert(rowsPerImage >= copySizeBlocks.height);\n  } else {\n    rowsPerImage = copySizeBlocks.height;\n  }\n\n  const bytesPerSlice = bytesPerRow * rowsPerImage;\n  const sliceSize =\n    bytesPerRow * (copySizeBlocks.height - 1) + bytesPerBlock * copySizeBlocks.width;\n  const byteLength = bytesPerSlice * (copySizeBlocks.depthOrArrayLayers - 1) + sliceSize;\n\n  return {\n    bytesPerBlock,\n    byteLength: align(byteLength, kBufferCopyAlignment),\n    minBytesPerRow,\n    bytesPerRow,\n    rowsPerImage,\n  };\n}\n\n/**\n * Fill an ArrayBuffer with the linear-memory representation of a solid-color\n * texture where every texel has the byte value `texelValue`.\n * Preserves the contents of `outputBuffer` which are in \"padding\" space between image rows.\n *\n * Effectively emulates a copyTextureToBuffer from a solid-color texture to a buffer.\n */\nexport function fillTextureDataWithTexelValue(\n  texelValue: ArrayBuffer,\n  format: EncodableTextureFormat,\n  dimension: GPUTextureDimension,\n  outputBuffer: ArrayBuffer,\n  size: [number, number, number],\n  options: LayoutOptions = kDefaultLayoutOptions\n): void {\n  const { blockWidth, blockHeight, bytesPerBlock } = kTextureFormatInfo[format];\n  // Block formats are not handled correctly below.\n  assert(blockWidth === 1);\n  assert(blockHeight === 1);\n\n  assert(bytesPerBlock === texelValue.byteLength, 'texelValue must be of size bytesPerBlock');\n\n  const { byteLength, rowsPerImage, bytesPerRow } = getTextureCopyLayout(\n    format,\n    dimension,\n    size,\n    options\n  );\n\n  assert(byteLength <= outputBuffer.byteLength);\n\n  const mipSize = virtualMipSize(dimension, size, options.mipLevel);\n\n  const outputTexelValueBytes = new Uint8Array(outputBuffer);\n  for (let slice = 0; slice < mipSize[2]; ++slice) {\n    for (let row = 0; row < mipSize[1]; row += blockHeight) {\n      for (let col = 0; col < mipSize[0]; col += blockWidth) {\n        const byteOffset =\n          slice * rowsPerImage * bytesPerRow + row * bytesPerRow + col * texelValue.byteLength;\n        memcpy({ src: texelValue }, { dst: outputTexelValueBytes, start: byteOffset });\n      }\n    }\n  }\n}\n\n/**\n * Create a `COPY_SRC` GPUBuffer containing the linear-memory representation of a solid-color\n * texture where every texel has the byte value `texelValue`.\n */\nexport function createTextureUploadBuffer(\n  texelValue: ArrayBuffer,\n  device: GPUDevice,\n  format: EncodableTextureFormat,\n  dimension: GPUTextureDimension,\n  size: [number, number, number],\n  options: LayoutOptions = kDefaultLayoutOptions\n): {\n  buffer: GPUBuffer;\n  bytesPerRow: number;\n  rowsPerImage: number;\n} {\n  const { byteLength, bytesPerRow, rowsPerImage, bytesPerBlock } = getTextureCopyLayout(\n    format,\n    dimension,\n    size,\n    options\n  );\n\n  const buffer = device.createBuffer({\n    mappedAtCreation: true,\n    size: byteLength,\n    usage: GPUBufferUsage.COPY_SRC,\n  });\n  const mapping = buffer.getMappedRange();\n\n  assert(texelValue.byteLength === bytesPerBlock);\n  fillTextureDataWithTexelValue(texelValue, format, dimension, mapping, size, options);\n  buffer.unmap();\n\n  return {\n    buffer,\n    bytesPerRow,\n    rowsPerImage,\n  };\n}\n\nexport type ImageCopyType = 'WriteTexture' | 'CopyB2T' | 'CopyT2B';\nexport const kImageCopyTypes: readonly ImageCopyType[] = [\n  'WriteTexture',\n  'CopyB2T',\n  'CopyT2B',\n] as const;\n\n/**\n * Computes `bytesInACompleteRow` (as defined by the WebGPU spec) for image copies (B2T/T2B/writeTexture).\n */\nexport function bytesInACompleteRow(copyWidth: number, format: SizedTextureFormat): number {\n  const info = kTextureFormatInfo[format];\n  assert(copyWidth % info.blockWidth === 0);\n  return (info.bytesPerBlock * copyWidth) / info.blockWidth;\n}\n\nfunction validateBytesPerRow({\n  bytesPerRow,\n  bytesInLastRow,\n  sizeInBlocks,\n}: {\n  bytesPerRow: number | undefined;\n  bytesInLastRow: number;\n  sizeInBlocks: Required<GPUExtent3DDict>;\n}) {\n  // If specified, layout.bytesPerRow must be greater than or equal to bytesInLastRow.\n  if (bytesPerRow !== undefined && bytesPerRow < bytesInLastRow) {\n    return false;\n  }\n  // If heightInBlocks > 1, layout.bytesPerRow must be specified.\n  // If copyExtent.depthOrArrayLayers > 1, layout.bytesPerRow and layout.rowsPerImage must be specified.\n  if (\n    bytesPerRow === undefined &&\n    (sizeInBlocks.height > 1 || sizeInBlocks.depthOrArrayLayers > 1)\n  ) {\n    return false;\n  }\n  return true;\n}\n\nfunction validateRowsPerImage({\n  rowsPerImage,\n  sizeInBlocks,\n}: {\n  rowsPerImage: number | undefined;\n  sizeInBlocks: Required<GPUExtent3DDict>;\n}) {\n  // If specified, layout.rowsPerImage must be greater than or equal to heightInBlocks.\n  if (rowsPerImage !== undefined && rowsPerImage < sizeInBlocks.height) {\n    return false;\n  }\n  // If copyExtent.depthOrArrayLayers > 1, layout.bytesPerRow and layout.rowsPerImage must be specified.\n  if (rowsPerImage === undefined && sizeInBlocks.depthOrArrayLayers > 1) {\n    return false;\n  }\n  return true;\n}\n\ninterface DataBytesForCopyArgs {\n  layout: GPUImageDataLayout;\n  format: SizedTextureFormat;\n  copySize: Readonly<GPUExtent3DDict> | readonly number[];\n  method: ImageCopyType;\n}\n\n/**\n * Validate a copy and compute the number of bytes it needs. Throws if the copy is invalid.\n */\nexport function dataBytesForCopyOrFail(args: DataBytesForCopyArgs): number {\n  const { minDataSizeOrOverestimate, copyValid } = dataBytesForCopyOrOverestimate(args);\n  assert(copyValid, 'copy was invalid');\n  return minDataSizeOrOverestimate;\n}\n\n/**\n * Validate a copy and compute the number of bytes it needs. If the copy is invalid, attempts to\n * \"conservatively guess\" (overestimate) the number of bytes that could be needed for a copy, even\n * if the copy parameters turn out to be invalid. This hopes to avoid \"buffer too small\" validation\n * errors when attempting to test other validation errors.\n */\nexport function dataBytesForCopyOrOverestimate({\n  layout,\n  format,\n  copySize: copySize_,\n  method,\n}: DataBytesForCopyArgs): { minDataSizeOrOverestimate: number; copyValid: boolean } {\n  const copyExtent = reifyExtent3D(copySize_);\n\n  const info = kTextureFormatInfo[format];\n  assert(copyExtent.width % info.blockWidth === 0);\n  assert(copyExtent.height % info.blockHeight === 0);\n  const sizeInBlocks = {\n    width: copyExtent.width / info.blockWidth,\n    height: copyExtent.height / info.blockHeight,\n    depthOrArrayLayers: copyExtent.depthOrArrayLayers,\n  } as const;\n  const bytesInLastRow = sizeInBlocks.width * info.bytesPerBlock;\n\n  let valid = true;\n  const offset = layout.offset ?? 0;\n  if (method !== 'WriteTexture') {\n    if (offset % info.bytesPerBlock !== 0) valid = false;\n    if (layout.bytesPerRow && layout.bytesPerRow % 256 !== 0) valid = false;\n  }\n\n  let requiredBytesInCopy = 0;\n  {\n    let { bytesPerRow, rowsPerImage } = layout;\n\n    // If bytesPerRow or rowsPerImage is invalid, guess a value for the sake of various tests that\n    // don't actually care about the exact value.\n    // (In particular for validation tests that want to test invalid bytesPerRow or rowsPerImage but\n    // need to make sure the total buffer size is still big enough.)\n    if (!validateBytesPerRow({ bytesPerRow, bytesInLastRow, sizeInBlocks })) {\n      bytesPerRow = undefined;\n      valid = false;\n    }\n    if (!validateRowsPerImage({ rowsPerImage, sizeInBlocks })) {\n      rowsPerImage = undefined;\n      valid = false;\n    }\n    // Pick values for cases when (a) bpr/rpi was invalid or (b) they're validly undefined.\n    bytesPerRow ??= align(info.bytesPerBlock * sizeInBlocks.width, 256);\n    rowsPerImage ??= sizeInBlocks.height;\n\n    if (copyExtent.depthOrArrayLayers > 1) {\n      const bytesPerImage = bytesPerRow * rowsPerImage;\n      const bytesBeforeLastImage = bytesPerImage * (copyExtent.depthOrArrayLayers - 1);\n      requiredBytesInCopy += bytesBeforeLastImage;\n    }\n    if (copyExtent.depthOrArrayLayers > 0) {\n      if (sizeInBlocks.height > 1) requiredBytesInCopy += bytesPerRow * (sizeInBlocks.height - 1);\n      if (sizeInBlocks.height > 0) requiredBytesInCopy += bytesInLastRow;\n    }\n  }\n\n  return { minDataSizeOrOverestimate: offset + requiredBytesInCopy, copyValid: valid };\n}\n"],"file":"layout.js"}
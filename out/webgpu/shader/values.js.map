{"version":3,"sources":["../../../src/webgpu/shader/values.ts"],"names":["description","assert","uint32ToFloat32","subnormalF32Examples","result_as_bits","max_mantissa","sign_bits","sign_bit","sign_and_exponent","push","lower_bits","length","toString","map","u","normalF32Examples","result","max_mantissa_as_bits","min_exponent_as_bits","max_exponent_as_bits","e"],"mappings":";AAAA;AACA,GADA,OAAO,MAAMA,WAAW,GAAI,iDAArB,CAEP,SAASC,MAAT,QAAuB,2BAAvB;AACA,SAASC,eAAT,QAAgC,uBAAhC;;AAEA;AACA;AACA;AACA;AACA,OAAO,SAASC,oBAAT,GAA+C;AACpD;AACA,QAAMC,cAAwB,GAAG,EAAjC;;AAEA,QAAMC,YAAY,GAAG,SAArB;AACA,QAAMC,SAA2B,GAAG,CAAC,CAAD,EAAI,WAAJ,CAApC;AACA,OAAK,MAAMC,QAAX,IAAuBD,SAAvB,EAAkC;AAChC;AACA,UAAME,iBAAiB,GAAID,QAA3B;;AAEA;AACAH,IAAAA,cAAc,CAACK,IAAf,CAAoBD,iBAAiB,GAAGH,YAAxC;;AAEA;AACA,SAAK,IAAIK,UAAU,GAAG,CAAtB,EAAyBA,UAAU,IAAIL,YAAvC,EAAqDK,UAAU,KAAK,CAApE,EAAuE;AACrEN,MAAAA,cAAc,CAACK,IAAf,CAAoBD,iBAAiB,GAAGE,UAAxC;AACD;AACF;AACDT,EAAAA,MAAM;AACJG,EAAAA,cAAc,CAACO,MAAf,KAA0B,KAAK,IAAI,EAAT,CADtB;AAEJ,wCAAsCP,cAAc,CAACO,MAAf,CAAsBC,QAAtB,EAFlC,CAAN;;AAIA,SAAOR,cAAc,CAACS,GAAf,CAAmBC,CAAC,IAAIZ,eAAe,CAACY,CAAD,CAAvC,CAAP;AACD;;AAED;AACA;AACA;AACA,OAAO,SAASC,iBAAT,GAA4C;AACjD,QAAMC,MAAgB,GAAG,CAAC,GAAD,EAAM,CAAC,GAAP,CAAzB;;AAEA,QAAMC,oBAAoB,GAAG,SAA7B;AACA,QAAMC,oBAAoB,GAAG,WAA7B;AACA,QAAMC,oBAAoB,GAAG,WAA7B,CALiD,CAKP;AAC1C,QAAMb,SAAS,GAAG,CAAC,CAAD,EAAI,WAAJ,CAAlB;AACA,OAAK,MAAMC,QAAX,IAAuBD,SAAvB,EAAkC;AAChC,SAAK,IAAIc,CAAC,GAAGF,oBAAb,EAAmCE,CAAC,IAAID,oBAAxC,EAA8DC,CAAC,IAAIF,oBAAnE,EAAyF;AACvF,YAAMV,iBAAiB,GAAKD,QAAF,GAAoCa,CAA9D;;AAEA;AACAJ,MAAAA,MAAM,CAACP,IAAP,CAAYP,eAAe,CAACM,iBAAD,CAA3B;AACA;AACAQ,MAAAA,MAAM,CAACP,IAAP,CAAYP,eAAe,CAACM,iBAAiB,GAAGS,oBAArB,CAA3B;;AAEA;AACA,WAAK,IAAIP,UAAU,GAAG,CAAtB,EAAyBA,UAAU,IAAIO,oBAAvC,EAA6DP,UAAU,KAAK,CAA5E,EAA+E;AAC7EM,QAAAA,MAAM,CAACP,IAAP,CAAYP,eAAe,CAACM,iBAAiB,GAAGE,UAArB,CAA3B;AACD;AACF;AACF;AACDT,EAAAA,MAAM;AACJe,EAAAA,MAAM,CAACL,MAAP,KAAkB,IAAI,IAAI,GAAJ,GAAU,EAD5B;AAEJ,qCAAmCK,MAAM,CAACL,MAAP,CAAcC,QAAd,EAF/B,CAAN;;AAIA,SAAOI,MAAP;AACD","sourcesContent":["export const description = `Special and sample values for WGSL scalar types`;\n\nimport { assert } from '../../common/util/util.js';\nimport { uint32ToFloat32 } from '../util/conversion.js';\n\n/** Returns an array of subnormal f32 numbers.\n * Subnnormals are non-zero finite numbers with the minimum representable\n * exponent.\n */\nexport function subnormalF32Examples(): Array<number> {\n  // The results, as uint32 values.\n  const result_as_bits: number[] = [];\n\n  const max_mantissa = 0x7f_ffff;\n  const sign_bits: [number, number] = [0, 0x8000_0000];\n  for (const sign_bit in sign_bits) {\n    // exponent bits must be zero.\n    const sign_and_exponent = (sign_bit as unknown) as number;\n\n    // Set all bits\n    result_as_bits.push(sign_and_exponent | max_mantissa);\n\n    // Set each of the lower bits individually.\n    for (let lower_bits = 1; lower_bits <= max_mantissa; lower_bits <<= 1) {\n      result_as_bits.push(sign_and_exponent | lower_bits);\n    }\n  }\n  assert(\n    result_as_bits.length === 2 * (1 + 23),\n    'subnormal number sample count is ' + result_as_bits.length.toString()\n  );\n  return result_as_bits.map(u => uint32ToFloat32(u));\n}\n\n/** Returns an array of normal f32 numbers.\n * Normal numbers are not: zero, Nan, infinity, subnormal.\n */\nexport function normalF32Examples(): Array<number> {\n  const result: number[] = [1.0, -2.0];\n\n  const max_mantissa_as_bits = 0x7f_ffff;\n  const min_exponent_as_bits = 0x0080_0000;\n  const max_exponent_as_bits = 0x7f00_0000; // Max normal exponent\n  const sign_bits = [0, 0x8000_0000];\n  for (const sign_bit in sign_bits) {\n    for (let e = min_exponent_as_bits; e <= max_exponent_as_bits; e += min_exponent_as_bits) {\n      const sign_and_exponent = ((sign_bit as unknown) as number) | e;\n\n      // Set zero mantissa bits\n      result.push(uint32ToFloat32(sign_and_exponent));\n      // Set all mantissa bits\n      result.push(uint32ToFloat32(sign_and_exponent | max_mantissa_as_bits));\n\n      // Set each of the lower bits individually.\n      for (let lower_bits = 1; lower_bits <= max_mantissa_as_bits; lower_bits <<= 1) {\n        result.push(uint32ToFloat32(sign_and_exponent | lower_bits));\n      }\n    }\n  }\n  assert(\n    result.length === 2 + 2 * 254 * 25,\n    'normal number sample count is ' + result.length.toString()\n  );\n  return result;\n}\n"],"file":"values.js"}
{"version":3,"file":"harness.js","names":["assert","workgroupSizes","dispatchSizes","kMapId","passthrough","f","id","max","wgsl","remap","runStorageVariableTest","t","workgroupSize","dispatchSize","bufferNumElements","initValue","op","expected","extra","length","pipeline","device","createComputePipeline","layout","compute","module","createShaderModule","code","entryPoint","outputBuffer","createBuffer","size","Uint32Array","BYTES_PER_ELEMENT","usage","GPUBufferUsage","STORAGE","COPY_SRC","mappedAtCreation","trackForCleanup","data","getMappedRange","fill","unmap","bindGroup","createBindGroup","getBindGroupLayout","entries","binding","resource","buffer","encoder","createCommandEncoder","pass","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","end","queue","submit","finish","expectGPUBufferValuesEqual","runWorkgroupVariableTest","wgNumElements"],"sources":["../../../../../../../../src/webgpu/shader/execution/expression/call/builtin/atomics/harness.ts"],"sourcesContent":["import { assert } from '../../../../../../../common/util/util.js';\nimport { GPUTest } from '../../../../../../gpu_test.js';\n\nexport const workgroupSizes = [1, 2, 32, 64];\nexport const dispatchSizes = [1, 4, 8, 16];\nexport const kMapId = {\n  passthrough: {\n    f: (id: number, max: number) => id,\n    wgsl: (max: number) => 'fn map_id(id: u32) -> u32 { return id; }',\n  },\n  remap: {\n    f: (id: number, max: number) => (((id >>> 0) * 14957) ^ (((id >>> 0) * 26561) >> 2)) % max,\n    wgsl: (max: number) =>\n      `fn map_id(id: u32) -> u32 { return ((id * 14957) ^ ((id * 26561) >> 2)) % ${max}; }`,\n  },\n};\n\nexport function runStorageVariableTest({\n  t,\n  workgroupSize, // Workgroup X-size\n  dispatchSize, // Dispatch X-size\n  bufferNumElements, // Number of 32-bit elements in output buffer\n  initValue, // 32-bit initial value used to fill output buffer\n  op, // Atomic op source executed by the compute shader, NOTE: 'id' is global_invocation_id.x\n  expected, // Expected values array to compare against output buffer\n  extra, // Optional extra WGSL source\n}: {\n  t: GPUTest;\n  workgroupSize: number;\n  dispatchSize: number;\n  bufferNumElements: number;\n  initValue: number;\n  op: string;\n  expected: Uint32Array;\n  extra?: string;\n}) {\n  assert(expected.length === bufferNumElements, \"'expected' buffer size is incorrect\");\n\n  const wgsl = `\n    @group(0) @binding(0)\n    var<storage, read_write> output: array<atomic<u32>>;\n    \n    @compute @workgroup_size(${workgroupSize})\n    fn main(\n        @builtin(global_invocation_id) global_invocation_id : vec3<u32>,\n        ) {\n      let id = global_invocation_id[0];\n      ${op};\n    }\n    ${extra || ''}\n    `;\n\n  const pipeline = t.device.createComputePipeline({\n    layout: 'auto',\n    compute: {\n      module: t.device.createShaderModule({ code: wgsl }),\n      entryPoint: 'main',\n    },\n  });\n\n  const outputBuffer = t.device.createBuffer({\n    size: bufferNumElements * Uint32Array.BYTES_PER_ELEMENT,\n    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    mappedAtCreation: true,\n  });\n  // Fill with initial value\n  t.trackForCleanup(outputBuffer);\n  const data = new Uint32Array(outputBuffer.getMappedRange());\n  data.fill(initValue);\n  outputBuffer.unmap();\n\n  const bindGroup = t.device.createBindGroup({\n    layout: pipeline.getBindGroupLayout(0),\n    entries: [{ binding: 0, resource: { buffer: outputBuffer } }],\n  });\n\n  // Run the shader.\n  const encoder = t.device.createCommandEncoder();\n  const pass = encoder.beginComputePass();\n  pass.setPipeline(pipeline);\n  pass.setBindGroup(0, bindGroup);\n  pass.dispatchWorkgroups(dispatchSize);\n  pass.end();\n  t.queue.submit([encoder.finish()]);\n\n  t.expectGPUBufferValuesEqual(outputBuffer, expected);\n}\n\nexport function runWorkgroupVariableTest({\n  t,\n  workgroupSize, // Workgroup X-size\n  dispatchSize, // Dispatch X-size\n  wgNumElements, // Number of 32-bit elements in 'wg' array. Output buffer is sized to wgNumElements * dispatchSize.\n  initValue, // 32-bit initial value used to fill 'wg' array\n  op, // Atomic op source executed by the compute shader, NOTE: 'id' is local_invocation_index\n  expected, // Expected values array to compare against output buffer\n  extra, // Optional extra WGSL source\n}: {\n  t: GPUTest;\n  workgroupSize: number;\n  dispatchSize: number;\n  wgNumElements: number;\n  initValue: number;\n  op: string;\n  expected: Uint32Array;\n  extra?: string;\n}) {\n  assert(expected.length === wgNumElements * dispatchSize, \"'expected' buffer size is incorrect\");\n\n  const wgsl = `\n    var<workgroup> wg: array<atomic<u32>, ${wgNumElements}>;\n\n    // Result of each workgroup is written to output[workgroup_id.x]\n    @group(0) @binding(0)\n    var<storage, read_write> output: array<u32, ${wgNumElements * dispatchSize}>;\n    \n    @compute @workgroup_size(${workgroupSize})\n    fn main(\n        @builtin(local_invocation_index) local_invocation_index: u32,\n        @builtin(workgroup_id) workgroup_id : vec3<u32>\n        ) {\n      let id = local_invocation_index;\n\n      // Initialize workgroup array\n      if (local_invocation_index == 0) {\n        for (var i = 0u; i < ${wgNumElements}; i++) {\n          atomicStore(&wg[i], ${initValue});\n        }\n      }\n      workgroupBarrier();\n\n      ${op};\n\n      // Copy results to output buffer\n      workgroupBarrier();\n      if (local_invocation_index == 0) {\n        for (var i = 0u; i < ${wgNumElements}; i++) {\n          output[(workgroup_id.x * ${wgNumElements}) + i] = atomicLoad(&wg[i]);\n        }\n      }\n    }\n    ${extra || ''}\n    `;\n\n  const pipeline = t.device.createComputePipeline({\n    layout: 'auto',\n    compute: {\n      module: t.device.createShaderModule({ code: wgsl }),\n      entryPoint: 'main',\n    },\n  });\n\n  const outputBuffer = t.device.createBuffer({\n    size: wgNumElements * dispatchSize * Uint32Array.BYTES_PER_ELEMENT,\n    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    mappedAtCreation: true,\n  });\n  // Fill with initial value\n  t.trackForCleanup(outputBuffer);\n  const data = new Uint32Array(outputBuffer.getMappedRange());\n  data.fill(initValue);\n  outputBuffer.unmap();\n\n  const bindGroup = t.device.createBindGroup({\n    layout: pipeline.getBindGroupLayout(0),\n    entries: [{ binding: 0, resource: { buffer: outputBuffer } }],\n  });\n\n  // Run the shader.\n  const encoder = t.device.createCommandEncoder();\n  const pass = encoder.beginComputePass();\n  pass.setPipeline(pipeline);\n  pass.setBindGroup(0, bindGroup);\n  pass.dispatchWorkgroups(dispatchSize);\n  pass.end();\n  t.queue.submit([encoder.finish()]);\n\n  t.expectGPUBufferValuesEqual(outputBuffer, expected);\n}\n"],"mappings":"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"}
{"version":3,"file":"expression.js","names":["globalTestConfig","assert","objectEquals","unreachable","compare","anyOf","ScalarType","Scalar","TypeVec","TypeU32","Vector","VectorType","f32","u32","i32","Matrix","MatrixType","F32Interval","cartesianProduct","map2DArray","quantizeToF32","quantizeToI32","quantizeToU32","isComparator","e","Array","toComparator","input","got","allInputSources","valueStride","ty","cols","rows","valueStrides","tys","map","reduce","sum","c","storageType","kind","width","elementType","fromStorage","expr","toStorage","getOrCreate","key","create","existing","get","undefined","value","set","run","t","expressionBuilder","parameterTypes","returnType","cfg","inputSource","compoundStmt","cases","vectorize","packed","packScalarsToVector","casesPerBatch","Math","floor","min","device","limits","maxUniformBufferBindingSize","maxStorageBufferBindingSize","pipelineCache","Map","checkResults","i","length","batchCases","slice","pushErrorScope","checkBatch","submitBatch","push","popErrorScope","then","error","fail","message","Promise","all","outputBufferSize","outputBuffer","createBuffer","size","usage","GPUBufferUsage","COPY_SRC","COPY_DST","STORAGE","pipeline","group","buildPipeline","encoder","createCommandEncoder","pass","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","end","testHeartbeatCallback","queue","submit","finish","checkExpectation","outputData","outputs","read","errs","caseIdx","cmp","expected","matched","join","Error","expectGPUBufferValuesPassCheck","type","Uint8Array","typedLength","ith","v","makeConstCompoundShader","wgslStorageType","wgslOutputs","wgslValues","args","_","wgsl","wgslBody","unrollConstEvalLoops","s","makeConstShader","makeNonConstCompoundShader","wgslInputVar","makeNonConstShader","paramExpr","wgslValueStride","forEach","inputTypes","input_str","param_str","source","module","createShaderModule","code","createComputePipeline","layout","compute","entryPoint","createBindGroup","getBindGroupLayout","entries","binding","resource","buffer","inputSize","inputData","caseStride","caseBase","offset","paramIdx","params","copyTo","inputBuffer","makeBufferWithContents","UNIFORM","vectorWidth","packedCases","packedParameterTypes","p","packedReturnType","clampCaseIdx","idx","packedInputs","inputElements","comparators","packedComparator","gElements","eElements","d","elements","makeUnaryToF32IntervalCase","param","filter","ops","intervals","o","some","isFinite","generateUnaryToF32IntervalCases","makeBinaryToF32IntervalCase","param0","param1","generateBinaryToF32IntervalCases","param0s","param1s","makeTernaryToF32IntervalCase","param2","generateTernaryToF32IntervalCases","param2s","makeVectorToF32IntervalCase","param_f32","generateVectorToF32IntervalCases","makeVectorPairToF32IntervalCase","param0_f32","param1_f32","generateVectorPairToF32IntervalCases","makeVectorToVectorCase","vectors","generateVectorToVectorCases","makeVectorPairToVectorCase","generateVectorPairToVectorCases","makeMatrixToScalarCase","results","generateMatrixToScalarCases","makeMatrixToMatrixCase","m","r","generateMatrixToMatrixCases","makeMatrixPairToMatrixCase","generateMatrixPairToMatrixCases","makeMatrixScalarToMatrixCase","mat","scalar","mat_f32","scalar_f32","generateMatrixScalarToMatrixCases","mats","scalars","makeScalarMatrixToMatrixCase","generateScalarMatrixToMatrixCases","makeMatrixVectorToVectorCase","vec","vec_f32","generateMatrixVectorToVectorCases","vecs","makeVectorMatrixToVectorCase","generateVectorMatrixToVectorCases","makeU32ToVectorCase","trunc","param_u32","every","generateU32ToVectorCases","generateBinaryToI32Cases","params0s","params1s","op","generateBinaryToU32Cases","makeScalarVectorBinaryToVectorCase","vector","quantize","scalarize","result","includes","generateScalarVectorBinaryToVectorCases","makeVectorScalarBinaryToVectorCase","generateVectorScalarBinaryToVectorCases","generateU32VectorBinaryToVectorCases","generateVectorU32BinaryToVectorCases","generateI32VectorBinaryToVectorCases","generateVectorI32BinaryToVectorCases"],"sources":["../../../../../src/webgpu/shader/execution/expression/expression.ts"],"sourcesContent":["import { globalTestConfig } from '../../../../common/framework/test_config.js';\nimport { assert, objectEquals, unreachable } from '../../../../common/util/util.js';\nimport { GPUTest } from '../../../gpu_test.js';\nimport { compare, Comparator, anyOf } from '../../../util/compare.js';\nimport {\n  ScalarType,\n  Scalar,\n  Type,\n  TypeVec,\n  TypeU32,\n  Value,\n  Vector,\n  VectorType,\n  f32,\n  u32,\n  i32,\n  Matrix,\n  MatrixType,\n  ScalarBuilder,\n} from '../../../util/conversion.js';\nimport {\n  BinaryToInterval,\n  F32Interval,\n  MatrixPairToMatrix,\n  MatrixScalarToMatrix,\n  MatrixToMatrix,\n  MatrixToScalar,\n  MatrixVectorToVector,\n  PointToInterval,\n  PointToVector,\n  ScalarMatrixToMatrix,\n  TernaryToInterval,\n  VectorMatrixToVector,\n  VectorPairToInterval,\n  VectorPairToVector,\n  VectorToInterval,\n  VectorToVector,\n} from '../../../util/f32_interval.js';\nimport {\n  cartesianProduct,\n  map2DArray,\n  QuantizeFunc,\n  quantizeToF32,\n  quantizeToI32,\n  quantizeToU32,\n} from '../../../util/math.js';\n\nexport type Expectation = Value | F32Interval | F32Interval[] | F32Interval[][] | Comparator;\n\n/** Is this expectation actually a Comparator */\nfunction isComparator(e: Expectation): boolean {\n  return !(\n    e instanceof F32Interval ||\n    e instanceof Scalar ||\n    e instanceof Vector ||\n    e instanceof Matrix ||\n    e instanceof Array\n  );\n}\n\n/** Helper for converting Values to Comparators */\nexport function toComparator(input: Expectation): Comparator {\n  if (!isComparator(input)) {\n    return got => compare(got, input as Value);\n  }\n  return input as Comparator;\n}\n\n/** Case is a single expression test case. */\nexport type Case = {\n  // The input value(s)\n  input: Value | Array<Value>;\n  // The expected result, or function to check the result\n  expected: Expectation;\n};\n\n/** CaseList is a list of Cases */\nexport type CaseList = Array<Case>;\n\n/** The input value source */\nexport type InputSource =\n  | 'const' // Shader creation time constant values (@const)\n  | 'uniform' // Uniform buffer\n  | 'storage_r' // Read-only storage buffer\n  | 'storage_rw'; // Read-write storage buffer\n\n/** All possible input sources */\nexport const allInputSources: InputSource[] = ['const', 'uniform', 'storage_r', 'storage_rw'];\n\n/** Configuration for running a expression test */\nexport type Config = {\n  // Where the input values are read from\n  inputSource: InputSource;\n  // If the expression is a compound statement\n  compoundStmt?: Boolean;\n  // If defined, scalar test cases will be packed into vectors of the given\n  // width, which must be 2, 3 or 4.\n  // Requires that all parameters of the expression overload are of a scalar\n  // type, and the return type of the expression overload is also a scalar type.\n  // If the number of test cases is not a multiple of the vector width, then the\n  // last scalar value is repeated to fill the last vector value.\n  vectorize?: number;\n};\n\n// Helper for returning the stride for a given Type\nfunction valueStride(ty: Type): number {\n  if (ty instanceof MatrixType) {\n    switch (ty.cols) {\n      case 2:\n        switch (ty.rows) {\n          case 2:\n            return 16;\n          case 3:\n            return 32;\n          case 4:\n            return 32;\n        }\n        break;\n      case 3:\n        switch (ty.rows) {\n          case 2:\n            return 32;\n          case 3:\n            return 64;\n          case 4:\n            return 64;\n        }\n        break;\n      case 4:\n        switch (ty.rows) {\n          case 2:\n            return 32;\n          case 3:\n            return 64;\n          case 4:\n            return 64;\n        }\n        break;\n    }\n    unreachable(\n      `Attempted to get stride length for a matrix with dimensions (${ty.cols}x${ty.rows}), which isn't currently handled`\n    );\n  }\n\n  // Handles scalars and vectors\n  return 16;\n}\n\n// Helper for summing up all of the stride values for an array of Types\nfunction valueStrides(tys: Type[]): number {\n  return tys.map(valueStride).reduce((sum, c) => sum + c);\n}\n\n// Helper for returning the WGSL storage type for the given Type.\nfunction storageType(ty: Type): Type {\n  if (ty instanceof ScalarType) {\n    if (ty.kind === 'bool') {\n      return TypeU32;\n    }\n  }\n  if (ty instanceof VectorType) {\n    return TypeVec(ty.width, storageType(ty.elementType) as ScalarType);\n  }\n  return ty;\n}\n\n// Helper for converting a value of the type 'ty' from the storage type.\nfunction fromStorage(ty: Type, expr: string): string {\n  if (ty instanceof ScalarType) {\n    if (ty.kind === 'bool') {\n      return `${expr} != 0u`;\n    }\n  }\n  if (ty instanceof VectorType) {\n    if (ty.elementType.kind === 'bool') {\n      return `${expr} != vec${ty.width}<u32>(0u)`;\n    }\n  }\n  return expr;\n}\n\n// Helper for converting a value of the type 'ty' to the storage type.\nfunction toStorage(ty: Type, expr: string): string {\n  if (ty instanceof ScalarType) {\n    if (ty.kind === 'bool') {\n      return `select(0u, 1u, ${expr})`;\n    }\n  }\n  if (ty instanceof VectorType) {\n    if (ty.elementType.kind === 'bool') {\n      return `select(vec${ty.width}<u32>(0u), vec${ty.width}<u32>(1u), ${expr})`;\n    }\n  }\n  return expr;\n}\n\n// ExpressionBuilder returns the WGSL used to test an expression.\nexport interface ExpressionBuilder {\n  (values: Array<string>): string;\n}\n\n// A Pipeline is a map of WGSL shader source to a built pipeline\ntype PipelineCache = Map<String, GPUComputePipeline>;\n\n/**\n * Searches for an entry with the given key, adding and returning the result of calling\n * @p create if the entry was not found.\n * @param map the cache map\n * @param key the entry's key\n * @param create the function used to construct a value, if not found in the cache\n * @returns the value, either fetched from the cache, or newly built.\n */\nfunction getOrCreate<K, V>(map: Map<K, V>, key: K, create: () => V) {\n  const existing = map.get(key);\n  if (existing !== undefined) {\n    return existing;\n  }\n  const value = create();\n  map.set(key, value);\n  return value;\n}\n/**\n * Runs the list of expression tests, possibly splitting the tests into multiple\n * dispatches to keep the input data within the buffer binding limits.\n * run() will pack the scalar test cases into smaller set of vectorized tests\n * if `cfg.vectorize` is defined.\n * @param t the GPUTest\n * @param expressionBuilder the expression builder function\n * @param parameterTypes the list of expression parameter types\n * @param returnType the return type for the expression overload\n * @param cfg test configuration values\n * @param cases list of test cases\n */\nexport async function run(\n  t: GPUTest,\n  expressionBuilder: ExpressionBuilder,\n  parameterTypes: Array<Type>,\n  returnType: Type,\n  cfg: Config = { inputSource: 'storage_r', compoundStmt: false },\n  cases: CaseList\n) {\n  // If the 'vectorize' config option was provided, pack the cases into vectors.\n  if (cfg.vectorize !== undefined) {\n    const packed = packScalarsToVector(parameterTypes, returnType, cases, cfg.vectorize);\n    cases = packed.cases;\n    parameterTypes = packed.parameterTypes;\n    returnType = packed.returnType;\n  }\n\n  // The size of the input buffer may exceed the maximum buffer binding size,\n  // so chunk the tests up into batches that fit into the limits. We also split\n  // the cases into smaller batches to help with shader compilation performance.\n  const casesPerBatch = (function () {\n    switch (cfg.inputSource) {\n      case 'const':\n        // Some drivers are slow to optimize shaders with many constant values,\n        // or statements. 32 is an empirically picked number of cases that works\n        // well for most drivers.\n        return 32;\n      case 'uniform':\n        // Some drivers are slow to build pipelines with large uniform buffers.\n        // 2k appears to be a sweet-spot when benchmarking.\n        return Math.floor(\n          Math.min(1024 * 2, t.device.limits.maxUniformBufferBindingSize) /\n            valueStrides(parameterTypes)\n        );\n      case 'storage_r':\n      case 'storage_rw':\n        return Math.floor(\n          t.device.limits.maxStorageBufferBindingSize / valueStrides(parameterTypes)\n        );\n    }\n  })();\n\n  // A cache to hold built shader pipelines.\n  const pipelineCache = new Map<String, GPUComputePipeline>();\n\n  // Submit all the cases in batches, each in a separate error scope.\n  const checkResults: Array<Promise<void>> = [];\n  for (let i = 0; i < cases.length; i += casesPerBatch) {\n    const batchCases = cases.slice(i, Math.min(i + casesPerBatch, cases.length));\n\n    t.device.pushErrorScope('validation');\n\n    const checkBatch = submitBatch(\n      t,\n      expressionBuilder,\n      parameterTypes,\n      returnType,\n      batchCases,\n      cfg.inputSource,\n      cfg.compoundStmt || false,\n      pipelineCache\n    );\n\n    checkResults.push(\n      // Check GPU validation (shader compilation, pipeline creation, etc) before checking the batch results.\n      t.device.popErrorScope().then(error => {\n        if (error === null) {\n          checkBatch();\n        } else {\n          t.fail(error.message);\n        }\n      })\n    );\n  }\n\n  // Check the results\n  await Promise.all(checkResults);\n}\n\n/**\n * Submits the list of expression tests. The input data must fit within the\n * buffer binding limits of the given inputSource.\n * @param t the GPUTest\n * @param expressionBuilder the expression builder function\n * @param parameterTypes the list of expression parameter types\n * @param returnType the return type for the expression overload\n * @param cases list of test cases that fit within the binding limits of the device\n * @param inputSource the source of the input values\n * @param compoundStmt if the expression is a compound statement\n * @param pipelineCache the cache of compute pipelines, shared between batches\n * @returns a function that checks the results are as expected\n */\nfunction submitBatch(\n  t: GPUTest,\n  expressionBuilder: ExpressionBuilder,\n  parameterTypes: Array<Type>,\n  returnType: Type,\n  cases: CaseList,\n  inputSource: InputSource,\n  compoundStmt: Boolean,\n  pipelineCache: PipelineCache\n): () => void {\n  // Construct a buffer to hold the results of the expression tests\n  const outputBufferSize = cases.length * valueStride(returnType);\n  const outputBuffer = t.device.createBuffer({\n    size: outputBufferSize,\n    usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,\n  });\n\n  const [pipeline, group] = buildPipeline(\n    t,\n    expressionBuilder,\n    parameterTypes,\n    returnType,\n    cases,\n    inputSource,\n    compoundStmt,\n    outputBuffer,\n    pipelineCache\n  );\n\n  const encoder = t.device.createCommandEncoder();\n  const pass = encoder.beginComputePass();\n  pass.setPipeline(pipeline);\n  pass.setBindGroup(0, group);\n  pass.dispatchWorkgroups(1);\n  pass.end();\n\n  // Heartbeat to ensure CTS runners know we're alive.\n  globalTestConfig.testHeartbeatCallback();\n\n  t.queue.submit([encoder.finish()]);\n\n  // Return a function that can check the results of the shader\n  return () => {\n    const checkExpectation = (outputData: Uint8Array) => {\n      // Read the outputs from the output buffer\n      const outputs = new Array<Value>(cases.length);\n      for (let i = 0; i < cases.length; i++) {\n        outputs[i] = returnType.read(outputData, i * valueStride(returnType));\n      }\n\n      // The list of expectation failures\n      const errs: string[] = [];\n\n      // For each case...\n      for (let caseIdx = 0; caseIdx < cases.length; caseIdx++) {\n        const c = cases[caseIdx];\n        const got = outputs[caseIdx];\n        const cmp = toComparator(c.expected)(got);\n        if (!cmp.matched) {\n          errs.push(`(${c.input instanceof Array ? c.input.join(', ') : c.input})\n    returned: ${cmp.got}\n    expected: ${cmp.expected}`);\n        }\n      }\n\n      return errs.length > 0 ? new Error(errs.join('\\n\\n')) : undefined;\n    };\n\n    // Heartbeat to ensure CTS runners know we're alive.\n    globalTestConfig.testHeartbeatCallback();\n\n    t.expectGPUBufferValuesPassCheck(outputBuffer, checkExpectation, {\n      type: Uint8Array,\n      typedLength: outputBufferSize,\n    });\n  };\n}\n\n/**\n * @param v either an array of T or a single element of type T\n * @param i the value index to\n * @returns the i'th value of v, if v is an array, otherwise v (i must be 0)\n */\nfunction ith<T>(v: T | T[], i: number): T {\n  if (v instanceof Array) {\n    assert(i < v.length);\n    return v[i];\n  }\n  assert(i === 0);\n  return v;\n}\n\n/**\n * Constructs the shader for a compound const input source\n * @param expressionBuilder the expression builder function\n * @param parameterTypes the list of expression parameter types\n * @param returnType the return type for the expression overload\n * @param cases list of test cases that fit within the binding limits of the device\n * @param inputSource the source of the input values\n * @param wgslStorageType the wgsl storage type\n * @param wgslOutput the wgsl output location\n */\nfunction makeConstCompoundShader(\n  expressionBuilder: ExpressionBuilder,\n  parameterTypes: Array<Type>,\n  returnType: Type,\n  cases: CaseList,\n  wgslStorageType: Type,\n  wgslOutputs: string\n) {\n  const wgslValues = cases.map(c => {\n    const args = parameterTypes.map((_, i) => `(${ith(c.input, i).wgsl()})`);\n    return `  array(${args[0]}, ${args[1]})`;\n  });\n\n  let wgslBody = '';\n  if (globalTestConfig.unrollConstEvalLoops) {\n    wgslBody = wgslValues\n      .map((v, i) => {\n        return `  outputs[${i}].value = values[${i}][0];\n    outputs[${i}].value ${expressionBuilder([])}= values[${i}][1];`;\n      })\n      .join('\\n  ');\n  } else {\n    wgslBody = `  for (var i = 0u; i < ${cases.length}; i++) {\n  outputs[i].value = values[i][0];\n  outputs[i].value ${expressionBuilder([])}= values[i][1];\n}`;\n  }\n\n  // the full WGSL shader source\n  return `\n  ${wgslOutputs}\n\n  const values = array<array<${wgslStorageType}, 2>, ${cases.length}>(\n  ${wgslValues.map(s => `${s}`).join(',\\n  ')}\n  );\n\n  @compute @workgroup_size(1)\n  fn main() {\n  ${wgslBody}\n  }\n  `;\n}\n\n/**\n * Constructs the shader for a const input source\n * @param expressionBuilder the expression builder function\n * @param parameterTypes the list of expression parameter types\n * @param returnType the return type for the expression overload\n * @param cases list of test cases that fit within the binding limits of the device\n * @param inputSource the source of the input values\n * @param wgslStorageType the wgsl storage type\n * @param wgslOutput the wgsl output location\n */\nfunction makeConstShader(\n  expressionBuilder: ExpressionBuilder,\n  parameterTypes: Array<Type>,\n  returnType: Type,\n  cases: CaseList,\n  wgslStorageType: Type,\n  wgslOutputs: string\n) {\n  //////////////////////////////////////////////////////////////////////////\n  // Input values are constant values in the WGSL shader\n  //////////////////////////////////////////////////////////////////////////\n  const wgslValues = cases.map(c => {\n    const args = parameterTypes.map((_, i) => `(${ith(c.input, i).wgsl()})`);\n    return `${toStorage(returnType, expressionBuilder(args))}`;\n  });\n\n  const wgslBody = globalTestConfig.unrollConstEvalLoops\n    ? wgslValues.map((_, i) => `outputs[${i}].value = values[${i}];`).join('\\n  ')\n    : `for (var i = 0u; i < ${cases.length}; i++) {\n  outputs[i].value = values[i];\n}`;\n\n  // the full WGSL shader source\n  return `\n  ${wgslOutputs}\n\n  const values = array<${wgslStorageType}, ${cases.length}>(\n    ${wgslValues.join(',\\n  ')}\n  );\n\n  @compute @workgroup_size(1)\n  fn main() {\n    ${wgslBody}\n  }\n  `;\n}\n\n/**\n * Constructs the shader for a compound non-const input source\n * @param expressionBuilder the expression builder function\n * @param parameterTypes the list of expression parameter types\n * @param returnType the return type for the expression overload\n * @param cases list of test cases that fit within the binding limits of the device\n * @param inputSource the source of the input values\n * @param wgslOutputs the wgsl output location\n */\nfunction makeNonConstCompoundShader(\n  expressionBuilder: ExpressionBuilder,\n  parameterTypes: Array<Type>,\n  returnType: Type,\n  cases: CaseList,\n  inputSource: InputSource,\n  wgslOutputs: string\n) {\n  // input binding var<...> declaration\n  const wgslInputVar = (function () {\n    switch (inputSource) {\n      case 'storage_r':\n        return 'var<storage, read>';\n      case 'storage_rw':\n        return 'var<storage, read_write>';\n      case 'uniform':\n        return 'var<uniform>';\n      default:\n        return '';\n    }\n  })();\n\n  return `\nstruct Input {\n${parameterTypes\n  .map((ty, i) => `  @size(${valueStride(ty)}) param${i} : ${storageType(ty)},`)\n  .join('\\n')}\n};\n\n${wgslOutputs}\n\n@group(0) @binding(1)\n${wgslInputVar} inputs : array<Input, ${cases.length}>;\n\n@compute @workgroup_size(1)\nfn main() {\n  for(var i = 0; i < ${cases.length}; i++) {\n    outputs[i].value = inputs[i].param0;\n    outputs[i].value ${expressionBuilder([])}= inputs[i].param1;\n  }\n}\n`;\n}\n\n/**\n * Constructs the shader for a non-const input source\n * @param expressionBuilder the expression builder function\n * @param parameterTypes the list of expression parameter types\n * @param returnType the return type for the expression overload\n * @param cases list of test cases that fit within the binding limits of the device\n * @param inputSource the source of the input values\n * @param wgslOutputs the wgsl output location\n */\nfunction makeNonConstShader(\n  expressionBuilder: ExpressionBuilder,\n  parameterTypes: Array<Type>,\n  returnType: Type,\n  cases: CaseList,\n  inputSource: InputSource,\n  wgslOutputs: string\n) {\n  // returns the WGSL expression to load the ith parameter of the given type from the input buffer\n  const paramExpr = (ty: Type, i: number) => fromStorage(ty, `inputs[i].param${i}`);\n\n  // resolves to the expression that calls the builtin\n  const expr = toStorage(returnType, expressionBuilder(parameterTypes.map(paramExpr)));\n\n  // input binding var<...> declaration\n  const wgslInputVar = (function () {\n    switch (inputSource) {\n      case 'storage_r':\n        return 'var<storage, read>';\n      case 'storage_rw':\n        return 'var<storage, read_write>';\n      case 'uniform':\n        return 'var<uniform>';\n      default:\n        return '';\n    }\n  })();\n\n  return `\nstruct Input {\n${parameterTypes\n  .map((ty, i) => `  @size(${valueStride(ty)}) param${i} : ${storageType(ty)},`)\n  .join('\\n')}\n};\n\n${wgslOutputs}\n\n@group(0) @binding(1)\n${wgslInputVar} inputs : array<Input, ${cases.length}>;\n\n@compute @workgroup_size(1)\nfn main() {\n  for(var i = 0; i < ${cases.length}; i++) {\n    outputs[i].value = ${expr};\n  }\n}\n`;\n}\n\n/**\n * Constructs and returns a GPUComputePipeline and GPUBindGroup for running a\n * batch of test cases. If a pre-created pipeline can be found in\n * @p pipelineCache, then this may be returned instead of creating a new\n * pipeline.\n * @param t the GPUTest\n * @param expressionBuilder the expression builder function\n * @param parameterTypes the list of expression parameter types\n * @param returnType the return type for the expression overload\n * @param cases list of test cases that fit within the binding limits of the device\n * @param inputSource the source of the input values\n * @param compoundStmt true if the expression is a compound statement\n * @param outputBuffer the buffer that will hold the output values of the tests\n * @param pipelineCache the cache of compute pipelines, shared between batches\n */\nfunction buildPipeline(\n  t: GPUTest,\n  expressionBuilder: ExpressionBuilder,\n  parameterTypes: Array<Type>,\n  returnType: Type,\n  cases: CaseList,\n  inputSource: InputSource,\n  compoundStmt: Boolean,\n  outputBuffer: GPUBuffer,\n  pipelineCache: PipelineCache\n): [GPUComputePipeline, GPUBindGroup] {\n  // wgsl declaration of output buffer and binding\n  const wgslValueStride = valueStride(returnType);\n  const wgslStorageType = storageType(returnType);\n  const wgslOutputs = `\nstruct Output {\n  @size(${wgslValueStride}) value : ${wgslStorageType}\n};\n@group(0) @binding(0) var<storage, read_write> outputs : array<Output, ${cases.length}>;\n`;\n\n  cases.forEach(c => {\n    const inputTypes = c.input instanceof Array ? c.input.map(i => i.type) : [c.input.type];\n    if (!objectEquals(inputTypes, parameterTypes)) {\n      const input_str = `[${inputTypes.join(',')}]`;\n      const param_str = `[${parameterTypes.join(',')}]`;\n      throw new Error(\n        `case input types ${input_str} do not match provided runner parameter types ${param_str}`\n      );\n    }\n  });\n\n  switch (inputSource) {\n    case 'const': {\n      const source = compoundStmt\n        ? makeConstCompoundShader(\n            expressionBuilder,\n            parameterTypes,\n            returnType,\n            cases,\n            wgslStorageType,\n            wgslOutputs\n          )\n        : makeConstShader(\n            expressionBuilder,\n            parameterTypes,\n            returnType,\n            cases,\n            wgslStorageType,\n            wgslOutputs\n          );\n\n      // build the shader module\n      const module = t.device.createShaderModule({ code: source });\n\n      // build the pipeline\n      const pipeline = t.device.createComputePipeline({\n        layout: 'auto',\n        compute: { module, entryPoint: 'main' },\n      });\n\n      // build the bind group\n      const group = t.device.createBindGroup({\n        layout: pipeline.getBindGroupLayout(0),\n        entries: [{ binding: 0, resource: { buffer: outputBuffer } }],\n      });\n\n      return [pipeline, group];\n    }\n\n    case 'uniform':\n    case 'storage_r':\n    case 'storage_rw': {\n      //////////////////////////////////////////////////////////////////////////\n      // Input values come from a uniform or storage buffer\n      //////////////////////////////////////////////////////////////////////////\n\n      // the full WGSL shader source\n      const source = compoundStmt\n        ? makeNonConstCompoundShader(\n            expressionBuilder,\n            parameterTypes,\n            returnType,\n            cases,\n            inputSource,\n            wgslOutputs\n          )\n        : makeNonConstShader(\n            expressionBuilder,\n            parameterTypes,\n            returnType,\n            cases,\n            inputSource,\n            wgslOutputs\n          );\n\n      // size in bytes of the input buffer\n      const inputSize = cases.length * valueStrides(parameterTypes);\n\n      // Holds all the parameter values for all cases\n      const inputData = new Uint8Array(inputSize);\n\n      // Pack all the input parameter values into the inputData buffer\n      {\n        const caseStride = valueStrides(parameterTypes);\n        for (let caseIdx = 0; caseIdx < cases.length; caseIdx++) {\n          const caseBase = caseIdx * caseStride;\n          let offset = caseBase;\n          for (let paramIdx = 0; paramIdx < parameterTypes.length; paramIdx++) {\n            const params = cases[caseIdx].input;\n            if (params instanceof Array) {\n              params[paramIdx].copyTo(inputData, offset);\n            } else {\n              params.copyTo(inputData, offset);\n            }\n            offset += valueStride(parameterTypes[paramIdx]);\n          }\n        }\n      }\n\n      // build the compute pipeline, if the shader hasn't been compiled already.\n      const pipeline = getOrCreate(pipelineCache, source, () => {\n        // build the shader module\n        const module = t.device.createShaderModule({ code: source });\n\n        // build the pipeline\n        return t.device.createComputePipeline({\n          layout: 'auto',\n          compute: { module, entryPoint: 'main' },\n        });\n      });\n\n      // build the input buffer\n      const inputBuffer = t.makeBufferWithContents(\n        inputData,\n        GPUBufferUsage.COPY_SRC |\n          (inputSource === 'uniform' ? GPUBufferUsage.UNIFORM : GPUBufferUsage.STORAGE)\n      );\n\n      // build the bind group\n      const group = t.device.createBindGroup({\n        layout: pipeline.getBindGroupLayout(0),\n        entries: [\n          { binding: 0, resource: { buffer: outputBuffer } },\n          { binding: 1, resource: { buffer: inputBuffer } },\n        ],\n      });\n\n      return [pipeline, group];\n    }\n  }\n}\n\n/**\n * Packs a list of scalar test cases into a smaller list of vector cases.\n * Requires that all parameters of the expression overload are of a scalar type,\n * and the return type of the expression overload is also a scalar type.\n * If `cases.length` is not a multiple of `vectorWidth`, then the last scalar\n * test case value is repeated to fill the vector value.\n */\nfunction packScalarsToVector(\n  parameterTypes: Array<Type>,\n  returnType: Type,\n  cases: CaseList,\n  vectorWidth: number\n): { cases: CaseList; parameterTypes: Array<Type>; returnType: Type } {\n  // Validate that the parameters and return type are all vectorizable\n  for (let i = 0; i < parameterTypes.length; i++) {\n    const ty = parameterTypes[i];\n    if (!(ty instanceof ScalarType)) {\n      throw new Error(\n        `packScalarsToVector() can only be used on scalar parameter types, but the ${i}'th parameter type is a ${ty}'`\n      );\n    }\n  }\n  if (!(returnType instanceof ScalarType)) {\n    throw new Error(\n      `packScalarsToVector() can only be used with a scalar return type, but the return type is a ${returnType}'`\n    );\n  }\n\n  const packedCases: Array<Case> = [];\n  const packedParameterTypes = parameterTypes.map(p => TypeVec(vectorWidth, p as ScalarType));\n  const packedReturnType = new VectorType(vectorWidth, returnType);\n\n  const clampCaseIdx = (idx: number) => Math.min(idx, cases.length - 1);\n\n  let caseIdx = 0;\n  while (caseIdx < cases.length) {\n    // Construct the vectorized inputs from the scalar cases\n    const packedInputs = new Array<Vector>(parameterTypes.length);\n    for (let paramIdx = 0; paramIdx < parameterTypes.length; paramIdx++) {\n      const inputElements = new Array<Scalar>(vectorWidth);\n      for (let i = 0; i < vectorWidth; i++) {\n        const input = cases[clampCaseIdx(caseIdx + i)].input;\n        inputElements[i] = (input instanceof Array ? input[paramIdx] : input) as Scalar;\n      }\n      packedInputs[paramIdx] = new Vector(inputElements);\n    }\n\n    // Gather the comparators for the packed cases\n    const comparators = new Array<Comparator>(vectorWidth);\n    for (let i = 0; i < vectorWidth; i++) {\n      comparators[i] = toComparator(cases[clampCaseIdx(caseIdx + i)].expected);\n    }\n    const packedComparator = (got: Value) => {\n      let matched = true;\n      const gElements = new Array<string>(vectorWidth);\n      const eElements = new Array<string>(vectorWidth);\n      for (let i = 0; i < vectorWidth; i++) {\n        const d = comparators[i]((got as Vector).elements[i]);\n        matched = matched && d.matched;\n        gElements[i] = d.got;\n        eElements[i] = d.expected;\n      }\n      return {\n        matched,\n        got: `${packedReturnType}(${gElements.join(', ')})`,\n        expected: `${packedReturnType}(${eElements.join(', ')})`,\n      };\n    };\n\n    // Append the new packed case\n    packedCases.push({ input: packedInputs, expected: packedComparator });\n    caseIdx += vectorWidth;\n  }\n\n  return {\n    cases: packedCases,\n    parameterTypes: packedParameterTypes,\n    returnType: packedReturnType,\n  };\n}\n\n/**\n * Indicates bounds that acceptance intervals need to be within to avoid inputs\n * being filtered out. This is used for const-eval tests, since going OOB will\n * cause a validation error not an execution error.\n */\nexport type IntervalFilter =\n  | 'f32-only' // Expected to be f32 finite\n  | 'unfiltered'; // No expectations\n\n/**\n * @returns a Case for the param and unary interval generator provided\n * The Case will use use an interval comparator for matching results.\n * @param param the param to pass in\n * @param filter what interval filtering to apply\n * @param ops callbacks that implement generating an acceptance interval for an\n *            unary operation\n */\nfunction makeUnaryToF32IntervalCase(\n  param: number,\n  filter: IntervalFilter,\n  ...ops: PointToInterval[]\n): Case | undefined {\n  param = quantizeToF32(param);\n\n  const intervals = ops.map(o => o(param));\n  if (filter === 'f32-only' && intervals.some(i => !i.isFinite())) {\n    return undefined;\n  }\n  return { input: [f32(param)], expected: anyOf(...intervals) };\n}\n\n/**\n * @returns an array of Cases for operations over a range of inputs\n * @param params array of inputs to try\n * @param filter what interval filtering to apply\n * @param ops callbacks that implement generating an acceptance interval for an\n *            unary operation\n */\nexport function generateUnaryToF32IntervalCases(\n  params: number[],\n  filter: IntervalFilter,\n  ...ops: PointToInterval[]\n): Case[] {\n  return params.reduce((cases, e) => {\n    const c = makeUnaryToF32IntervalCase(e, filter, ...ops);\n    if (c !== undefined) {\n      cases.push(c);\n    }\n    return cases;\n  }, new Array<Case>());\n}\n\n/**\n * @returns a Case for the params and binary interval generator provided\n * The Case will use use an interval comparator for matching results.\n * @param param0 the first param or left hand side to pass in\n * @param param1 the second param or rhs hand side to pass in\n * @param filter what interval filtering to apply\n * @param ops callbacks that implement generating an acceptance interval for a\n *            binary operation\n */\nfunction makeBinaryToF32IntervalCase(\n  param0: number,\n  param1: number,\n  filter: IntervalFilter,\n  ...ops: BinaryToInterval[]\n): Case | undefined {\n  param0 = quantizeToF32(param0);\n  param1 = quantizeToF32(param1);\n\n  const intervals = ops.map(o => o(param0, param1));\n  if (filter === 'f32-only' && intervals.some(i => !i.isFinite())) {\n    return undefined;\n  }\n  return { input: [f32(param0), f32(param1)], expected: anyOf(...intervals) };\n}\n\n/**\n * @returns an array of Cases for operations over a range of inputs\n * @param param0s array of inputs to try for the first param\n * @param param1s array of inputs to try for the second param\n * @param filter what interval filtering to apply\n * @param ops callbacks that implement generating an acceptance interval for a\n *            binary operation\n */\nexport function generateBinaryToF32IntervalCases(\n  param0s: number[],\n  param1s: number[],\n  filter: IntervalFilter,\n  ...ops: BinaryToInterval[]\n): Case[] {\n  return cartesianProduct(param0s, param1s).reduce((cases, e) => {\n    const c = makeBinaryToF32IntervalCase(e[0], e[1], filter, ...ops);\n    if (c !== undefined) {\n      cases.push(c);\n    }\n    return cases;\n  }, new Array<Case>());\n}\n\n/**\n * @returns a Case for the params and ternary interval generator provided\n * The Case will use use an interval comparator for matching results.\n * @param param0 the first param to pass in\n * @param param1 the second param to pass in\n * @param param2 the third param to pass in\n * @param filter what interval filtering to apply\n * @param ops callbacks that implement generating an acceptance interval for a\n *            ternary operation.\n */\nfunction makeTernaryToF32IntervalCase(\n  param0: number,\n  param1: number,\n  param2: number,\n  filter: IntervalFilter,\n  ...ops: TernaryToInterval[]\n): Case | undefined {\n  param0 = quantizeToF32(param0);\n  param1 = quantizeToF32(param1);\n  param2 = quantizeToF32(param2);\n\n  const intervals = ops.map(o => o(param0, param1, param2));\n  if (filter === 'f32-only' && intervals.some(i => !i.isFinite())) {\n    return undefined;\n  }\n  return {\n    input: [f32(param0), f32(param1), f32(param2)],\n    expected: anyOf(...intervals),\n  };\n}\n\n/**\n * @returns an array of Cases for operations over a range of inputs\n * @param param0s array of inputs to try for the first param\n * @param param1s array of inputs to try for the second param\n * @param param2s array of inputs to try for the third param\n * @param filter what interval filtering to apply\n * @param ops callbacks that implement generating an acceptance interval for a\n *            ternary operation.\n */\nexport function generateTernaryToF32IntervalCases(\n  param0s: number[],\n  param1s: number[],\n  param2s: number[],\n  filter: IntervalFilter,\n  ...ops: TernaryToInterval[]\n): Case[] {\n  return cartesianProduct(param0s, param1s, param2s).reduce((cases, e) => {\n    const c = makeTernaryToF32IntervalCase(e[0], e[1], e[2], filter, ...ops);\n    if (c !== undefined) {\n      cases.push(c);\n    }\n    return cases;\n  }, new Array<Case>());\n}\n\n/**\n * @returns a Case for the param and vector interval generator provided\n * @param param the param to pass in\n * @param filter what interval filtering to apply\n * @param ops callbacks that implement generating an acceptance interval for a\n *            vector.\n */\nfunction makeVectorToF32IntervalCase(\n  param: number[],\n  filter: IntervalFilter,\n  ...ops: VectorToInterval[]\n): Case | undefined {\n  param = param.map(quantizeToF32);\n  const param_f32 = param.map(f32);\n\n  const intervals = ops.map(o => o(param));\n  if (filter === 'f32-only' && intervals.some(i => !i.isFinite())) {\n    return undefined;\n  }\n  return {\n    input: [new Vector(param_f32)],\n    expected: anyOf(...intervals),\n  };\n}\n\n/**\n * @returns an array of Cases for operations over a range of inputs\n * @param params array of inputs to try\n * @param filter what interval filtering to apply\n * @param ops callbacks that implement generating an acceptance interval for a\n *            vector.\n */\nexport function generateVectorToF32IntervalCases(\n  params: number[][],\n  filter: IntervalFilter,\n  ...ops: VectorToInterval[]\n): Case[] {\n  return params.reduce((cases, e) => {\n    const c = makeVectorToF32IntervalCase(e, filter, ...ops);\n    if (c !== undefined) {\n      cases.push(c);\n    }\n    return cases;\n  }, new Array<Case>());\n}\n\n/**\n * @returns a Case for the params and vector pair interval generator provided\n * @param param0 the first param to pass in\n * @param param1 the second param to pass in\n * @param filter what interval filtering to apply\n * @param ops callbacks that implement generating an acceptance interval for a\n *            pair of vectors.\n */\nfunction makeVectorPairToF32IntervalCase(\n  param0: number[],\n  param1: number[],\n  filter: IntervalFilter,\n  ...ops: VectorPairToInterval[]\n): Case | undefined {\n  param0 = param0.map(quantizeToF32);\n  param1 = param1.map(quantizeToF32);\n  const param0_f32 = param0.map(f32);\n  const param1_f32 = param1.map(f32);\n\n  const intervals = ops.map(o => o(param0, param1));\n  if (filter === 'f32-only' && intervals.some(i => !i.isFinite())) {\n    return undefined;\n  }\n  return {\n    input: [new Vector(param0_f32), new Vector(param1_f32)],\n    expected: anyOf(...intervals),\n  };\n}\n\n/**\n * @returns an array of Cases for operations over a range of inputs\n * @param param0s array of inputs to try for the first input\n * @param param1s array of inputs to try for the second input\n * @param filter what interval filtering to apply\n * @param ops callbacks that implement generating an acceptance interval for a\n *            pair of vectors.\n */\nexport function generateVectorPairToF32IntervalCases(\n  param0s: number[][],\n  param1s: number[][],\n  filter: IntervalFilter,\n  ...ops: VectorPairToInterval[]\n): Case[] {\n  return cartesianProduct(param0s, param1s).reduce((cases, e) => {\n    const c = makeVectorPairToF32IntervalCase(e[0], e[1], filter, ...ops);\n    if (c !== undefined) {\n      cases.push(c);\n    }\n    return cases;\n  }, new Array<Case>());\n}\n\n/**\n * @returns a Case for the param and vector of intervals generator provided\n * @param param the param to pass in\n * @param filter what interval filtering to apply\n * @param ops callbacks that implement generating an vector of acceptance\n *            intervals for a vector.\n */\nfunction makeVectorToVectorCase(\n  param: number[],\n  filter: IntervalFilter,\n  ...ops: VectorToVector[]\n): Case | undefined {\n  param = param.map(quantizeToF32);\n  const param_f32 = param.map(f32);\n\n  const vectors = ops.map(o => o(param));\n  if (filter === 'f32-only' && vectors.some(v => v.some(e => !e.isFinite()))) {\n    return undefined;\n  }\n  return {\n    input: [new Vector(param_f32)],\n    expected: anyOf(...vectors),\n  };\n}\n\n/**\n * @returns an array of Cases for operations over a range of inputs\n * @param params array of inputs to try\n * @param filter what interval filtering to apply\n * @param ops callbacks that implement generating an vector of acceptance\n *            intervals for a vector.\n */\nexport function generateVectorToVectorCases(\n  params: number[][],\n  filter: IntervalFilter,\n  ...ops: VectorToVector[]\n): Case[] {\n  return params.reduce((cases, e) => {\n    const c = makeVectorToVectorCase(e, filter, ...ops);\n    if (c !== undefined) {\n      cases.push(c);\n    }\n    return cases;\n  }, new Array<Case>());\n}\n\n/**\n * @returns a Case for the params and vector of intervals generator provided\n * @param param0 the first param to pass in\n * @param param1 the second param to pass in\n * @param filter what interval filtering to apply\n * @param ops callbacks that implement generating an vector of acceptance\n *            intervals for a pair of vectors.\n */\nfunction makeVectorPairToVectorCase(\n  param0: number[],\n  param1: number[],\n  filter: IntervalFilter,\n  ...ops: VectorPairToVector[]\n): Case | undefined {\n  param0 = param0.map(quantizeToF32);\n  param1 = param1.map(quantizeToF32);\n  const param0_f32 = param0.map(f32);\n  const param1_f32 = param1.map(f32);\n\n  const vectors = ops.map(o => o(param0, param1));\n  if (filter === 'f32-only' && vectors.some(v => v.some(e => !e.isFinite()))) {\n    return undefined;\n  }\n  return {\n    input: [new Vector(param0_f32), new Vector(param1_f32)],\n    expected: anyOf(...vectors),\n  };\n}\n\n/**\n * @returns an array of Cases for operations over a range of inputs\n * @param param0s array of inputs to try for the first input\n * @param param1s array of inputs to try for the second input\n * @param filter what interval filtering to apply\n * @param ops callbacks that implement generating an vector of acceptance\n *            intervals for a pair of vectors.\n */\nexport function generateVectorPairToVectorCases(\n  param0s: number[][],\n  param1s: number[][],\n  filter: IntervalFilter,\n  ...ops: VectorPairToVector[]\n): Case[] {\n  return cartesianProduct(param0s, param1s).reduce((cases, e) => {\n    const c = makeVectorPairToVectorCase(e[0], e[1], filter, ...ops);\n    if (c !== undefined) {\n      cases.push(c);\n    }\n    return cases;\n  }, new Array<Case>());\n}\n\n/**\n * @returns a Case for the param and an array of interval generators provided\n * @param param the param to pass in\n * @param filter what interval filtering to apply\n * @param ops callbacks that implement generating an acceptance  interval for a\n *            matrix.\n */\nfunction makeMatrixToScalarCase(\n  param: number[][],\n  filter: IntervalFilter,\n  ...ops: MatrixToScalar[]\n): Case | undefined {\n  param = map2DArray(param, quantizeToF32);\n  const param_f32 = map2DArray(param, f32);\n\n  const results = ops.map(o => o(param));\n  if (filter === 'f32-only' && results.some(e => !e.isFinite())) {\n    return undefined;\n  }\n\n  return {\n    input: [new Matrix(param_f32)],\n    expected: anyOf(...results),\n  };\n}\n\n/**\n * @returns an array of Cases for operations over a range of inputs\n * @param params array of inputs to try\n * @param filter what interval filtering to apply\n * @param ops callbacks that implement generating an acceptance interval for a\n *            matrix.\n */\nexport function generateMatrixToScalarCases(\n  params: number[][][],\n  filter: IntervalFilter,\n  ...ops: MatrixToScalar[]\n): Case[] {\n  return params.reduce((cases, e) => {\n    const c = makeMatrixToScalarCase(e, filter, ...ops);\n    if (c !== undefined) {\n      cases.push(c);\n    }\n    return cases;\n  }, new Array<Case>());\n}\n\n/**\n * @returns a Case for the param and an array of interval generators provided\n * @param param the param to pass in\n * @param filter what interval filtering to apply\n * @param ops callbacks that implement generating a matrix of acceptance\n *            intervals for a matrix.\n */\nfunction makeMatrixToMatrixCase(\n  param: number[][],\n  filter: IntervalFilter,\n  ...ops: MatrixToMatrix[]\n): Case | undefined {\n  param = map2DArray(param, quantizeToF32);\n  const param_f32 = map2DArray(param, f32);\n\n  const results = ops.map(o => o(param));\n  if (filter === 'f32-only' && results.some(m => m.some(c => c.some(r => !r.isFinite())))) {\n    return undefined;\n  }\n\n  return {\n    input: [new Matrix(param_f32)],\n    expected: anyOf(...results),\n  };\n}\n\n/**\n * @returns an array of Cases for operations over a range of inputs\n * @param params array of inputs to try\n * @param filter what interval filtering to apply\n * @param ops callbacks that implement generating a matrix of acceptance\n *            intervals for a matrix.\n */\nexport function generateMatrixToMatrixCases(\n  params: number[][][],\n  filter: IntervalFilter,\n  ...ops: MatrixToMatrix[]\n): Case[] {\n  return params.reduce((cases, e) => {\n    const c = makeMatrixToMatrixCase(e, filter, ...ops);\n    if (c !== undefined) {\n      cases.push(c);\n    }\n    return cases;\n  }, new Array<Case>());\n}\n\n/**\n * @returns a Case for the params and matrix of intervals generator provided\n * @param param0 the first param to pass in\n * @param param1 the second param to pass in\n * @param filter what interval filtering to apply\n * @param ops callbacks that implement generating an matrix of acceptance\n *            intervals for a pair of matrices.\n */\nfunction makeMatrixPairToMatrixCase(\n  param0: number[][],\n  param1: number[][],\n  filter: IntervalFilter,\n  ...ops: MatrixPairToMatrix[]\n): Case | undefined {\n  param0 = map2DArray(param0, quantizeToF32);\n  param1 = map2DArray(param1, quantizeToF32);\n  const param0_f32 = map2DArray(param0, f32);\n  const param1_f32 = map2DArray(param1, f32);\n\n  const results = ops.map(o => o(param0, param1));\n  if (filter === 'f32-only' && results.some(m => m.some(c => c.some(r => !r.isFinite())))) {\n    return undefined;\n  }\n  return {\n    input: [new Matrix(param0_f32), new Matrix(param1_f32)],\n    expected: anyOf(...results),\n  };\n}\n\n/**\n * @returns an array of Cases for operations over a range of inputs\n * @param param0s array of inputs to try for the first input\n * @param param1s array of inputs to try for the second input\n * @param filter what interval filtering to apply\n * @param ops callbacks that implement generating an matrix of acceptance\n *            intervals for a pair of matrices.\n */\nexport function generateMatrixPairToMatrixCases(\n  param0s: number[][][],\n  param1s: number[][][],\n  filter: IntervalFilter,\n  ...ops: MatrixPairToMatrix[]\n): Case[] {\n  return cartesianProduct(param0s, param1s).reduce((cases, e) => {\n    const c = makeMatrixPairToMatrixCase(e[0], e[1], filter, ...ops);\n    if (c !== undefined) {\n      cases.push(c);\n    }\n    return cases;\n  }, new Array<Case>());\n}\n\n/**\n * @returns a Case for the params and matrix of intervals generator provided\n * @param mat the matrix param to pass in\n * @param scalar the scalar to pass in\n * @param filter what interval filtering to apply\n * @param ops callbacks that implement generating an matrix of acceptance\n *            intervals for a pair of matrices.\n */\nfunction makeMatrixScalarToMatrixCase(\n  mat: number[][],\n  scalar: number,\n  filter: IntervalFilter,\n  ...ops: MatrixScalarToMatrix[]\n): Case | undefined {\n  mat = map2DArray(mat, quantizeToF32);\n  scalar = quantizeToF32(scalar);\n  const mat_f32 = map2DArray(mat, f32);\n  const scalar_f32 = f32(scalar);\n\n  const results = ops.map(o => o(mat, scalar));\n  if (filter === 'f32-only' && results.some(m => m.some(c => c.some(r => !r.isFinite())))) {\n    return undefined;\n  }\n  return {\n    input: [new Matrix(mat_f32), scalar_f32],\n    expected: anyOf(...results),\n  };\n}\n\n/**\n * @returns an array of Cases for operations over a range of inputs\n * @param mats array of inputs to try for the matrix input\n * @param scalars array of inputs to try for the scalar input\n * @param filter what interval filtering to apply\n * @param ops callbacks that implement generating an matrix of acceptance\n *            intervals for a pair of matrices.\n */\nexport function generateMatrixScalarToMatrixCases(\n  mats: number[][][],\n  scalars: number[],\n  filter: IntervalFilter,\n  ...ops: MatrixScalarToMatrix[]\n): Case[] {\n  // Cannot use cartesianProduct here, due to heterogeneous types\n  const cases: Case[] = [];\n  mats.forEach(mat => {\n    scalars.forEach(scalar => {\n      const c = makeMatrixScalarToMatrixCase(mat, scalar, filter, ...ops);\n      if (c !== undefined) {\n        cases.push(c);\n      }\n    });\n  });\n  return cases;\n}\n\n/**\n * @returns a Case for the params and matrix of intervals generator provided\n * @param mat the matrix param to pass in\n * @param scalar the scalar to pass in\n * @param filter what interval filtering to apply\n * @param ops callbacks that implement generating an matrix of acceptance\n *            intervals for a pair of matrices.\n */\nfunction makeScalarMatrixToMatrixCase(\n  scalar: number,\n  mat: number[][],\n  filter: IntervalFilter,\n  ...ops: ScalarMatrixToMatrix[]\n): Case | undefined {\n  mat = map2DArray(mat, quantizeToF32);\n  scalar = quantizeToF32(scalar);\n  const mat_f32 = map2DArray(mat, f32);\n  const scalar_f32 = f32(scalar);\n\n  const results = ops.map(o => o(scalar, mat));\n  if (filter === 'f32-only' && results.some(m => m.some(c => c.some(r => !r.isFinite())))) {\n    return undefined;\n  }\n  return {\n    input: [scalar_f32, new Matrix(mat_f32)],\n    expected: anyOf(...results),\n  };\n}\n\n/**\n * @returns an array of Cases for operations over a range of inputs\n * @param scalars array of inputs to try for the scalar input\n * @param mats array of inputs to try for the matrix input\n * @param filter what interval filtering to apply\n * @param ops callbacks that implement generating an matrix of acceptance\n *            intervals for a pair of matrices.\n */\nexport function generateScalarMatrixToMatrixCases(\n  scalars: number[],\n  mats: number[][][],\n  filter: IntervalFilter,\n  ...ops: ScalarMatrixToMatrix[]\n): Case[] {\n  // Cannot use cartesianProduct here, due to heterogeneous types\n  const cases: Case[] = [];\n  mats.forEach(mat => {\n    scalars.forEach(scalar => {\n      const c = makeScalarMatrixToMatrixCase(scalar, mat, filter, ...ops);\n      if (c !== undefined) {\n        cases.push(c);\n      }\n    });\n  });\n  return cases;\n}\n\n/**\n * @returns a Case for the params and the vector of intervals generator provided\n * @param mat the matrix param to pass in\n * @param vec the vector to pass in\n * @param filter what interval filtering to apply\n * @param ops callbacks that implement generating a vector of acceptance\n *            intervals for a matrix and a vector.\n */\nfunction makeMatrixVectorToVectorCase(\n  mat: number[][],\n  vec: number[],\n  filter: IntervalFilter,\n  ...ops: MatrixVectorToVector[]\n): Case | undefined {\n  mat = map2DArray(mat, quantizeToF32);\n  vec = vec.map(quantizeToF32);\n  const mat_f32 = map2DArray(mat, f32);\n  const vec_f32 = vec.map(f32);\n\n  const results = ops.map(o => o(mat, vec));\n  if (filter === 'f32-only' && results.some(v => v.some(e => !e.isFinite()))) {\n    return undefined;\n  }\n  return {\n    input: [new Matrix(mat_f32), new Vector(vec_f32)],\n    expected: anyOf(...results),\n  };\n}\n\n/**\n * @returns an array of Cases for operations over a range of inputs\n * @param mats array of inputs to try for the matrix input\n * @param vecs array of inputs to try for the vector input\n * @param filter what interval filtering to apply\n * @param ops callbacks that implement generating a vector of acceptance\n *            intervals for a matrix and a vector.\n */\nexport function generateMatrixVectorToVectorCases(\n  mats: number[][][],\n  vecs: number[][],\n  filter: IntervalFilter,\n  ...ops: MatrixVectorToVector[]\n): Case[] {\n  // Cannot use cartesianProduct here, due to heterogeneous types\n  const cases: Case[] = [];\n  mats.forEach(mat => {\n    vecs.forEach(vec => {\n      const c = makeMatrixVectorToVectorCase(mat, vec, filter, ...ops);\n      if (c !== undefined) {\n        cases.push(c);\n      }\n    });\n  });\n  return cases;\n}\n\n/**\n * @returns a Case for the params and the vector of intervals generator provided\n * @param vec the vector to pass in\n * @param mat the matrix param to pass in\n * @param filter what interval filtering to apply\n * @param ops callbacks that implement generating a vector of acceptance\n *            intervals for a vector and a matrix.\n */\nfunction makeVectorMatrixToVectorCase(\n  vec: number[],\n  mat: number[][],\n  filter: IntervalFilter,\n  ...ops: VectorMatrixToVector[]\n): Case | undefined {\n  vec = vec.map(quantizeToF32);\n  mat = map2DArray(mat, quantizeToF32);\n  const vec_f32 = vec.map(f32);\n  const mat_f32 = map2DArray(mat, f32);\n\n  const results = ops.map(o => o(vec, mat));\n  if (filter === 'f32-only' && results.some(v => v.some(e => !e.isFinite()))) {\n    return undefined;\n  }\n  return {\n    input: [new Vector(vec_f32), new Matrix(mat_f32)],\n    expected: anyOf(...results),\n  };\n}\n\n/**\n * @returns an array of Cases for operations over a range of inputs\n * @param vecs array of inputs to try for the vector input\n * @param mats array of inputs to try for the matrix input\n * @param filter what interval filtering to apply\n * @param ops callbacks that implement generating a vector of acceptance\n *            intervals for a vector and a matrix.\n */\nexport function generateVectorMatrixToVectorCases(\n  vecs: number[][],\n  mats: number[][][],\n  filter: IntervalFilter,\n  ...ops: VectorMatrixToVector[]\n): Case[] {\n  // Cannot use cartesianProduct here, due to heterogeneous types\n  const cases: Case[] = [];\n  vecs.forEach(vec => {\n    mats.forEach(mat => {\n      const c = makeVectorMatrixToVectorCase(vec, mat, filter, ...ops);\n      if (c !== undefined) {\n        cases.push(c);\n      }\n    });\n  });\n  return cases;\n}\n\n/**\n * @returns a Case for the param and vector of intervals generator provided\n * The input is treated as an unsigned int.\n * @param param the param to pass in\n * @param filter what interval filtering to apply\n * @param ops callbacks that implement generating an acceptance\n *            interval for an unsigned int.\n */\nfunction makeU32ToVectorCase(\n  param: number,\n  filter: IntervalFilter,\n  ...ops: PointToVector[]\n): Case | undefined {\n  param = Math.trunc(param);\n  const param_u32 = u32(param);\n\n  const vectors = ops.map(o => o(param));\n  if (filter === 'f32-only' && vectors.some(v => !v.every(e => e.isFinite()))) {\n    return undefined;\n  }\n  return {\n    input: param_u32,\n    expected: anyOf(...vectors),\n  };\n}\n\n/**\n * @returns an array of Cases for operations over a range of inputs\n * The input is treated as an unsigned int.\n * @param params array of inputs to try\n * @param filter what interval filtering to apply\n * @param ops callbacks that implement generating an acceptance\n *            interval for an unsigned int.\n */\nexport function generateU32ToVectorCases(\n  params: number[],\n  filter: IntervalFilter,\n  ...ops: PointToVector[]\n): Case[] {\n  return params.reduce((cases, e) => {\n    const c = makeU32ToVectorCase(e, filter, ...ops);\n    if (c !== undefined) {\n      cases.push(c);\n    }\n    return cases;\n  }, new Array<Case>());\n}\n\n/**\n * A function that performs a binary operation on x and y, and returns the expected\n * result.\n */\nexport interface BinaryOp {\n  (x: number, y: number): number | undefined;\n}\n\n/**\n * @returns an array of Cases for operations over a range of inputs\n * @param param0s array of inputs to try for the first param\n * @param param1s array of inputs to try for the second param\n * @param op callback called on each pair of inputs to produce each case\n */\nexport function generateBinaryToI32Cases(params0s: number[], params1s: number[], op: BinaryOp) {\n  return cartesianProduct(params0s, params1s).reduce((cases, e) => {\n    const expected = op(e[0], e[1]);\n    if (expected !== undefined) {\n      cases.push({ input: [i32(e[0]), i32(e[1])], expected: i32(expected) });\n    }\n    return cases;\n  }, new Array<Case>());\n}\n\n/**\n * @returns an array of Cases for operations over a range of inputs\n * @param param0s array of inputs to try for the first param\n * @param param1s array of inputs to try for the second param\n * @param op callback called on each pair of inputs to produce each case\n */\nexport function generateBinaryToU32Cases(params0s: number[], params1s: number[], op: BinaryOp) {\n  return cartesianProduct(params0s, params1s).reduce((cases, e) => {\n    const expected = op(e[0], e[1]);\n    if (expected !== undefined) {\n      cases.push({ input: [u32(e[0]), u32(e[1])], expected: u32(expected) });\n    }\n    return cases;\n  }, new Array<Case>());\n}\n\n/**\n * @returns a Case for the input params with op applied\n * @param scalar scalar param\n * @param vector vector param (2, 3, or 4 elements)\n * @param op the op to apply to scalar and vector\n * @param quantize function to quantize all values in vectors and scalars\n * @param scalarize function to convert numbers to Scalars\n */\nfunction makeScalarVectorBinaryToVectorCase(\n  scalar: number,\n  vector: number[],\n  op: BinaryOp,\n  quantize: QuantizeFunc,\n  scalarize: ScalarBuilder\n): Case | undefined {\n  scalar = quantize(scalar);\n  vector = vector.map(quantize);\n  const result = vector.map(v => op(scalar, v));\n  if (result.includes(undefined)) {\n    return undefined;\n  }\n  return {\n    input: [scalarize(scalar), new Vector(vector.map(scalarize))],\n    expected: new Vector((result as number[]).map(scalarize)),\n  };\n}\n\n/**\n * @returns array of Case for the input params with op applied\n * @param scalars array of scalar params\n * @param vectors array of vector params (2, 3, or 4 elements)\n * @param op the op to apply to each pair of scalar and vector\n * @param quantize function to quantize all values in vectors and scalars\n * @param scalarize function to convert numbers to Scalars\n */\nfunction generateScalarVectorBinaryToVectorCases(\n  scalars: number[],\n  vectors: number[][],\n  op: BinaryOp,\n  quantize: QuantizeFunc,\n  scalarize: ScalarBuilder\n): Case[] {\n  const cases = new Array<Case>();\n  scalars.forEach(s => {\n    vectors.forEach(v => {\n      const c = makeScalarVectorBinaryToVectorCase(s, v, op, quantize, scalarize);\n      if (c !== undefined) {\n        cases.push(c);\n      }\n    });\n  });\n  return cases;\n}\n\n/**\n * @returns a Case for the input params with op applied\n * @param vector vector param (2, 3, or 4 elements)\n * @param scalar scalar param\n * @param op the op to apply to vector and scalar\n * @param quantize function to quantize all values in vectors and scalars\n * @param scalarize function to convert numbers to Scalars\n */\nfunction makeVectorScalarBinaryToVectorCase(\n  vector: number[],\n  scalar: number,\n  op: BinaryOp,\n  quantize: QuantizeFunc,\n  scalarize: ScalarBuilder\n): Case | undefined {\n  vector = vector.map(quantize);\n  scalar = quantize(scalar);\n  const result = vector.map(v => op(v, scalar));\n  if (result.includes(undefined)) {\n    return undefined;\n  }\n  return {\n    input: [new Vector(vector.map(scalarize)), scalarize(scalar)],\n    expected: new Vector((result as number[]).map(scalarize)),\n  };\n}\n\n/**\n * @returns array of Case for the input params with op applied\n * @param vectors array of vector params (2, 3, or 4 elements)\n * @param scalars array of scalar params\n * @param op the op to apply to each pair of vector and scalar\n * @param quantize function to quantize all values in vectors and scalars\n * @param scalarize function to convert numbers to Scalars\n */\nfunction generateVectorScalarBinaryToVectorCases(\n  vectors: number[][],\n  scalars: number[],\n  op: BinaryOp,\n  quantize: QuantizeFunc,\n  scalarize: ScalarBuilder\n): Case[] {\n  const cases = new Array<Case>();\n  scalars.forEach(s => {\n    vectors.forEach(v => {\n      const c = makeVectorScalarBinaryToVectorCase(v, s, op, quantize, scalarize);\n      if (c !== undefined) {\n        cases.push(c);\n      }\n    });\n  });\n  return cases;\n}\n\n/**\n * @returns array of Case for the input params with op applied\n * @param scalars array of scalar params\n * @param vectors array of vector params (2, 3, or 4 elements)\n * @param op he op to apply to each pair of scalar and vector\n */\nexport function generateU32VectorBinaryToVectorCases(\n  scalars: number[],\n  vectors: number[][],\n  op: BinaryOp\n): Case[] {\n  return generateScalarVectorBinaryToVectorCases(scalars, vectors, op, quantizeToU32, u32);\n}\n\n/**\n * @returns array of Case for the input params with op applied\n * @param vectors array of vector params (2, 3, or 4 elements)\n * @param scalars array of scalar params\n * @param op he op to apply to each pair of vector and scalar\n */\nexport function generateVectorU32BinaryToVectorCases(\n  vectors: number[][],\n  scalars: number[],\n  op: BinaryOp\n): Case[] {\n  return generateVectorScalarBinaryToVectorCases(vectors, scalars, op, quantizeToU32, u32);\n}\n\n/**\n * @returns array of Case for the input params with op applied\n * @param scalars array of scalar params\n * @param vectors array of vector params (2, 3, or 4 elements)\n * @param op he op to apply to each pair of scalar and vector\n */\nexport function generateI32VectorBinaryToVectorCases(\n  scalars: number[],\n  vectors: number[][],\n  op: BinaryOp\n): Case[] {\n  return generateScalarVectorBinaryToVectorCases(scalars, vectors, op, quantizeToI32, i32);\n}\n\n/**\n * @returns array of Case for the input params with op applied\n * @param vectors array of vector params (2, 3, or 4 elements)\n * @param scalars array of scalar params\n * @param op he op to apply to each pair of vector and scalar\n */\nexport function generateVectorI32BinaryToVectorCases(\n  vectors: number[][],\n  scalars: number[],\n  op: BinaryOp\n): Case[] {\n  return generateVectorScalarBinaryToVectorCases(vectors, scalars, op, quantizeToI32, i32);\n}\n"],"mappings":"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"}
{"version":3,"sources":["../../../../../src/webgpu/shader/execution/expression/expression.ts"],"names":["assert","compare","anyOf","intervalComparator","ScalarType","TypeVec","TypeU32","Vector","VectorType","f32","f64","flushSubnormalNumber","isSubnormalNumber","quantizeToF32","toComparator","input","type","undefined","got","cmpFloats","allInputSources","storageType","ty","kind","width","elementType","fromStorage","expr","toStorage","kValueStride","run","t","expressionBuilder","parameterTypes","returnType","cfg","inputSource","cases","expect","vectorize","packed","packScalarsToVector","casesPerBatch","Math","floor","device","limits","maxUniformBufferBindingSize","length","maxStorageBufferBindingSize","checkResults","i","batchCases","slice","min","checkResult","submitBatch","push","forEach","f","outputBufferSize","outputBuffer","createBuffer","size","usage","GPUBufferUsage","COPY_SRC","COPY_DST","STORAGE","pipeline","group","buildPipeline","encoder","createCommandEncoder","pass","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","end","queue","submit","finish","checkExpectation","outputData","outputs","Array","read","errs","caseIdx","c","cmp","expected","matched","join","Error","expectGPUBufferValuesPassCheck","Uint8Array","typedLength","ith","v","wgslOutputs","wgslCases","map","args","_","wgsl","source","module","createShaderModule","code","createComputePipeline","layout","compute","entryPoint","createBindGroup","getBindGroupLayout","entries","binding","resource","buffer","paramExpr","wgslInputVar","inputSize","inputData","caseStride","caseBase","paramIdx","offset","params","copyTo","inputBuffer","makeBufferWithContents","UNIFORM","vectorWidth","packedCases","packedParameterTypes","p","packedReturnType","clampCaseIdx","idx","packedInputs","inputElements","comparators","packedComparator","gElements","eElements","d","elements","calculateFlushedResults","value","makeUnaryF32Case","param","op","f32_param","is_param_subnormal","makeBinaryF32Case","param0","param1","skip_param1_zero_flush","f32_param0","f32_param1","is_param0_subnormal","is_param1_subnormal","makeUnaryF32IntervalCase","ops","intervals","makeBinaryF32IntervalCase","makeTernaryF32IntervalCase","param2"],"mappings":"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","sourcesContent":["import { assert } from '../../../../common/util/util.js';\nimport { GPUTest } from '../../../gpu_test.js';\nimport {\n  compare,\n  Comparator,\n  FloatMatch,\n  anyOf,\n  intervalComparator,\n} from '../../../util/compare.js';\nimport {\n  ScalarType,\n  Scalar,\n  Type,\n  TypeVec,\n  TypeU32,\n  Value,\n  Vector,\n  VectorType,\n  f32,\n  f64,\n} from '../../../util/conversion.js';\nimport {\n  BinaryToInterval,\n  F32Interval,\n  PointToInterval,\n  TernaryToInterval,\n} from '../../../util/f32_interval.js';\nimport { flushSubnormalNumber, isSubnormalNumber, quantizeToF32 } from '../../../util/math.js';\n\n// Helper for converting Values to Comparators.\nfunction toComparator(input: Value | Comparator): Comparator {\n  if ((input as Value).type !== undefined) {\n    return (got, cmpFloats) => compare(got, input as Value, cmpFloats);\n  }\n  return input as Comparator;\n}\n\n/** Case is a single expression test case. */\nexport type Case = {\n  // The input value(s)\n  input: Value | Array<Value>;\n  // The expected value, or comparator\n  expected: Value | Comparator;\n};\n\n/** CaseList is a list of Cases */\nexport type CaseList = Array<Case>;\n\n/** The input value source */\nexport type InputSource =\n  | 'const' // Shader creation time constant values (@const)\n  | 'uniform' // Uniform buffer\n  | 'storage_r' // Read-only storage buffer\n  | 'storage_rw'; // Read-write storage buffer\n\n/** All possible input sources */\nexport const allInputSources: InputSource[] = ['const', 'uniform', 'storage_r', 'storage_rw'];\n\n/** Configuration for running a expression test */\nexport type Config = {\n  // Where the input values are read from\n  inputSource: InputSource;\n  // If defined, scalar test cases will be packed into vectors of the given\n  // width, which must be 2, 3 or 4.\n  // Requires that all parameters of the expression overload are of a scalar\n  // type, and the return type of the expression overload is also a scalar type.\n  // If the number of test cases is not a multiple of the vector width, then the\n  // last scalar value is repeated to fill the last vector value.\n  vectorize?: number;\n  // The FloatMatch to use when comparing floating point numbers.\n  // If undefined, floating point numbers must match exactly.\n  cmpFloats?: FloatMatch;\n};\n\n// Helper for returning the WGSL storage type for the given Type.\nfunction storageType(ty: Type): Type {\n  if (ty instanceof ScalarType) {\n    if (ty.kind === 'bool') {\n      return TypeU32;\n    }\n  }\n  if (ty instanceof VectorType) {\n    return TypeVec(ty.width, storageType(ty.elementType) as ScalarType);\n  }\n  return ty;\n}\n\n// Helper for converting a value of the type 'ty' from the storage type.\nfunction fromStorage(ty: Type, expr: string): string {\n  if (ty instanceof ScalarType) {\n    if (ty.kind === 'bool') {\n      return `${expr} != 0u`;\n    }\n  }\n  if (ty instanceof VectorType) {\n    if (ty.elementType.kind === 'bool') {\n      return `${expr} != vec${ty.width}<u32>(0u)`;\n    }\n  }\n  return expr;\n}\n\n// Helper for converting a value of the type 'ty' to the storage type.\nfunction toStorage(ty: Type, expr: string): string {\n  if (ty instanceof ScalarType) {\n    if (ty.kind === 'bool') {\n      return `select(0u, 1u, ${expr})`;\n    }\n  }\n  if (ty instanceof VectorType) {\n    if (ty.elementType.kind === 'bool') {\n      return `select(vec${ty.width}<u32>(0u), vec${ty.width}<u32>(1u), ${expr})`;\n    }\n  }\n  return expr;\n}\n\n// Currently all values are packed into buffers of 16 byte strides\nconst kValueStride = 16;\n\n// ExpressionBuilder returns the WGSL used to test an expression.\nexport interface ExpressionBuilder {\n  (values: Array<string>): string;\n}\n\n/**\n * Runs the list of expression tests, possibly splitting the tests into multiple\n * dispatches to keep the input data within the buffer binding limits.\n * run() will pack the scalar test cases into smaller set of vectorized tests\n * if `cfg.vectorize` is defined.\n * @param t the GPUTest\n * @param expressionBuilder the expression builder function\n * @param parameterTypes the list of expression parameter types\n * @param returnType the return type for the expression overload\n * @param cfg test configuration values\n * @param cases list of test cases\n */\nexport function run(\n  t: GPUTest,\n  expressionBuilder: ExpressionBuilder,\n  parameterTypes: Array<Type>,\n  returnType: Type,\n  cfg: Config = { inputSource: 'storage_r' },\n  cases: CaseList\n) {\n  const cmpFloats =\n    cfg.cmpFloats !== undefined ? cfg.cmpFloats : (got: number, expect: number) => got === expect;\n\n  // If the 'vectorize' config option was provided, pack the cases into vectors.\n  if (cfg.vectorize !== undefined) {\n    const packed = packScalarsToVector(parameterTypes, returnType, cases, cfg.vectorize);\n    cases = packed.cases;\n    parameterTypes = packed.parameterTypes;\n    returnType = packed.returnType;\n  }\n\n  // The size of the input buffer may exceed the maximum buffer binding size,\n  // so chunk the tests up into batches that fit into the limits.\n  const casesPerBatch = (function () {\n    switch (cfg.inputSource) {\n      case 'const':\n        return 256; // Arbitrary limit, to ensure shaders aren't too large\n      case 'uniform':\n        return Math.floor(\n          t.device.limits.maxUniformBufferBindingSize / (parameterTypes.length * kValueStride)\n        );\n      case 'storage_r':\n      case 'storage_rw':\n        return Math.floor(\n          t.device.limits.maxStorageBufferBindingSize / (parameterTypes.length * kValueStride)\n        );\n    }\n  })();\n\n  // Submit all the batches, then check the results.\n  const checkResults: Array<() => void> = [];\n  for (let i = 0; i < cases.length; i += casesPerBatch) {\n    const batchCases = cases.slice(i, Math.min(i + casesPerBatch, cases.length));\n    const checkResult = submitBatch(\n      t,\n      expressionBuilder,\n      parameterTypes,\n      returnType,\n      batchCases,\n      cfg.inputSource,\n      cmpFloats\n    );\n    checkResults.push(checkResult);\n  }\n\n  checkResults.forEach(f => f());\n}\n\n/**\n * Submits the list of expression tests. The input data must fit within the\n * buffer binding limits of the given inputSource.\n * @param t the GPUTest\n * @param expressionBuilder the expression builder function\n * @param parameterTypes the list of expression parameter types\n * @param returnType the return type for the expression overload\n * @param cases list of test cases that fit within the binding limits of the device\n * @param inputSource the source of the input values\n * @param cmpFloats the method to compare floating point numbers\n * @returns a function that checks the results are as expected\n */\nfunction submitBatch(\n  t: GPUTest,\n  expressionBuilder: ExpressionBuilder,\n  parameterTypes: Array<Type>,\n  returnType: Type,\n  cases: CaseList,\n  inputSource: InputSource,\n  cmpFloats: FloatMatch\n): () => void {\n  // Construct a buffer to hold the results of the expression tests\n  const outputBufferSize = cases.length * kValueStride;\n  const outputBuffer = t.device.createBuffer({\n    size: outputBufferSize,\n    usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,\n  });\n\n  const [pipeline, group] = buildPipeline(\n    t,\n    expressionBuilder,\n    parameterTypes,\n    returnType,\n    cases,\n    inputSource,\n    outputBuffer\n  );\n  const encoder = t.device.createCommandEncoder();\n  const pass = encoder.beginComputePass();\n  pass.setPipeline(pipeline);\n  pass.setBindGroup(0, group);\n  pass.dispatchWorkgroups(1);\n  pass.end();\n\n  t.queue.submit([encoder.finish()]);\n\n  // Return a function that can check the results of the shader\n  return () => {\n    const checkExpectation = (outputData: Uint8Array) => {\n      // Read the outputs from the output buffer\n      const outputs = new Array<Value>(cases.length);\n      for (let i = 0; i < cases.length; i++) {\n        outputs[i] = returnType.read(outputData, i * kValueStride);\n      }\n\n      // The list of expectation failures\n      const errs: string[] = [];\n\n      // For each case...\n      for (let caseIdx = 0; caseIdx < cases.length; caseIdx++) {\n        const c = cases[caseIdx];\n        const got = outputs[caseIdx];\n        const cmp = toComparator(c.expected)(got, cmpFloats);\n        if (!cmp.matched) {\n          errs.push(`(${c.input instanceof Array ? c.input.join(', ') : c.input})\n    returned: ${cmp.got}\n    expected: ${cmp.expected}`);\n        }\n      }\n\n      return errs.length > 0 ? new Error(errs.join('\\n\\n')) : undefined;\n    };\n\n    t.expectGPUBufferValuesPassCheck(outputBuffer, checkExpectation, {\n      type: Uint8Array,\n      typedLength: outputBufferSize,\n    });\n  };\n}\n\n/**\n * @param v either an array of T or a single element of type T\n * @param i the value index to\n * @returns the i'th value of v, if v is an array, otherwise v (i must be 0)\n */\nfunction ith<T>(v: T | T[], i: number): T {\n  if (v instanceof Array) {\n    assert(i < v.length);\n    return v[i];\n  }\n  assert(i === 0);\n  return v;\n}\n\n/**\n * Constructs and returns a GPUComputePipeline and GPUBindGroup for running a\n * batch of test cases.\n * @param t the GPUTest\n * @param expressionBuilder the expression builder function\n * @param parameterTypes the list of expression parameter types\n * @param returnType the return type for the expression overload\n * @param cases list of test cases that fit within the binding limits of the device\n * @param inputSource the source of the input values\n * @param outputBuffer the buffer that will hold the output values of the tests\n */\nfunction buildPipeline(\n  t: GPUTest,\n  expressionBuilder: ExpressionBuilder,\n  parameterTypes: Array<Type>,\n  returnType: Type,\n  cases: CaseList,\n  inputSource: InputSource,\n  outputBuffer: GPUBuffer\n): [GPUComputePipeline, GPUBindGroup] {\n  // wgsl declaration of output buffer and binding\n  const wgslOutputs = `\nstruct Output {\n  @size(${kValueStride}) value : ${storageType(returnType)}\n};\n@group(0) @binding(0) var<storage, read_write> outputs : array<Output, ${cases.length}>;\n`;\n\n  switch (inputSource) {\n    case 'const': {\n      //////////////////////////////////////////////////////////////////////////\n      // Input values are constant values in the WGSL shader\n      //////////////////////////////////////////////////////////////////////////\n      const wgslCases = cases.map((c, caseIdx) => {\n        const args = parameterTypes.map((_, i) => `(${ith(c.input, i).wgsl()})`);\n        return `outputs[${caseIdx}].value = ${toStorage(returnType, expressionBuilder(args))};`;\n      });\n\n      // the full WGSL shader source\n      const source = `\n${wgslOutputs}\n\n@compute @workgroup_size(1)\nfn main() {\n  ${wgslCases.join('\\n   ')}\n}\n`;\n\n      // build the shader module\n      const module = t.device.createShaderModule({ code: source });\n\n      // build the pipeline\n      const pipeline = t.device.createComputePipeline({\n        layout: 'auto',\n        compute: { module, entryPoint: 'main' },\n      });\n\n      // build the bind group\n      const group = t.device.createBindGroup({\n        layout: pipeline.getBindGroupLayout(0),\n        entries: [{ binding: 0, resource: { buffer: outputBuffer } }],\n      });\n\n      return [pipeline, group];\n    }\n\n    case 'uniform':\n    case 'storage_r':\n    case 'storage_rw': {\n      //////////////////////////////////////////////////////////////////////////\n      // Input values come from a uniform or storage buffer\n      //////////////////////////////////////////////////////////////////////////\n\n      // returns the WGSL expression to load the ith parameter of the given type from the input buffer\n      const paramExpr = (ty: Type, i: number) => fromStorage(ty, `inputs[i].param${i}`);\n\n      // resolves to the expression that calls the builtin\n      const expr = toStorage(returnType, expressionBuilder(parameterTypes.map(paramExpr)));\n\n      // input binding var<...> declaration\n      const wgslInputVar = (function () {\n        switch (inputSource) {\n          case 'storage_r':\n            return 'var<storage, read>';\n          case 'storage_rw':\n            return 'var<storage, read_write>';\n          case 'uniform':\n            return 'var<uniform>';\n        }\n      })();\n\n      // the full WGSL shader source\n      const source = `\nstruct Input {\n${parameterTypes\n  .map((ty, i) => `  @size(${kValueStride}) param${i} : ${storageType(ty)},`)\n  .join('\\n')}\n};\n\n${wgslOutputs}\n\n@group(0) @binding(1)\n${wgslInputVar} inputs : array<Input, ${cases.length}>;\n\n@compute @workgroup_size(1)\nfn main() {\n  for(var i = 0; i < ${cases.length}; i++) {\n    outputs[i].value = ${expr};\n  }\n}\n`;\n\n      // size in bytes of the input buffer\n      const inputSize = cases.length * parameterTypes.length * kValueStride;\n\n      // Holds all the parameter values for all cases\n      const inputData = new Uint8Array(inputSize);\n\n      // Pack all the input parameter values into the inputData buffer\n      {\n        const caseStride = kValueStride * parameterTypes.length;\n        for (let caseIdx = 0; caseIdx < cases.length; caseIdx++) {\n          const caseBase = caseIdx * caseStride;\n          for (let paramIdx = 0; paramIdx < parameterTypes.length; paramIdx++) {\n            const offset = caseBase + paramIdx * kValueStride;\n            const params = cases[caseIdx].input;\n            if (params instanceof Array) {\n              params[paramIdx].copyTo(inputData, offset);\n            } else {\n              params.copyTo(inputData, offset);\n            }\n          }\n        }\n      }\n\n      // build the input buffer\n      const inputBuffer = t.makeBufferWithContents(\n        inputData,\n        GPUBufferUsage.COPY_SRC |\n          (inputSource === 'uniform' ? GPUBufferUsage.UNIFORM : GPUBufferUsage.STORAGE)\n      );\n\n      // build the shader module\n      const module = t.device.createShaderModule({ code: source });\n\n      // build the pipeline\n      const pipeline = t.device.createComputePipeline({\n        layout: 'auto',\n        compute: { module, entryPoint: 'main' },\n      });\n\n      // build the bind group\n      const group = t.device.createBindGroup({\n        layout: pipeline.getBindGroupLayout(0),\n        entries: [\n          { binding: 0, resource: { buffer: outputBuffer } },\n          { binding: 1, resource: { buffer: inputBuffer } },\n        ],\n      });\n\n      return [pipeline, group];\n    }\n  }\n}\n\n/**\n * Packs a list of scalar test cases into a smaller list of vector cases.\n * Requires that all parameters of the expression overload are of a scalar type,\n * and the return type of the expression overload is also a scalar type.\n * If `cases.length` is not a multiple of `vectorWidth`, then the last scalar\n * test case value is repeated to fill the vector value.\n */\nfunction packScalarsToVector(\n  parameterTypes: Array<Type>,\n  returnType: Type,\n  cases: CaseList,\n  vectorWidth: number\n): { cases: CaseList; parameterTypes: Array<Type>; returnType: Type } {\n  // Validate that the parameters and return type are all vectorizable\n  for (let i = 0; i < parameterTypes.length; i++) {\n    const ty = parameterTypes[i];\n    if (!(ty instanceof ScalarType)) {\n      throw new Error(\n        `packScalarsToVector() can only be used on scalar parameter types, but the ${i}'th parameter type is a ${ty}'`\n      );\n    }\n  }\n  if (!(returnType instanceof ScalarType)) {\n    throw new Error(\n      `packScalarsToVector() can only be used with a scalar return type, but the return type is a ${returnType}'`\n    );\n  }\n\n  const packedCases: Array<Case> = [];\n  const packedParameterTypes = parameterTypes.map(p => TypeVec(vectorWidth, p as ScalarType));\n  const packedReturnType = new VectorType(vectorWidth, returnType);\n\n  const clampCaseIdx = (idx: number) => Math.min(idx, cases.length - 1);\n\n  let caseIdx = 0;\n  while (caseIdx < cases.length) {\n    // Construct the vectorized inputs from the scalar cases\n    const packedInputs = new Array<Vector>(parameterTypes.length);\n    for (let paramIdx = 0; paramIdx < parameterTypes.length; paramIdx++) {\n      const inputElements = new Array<Scalar>(vectorWidth);\n      for (let i = 0; i < vectorWidth; i++) {\n        const input = cases[clampCaseIdx(caseIdx + i)].input;\n        inputElements[i] = (input instanceof Array ? input[paramIdx] : input) as Scalar;\n      }\n      packedInputs[paramIdx] = new Vector(inputElements);\n    }\n\n    // Gather the comparators for the packed cases\n    const comparators = new Array<Comparator>(vectorWidth);\n    for (let i = 0; i < vectorWidth; i++) {\n      comparators[i] = toComparator(cases[clampCaseIdx(caseIdx + i)].expected);\n    }\n    const packedComparator = (got: Value, cmpFloats: FloatMatch) => {\n      let matched = true;\n      const gElements = new Array<string>(vectorWidth);\n      const eElements = new Array<string>(vectorWidth);\n      for (let i = 0; i < vectorWidth; i++) {\n        const d = comparators[i]((got as Vector).elements[i], cmpFloats);\n        matched = matched && d.matched;\n        gElements[i] = d.got;\n        eElements[i] = d.expected;\n      }\n      return {\n        matched,\n        got: `${packedReturnType}(${gElements.join(', ')})`,\n        expected: `${packedReturnType}(${eElements.join(', ')})`,\n      };\n    };\n\n    // Append the new packed case\n    packedCases.push({ input: packedInputs, expected: packedComparator });\n    caseIdx += vectorWidth;\n  }\n\n  return {\n    cases: packedCases,\n    parameterTypes: packedParameterTypes,\n    returnType: packedReturnType,\n  };\n}\n\n/** @returns a set of flushed and non-flushed floating point results for a given number. */\nfunction calculateFlushedResults(value: number): Array<Scalar> {\n  return [f64(value), f64(flushSubnormalNumber(value))];\n}\n\n/**\n * Generates a Case for the param and unary op provide.\n * The Case will use either exact matching or the test level Comparator.\n * @param param the parameter to pass into the operation\n * @param op callback that implements the truth function for the unary operation\n */\nexport function makeUnaryF32Case(param: number, op: (p: number) => number): Case {\n  const f32_param = quantizeToF32(param);\n  const is_param_subnormal = isSubnormalNumber(f32_param);\n  const expected = calculateFlushedResults(op(f32_param));\n  if (is_param_subnormal) {\n    calculateFlushedResults(op(0)).forEach(value => {\n      expected.push(value);\n    });\n  }\n  return { input: [f32(param)], expected: anyOf(...expected) };\n}\n\n/**\n * Generates a Case for the params and binary op provide.\n * The Case will use either exact matching or the test level Comparator.\n * @param param0 the first param or left hand side to pass into the binary operation\n * @param param1 the second param or rhs hand side to pass into the binary operation\n * @param op callback that implements the truth function for the binary operation\n * @param skip_param1_zero_flush should the builder skip cases where the param1 would be flushed to 0,\n *                               this is to avoid performing division by 0, other invalid operations.\n *                               The caller is responsible for making sure the initial param1 isn't 0.\n */\nexport function makeBinaryF32Case(\n  param0: number,\n  param1: number,\n  op: (p0: number, p1: number) => number,\n  skip_param1_zero_flush: boolean = false\n): Case {\n  const f32_param0 = quantizeToF32(param0);\n  const f32_param1 = quantizeToF32(param1);\n  const is_param0_subnormal = isSubnormalNumber(f32_param0);\n  const is_param1_subnormal = isSubnormalNumber(f32_param1);\n  const expected = calculateFlushedResults(op(f32_param0, f32_param1));\n  if (is_param0_subnormal) {\n    calculateFlushedResults(op(0, f32_param1)).forEach(value => {\n      expected.push(value);\n    });\n  }\n  if (!skip_param1_zero_flush && is_param1_subnormal) {\n    calculateFlushedResults(op(f32_param0, 0)).forEach(value => {\n      expected.push(value);\n    });\n  }\n  if (!skip_param1_zero_flush && is_param0_subnormal && is_param1_subnormal) {\n    calculateFlushedResults(op(0, 0)).forEach(value => {\n      expected.push(value);\n    });\n  }\n\n  return { input: [f32(param0), f32(param1)], expected: anyOf(...expected) };\n}\n\n/**\n * Generates a Case for the param and unary interval generator provided.\n * The Case will use use an interval comparator for matching results.\n * @param param the param to pass into the unary operation\n * @param ops callbacks that implement generating an acceptance interval for a unary operation\n */\nexport function makeUnaryF32IntervalCase(param: number, ...ops: PointToInterval[]): Case {\n  param = quantizeToF32(param);\n  const intervals: Array<F32Interval> = new Array<F32Interval>();\n  for (const op of ops) {\n    intervals.push(op(param));\n  }\n  return { input: [f32(param)], expected: intervalComparator(...intervals) };\n}\n\n/**\n * Generates a Case for the params and binary interval generator provided.\n * The Case will use use an interval comparator for matching results.\n * @param param0 the first param or left hand side to pass into the binary operation\n * @param param1 the second param or rhs hand side to pass into the binary operation\n * @param ops callbacks that implement generating an acceptance interval for a binary operation\n */\nexport function makeBinaryF32IntervalCase(\n  param0: number,\n  param1: number,\n  ...ops: BinaryToInterval[]\n): Case {\n  param0 = quantizeToF32(param0);\n  param1 = quantizeToF32(param1);\n  const intervals: Array<F32Interval> = new Array<F32Interval>();\n  for (const op of ops) {\n    intervals.push(op(param0, param1));\n  }\n  return { input: [f32(param0), f32(param1)], expected: intervalComparator(...intervals) };\n}\n\n/**\n * Generates a Case for the params and ternary interval generator provided.\n * The Case will use use an interval comparator for matching results.\n * @param param0 the first param to pass into the ternary operation\n * @param param1 the second param to pass into the ternary operation\n * @param param2 the third param to pass into the ternary operation\n * @param ops callbacks that implement generating an acceptance interval for a\n *           ternary operation.\n */\nexport function makeTernaryF32IntervalCase(\n  param0: number,\n  param1: number,\n  param2: number,\n  ...ops: TernaryToInterval[]\n): Case {\n  param0 = quantizeToF32(param0);\n  param1 = quantizeToF32(param1);\n  param2 = quantizeToF32(param2);\n  const intervals: Array<F32Interval> = new Array<F32Interval>();\n  for (const op of ops) {\n    intervals.push(op(param0, param1, param2));\n  }\n  return {\n    input: [f32(param0), f32(param1), f32(param2)],\n    expected: intervalComparator(...intervals),\n  };\n}\n"],"file":"expression.js"}
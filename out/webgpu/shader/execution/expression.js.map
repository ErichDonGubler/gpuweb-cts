{"version":3,"sources":["../../../../src/webgpu/shader/execution/expression.ts"],"names":["compare","ScalarType","TypeVec","TypeU32","Vector","VectorType","toComparator","input","type","undefined","got","cmpFloats","storageType","ty","kind","width","elementType","fromStorage","expr","toStorage","kValueStride","builtin","name","values","join","run","t","expressionBuilder","parameterTypes","returnType","cfg","storageClass","cases","expect","vectorize","packed","packScalarsToVector","maxInputSize","device","limits","maxUniformBufferBindingSize","maxStorageBufferBindingSize","casesPerBatch","Math","floor","length","i","batchCases","slice","min","runBatch","paramExpr","map","storage","source","inputSize","inputData","Uint8Array","caseStride","caseIdx","caseBase","paramIdx","offset","params","Array","copyTo","inputBuffer","makeBufferWithContents","GPUBufferUsage","COPY_SRC","UNIFORM","STORAGE","outputBufferSize","outputBuffer","createBuffer","size","usage","COPY_DST","module","createShaderModule","code","pipeline","createComputePipeline","compute","entryPoint","group","createBindGroup","layout","getBindGroupLayout","entries","binding","resource","buffer","encoder","createCommandEncoder","pass","beginComputePass","setPipeline","setBindGroup","dispatch","end","queue","submit","finish","checkExpectation","outputData","outputs","read","errs","c","cmp","expected","matched","push","Error","expectGPUBufferValuesPassCheck","typedLength","vectorWidth","packedCases","packedParameterTypes","p","packedReturnType","clampCaseIdx","idx","packedInputs","inputElements","comparators","packedComparator","gElements","eElements","d","elements"],"mappings":"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","sourcesContent":["import { GPUTest } from '../../gpu_test.js';\nimport { compare, Comparator, FloatMatch } from '../../util/compare.js';\nimport {\n  ScalarType,\n  Scalar,\n  Type,\n  TypeVec,\n  TypeU32,\n  Value,\n  Vector,\n  VectorType,\n} from '../../util/conversion.js';\n\n// Helper for converting Values to Comparators.\nfunction toComparator(input: Value | Comparator): Comparator {\n  if ((input as Value).type !== undefined) {\n    return (got, cmpFloats) => compare(got, input as Value, cmpFloats);\n  }\n  return input as Comparator;\n}\n\n/** Case is a single expression test case. */\nexport type Case = {\n  // The input value(s)\n  input: Value | Array<Value>;\n  // The expected value, or comparator\n  expected: Value | Comparator;\n};\n\n/** CaseList is a list of Cases */\nexport type CaseList = Array<Case>;\n\n/** The storage class to use on test input buffers */\nexport type StorageClass = 'uniform' | 'storage_r' | 'storage_rw';\n\n/** Configuration for running a expression test */\nexport type Config = {\n  // Where the input values are read from\n  storageClass: StorageClass;\n  // If defined, scalar test cases will be packed into vectors of the given\n  // width, which must be 2, 3 or 4.\n  // Requires that all parameters of the expression overload are of a scalar\n  // type, and the return type of the expression overload is also a scalar type.\n  // If the number of test cases is not a multiple of the vector width, then the\n  // last scalar value is repeated to fill the last vector value.\n  vectorize?: number;\n  // The FloatMatch to use when comparing floating point numbers.\n  // If undefined, floating point numbers must match exactly.\n  cmpFloats?: FloatMatch;\n};\n\n// Helper for returning the WGSL storage type for the given Type.\nfunction storageType(ty: Type): Type {\n  if (ty instanceof ScalarType) {\n    if (ty.kind === 'bool') {\n      return TypeU32;\n    }\n  }\n  if (ty instanceof VectorType) {\n    return TypeVec(ty.width, storageType(ty.elementType) as ScalarType);\n  }\n  return ty;\n}\n\n// Helper for converting a value of the type 'ty' from the storage type.\nfunction fromStorage(ty: Type, expr: string): string {\n  if (ty instanceof ScalarType) {\n    if (ty.kind === 'bool') {\n      return `${expr} != 0u`;\n    }\n  }\n  if (ty instanceof VectorType) {\n    if (ty.elementType.kind === 'bool') {\n      return `${expr} != vec${ty.width}<u32>(0u)`;\n    }\n  }\n  return expr;\n}\n\n// Helper for converting a value of the type 'ty' to the storage type.\nfunction toStorage(ty: Type, expr: string): string {\n  if (ty instanceof ScalarType) {\n    if (ty.kind === 'bool') {\n      return `select(0u, 1u, ${expr})`;\n    }\n  }\n  if (ty instanceof VectorType) {\n    if (ty.elementType.kind === 'bool') {\n      return `select(vec${ty.width}<u32>(0u), vec${ty.width}<u32>(1u), ${expr})`;\n    }\n  }\n  return expr;\n}\n\n// Currently all values are packed into buffers of 16 byte strides\nconst kValueStride = 16;\n\n// ExpressionBuilder returns the WGSL used to test an expression.\nexport interface ExpressionBuilder {\n  (values: Array<string>): string;\n}\n\n/* @returns an ExpressionBuilder that calls the builtin with the given name */\nexport function builtin(name: string): ExpressionBuilder {\n  return values => `${name}(${values.join(', ')})`;\n}\n\n/**\n * Runs the list of expression tests, possibly splitting the tests into multiple\n * dispatches to keep the input data within the buffer binding limits.\n * run() will pack the scalar test cases into smaller set of vectorized tests\n * if `cfg.vectorize` is defined.\n * @param t the GPUTest\n * @param expressionBuilder the expression builder function\n * @param parameterTypes the list of expression parameter types\n * @param returnType the return type for the expression overload\n * @param cfg test configuration values\n * @param cases list of test cases\n */\nexport function run(\n  t: GPUTest,\n  expressionBuilder: ExpressionBuilder,\n  parameterTypes: Array<Type>,\n  returnType: Type,\n  cfg: Config = { storageClass: 'storage_r' },\n  cases: CaseList\n) {\n  const cmpFloats =\n    cfg.cmpFloats !== undefined ? cfg.cmpFloats : (got: number, expect: number) => got === expect;\n\n  // If the 'vectorize' config option was provided, pack the cases into vectors.\n  if (cfg.vectorize !== undefined) {\n    const packed = packScalarsToVector(parameterTypes, returnType, cases, cfg.vectorize);\n    cases = packed.cases;\n    parameterTypes = packed.parameterTypes;\n    returnType = packed.returnType;\n  }\n\n  // The size of the input buffer max exceed the maximum buffer binding size,\n  // so chunk the tests up into batches that fit into the limits.\n  const maxInputSize =\n    cfg.storageClass === 'uniform'\n      ? t.device.limits.maxUniformBufferBindingSize\n      : t.device.limits.maxStorageBufferBindingSize;\n  const casesPerBatch = Math.floor(maxInputSize / (parameterTypes.length * kValueStride));\n  for (let i = 0; i < cases.length; i += casesPerBatch) {\n    const batchCases = cases.slice(i, Math.min(i + casesPerBatch, cases.length));\n    runBatch(\n      t,\n      expressionBuilder,\n      parameterTypes,\n      returnType,\n      batchCases,\n      cfg.storageClass,\n      cmpFloats\n    );\n  }\n}\n\n/**\n * Runs the list of expression tests. The input data must fit within the buffer\n * binding limits of the given storageClass.\n * @param t the GPUTest\n * @param expressionBuilder the expression builder function\n * @param parameterTypes the list of expression parameter types\n * @param returnType the return type for the expression overload\n * @param cases list of test cases that fit within the binding limits of the device\n * @param storageClass the storage class to use for the input buffer\n * @param cmpFloats the method to compare floating point numbers\n */\nfunction runBatch(\n  t: GPUTest,\n  expressionBuilder: ExpressionBuilder,\n  parameterTypes: Array<Type>,\n  returnType: Type,\n  cases: CaseList,\n  storageClass: StorageClass,\n  cmpFloats: FloatMatch\n) {\n  // returns the WGSL expression to load the ith parameter of the given type from the input buffer\n  const paramExpr = (ty: Type, i: number) => fromStorage(ty, `inputs[i].param${i}`);\n\n  // resolves to the expression that calls the builtin\n  const expr = toStorage(returnType, expressionBuilder(parameterTypes.map(paramExpr)));\n\n  const storage = storageClass === 'storage_r' ? 'read' : 'read_write';\n\n  // the full WGSL shader source\n  const source = `\nstruct Input {\n${parameterTypes\n  .map((ty, i) => `  @size(${kValueStride}) param${i} : ${storageType(ty)};`)\n  .join('\\n')}\n};\n\nstruct Output {\n  @size(${kValueStride}) value : ${storageType(returnType)};\n};\n\n@group(0) @binding(0)\n${\n  storageClass === 'uniform'\n    ? `var<uniform> inputs : array<Input, ${cases.length}>;`\n    : `var<storage, ${storage}> inputs : array<Input, ${cases.length}>;`\n}\n@group(0) @binding(1) var<storage, write> outputs : array<Output, ${cases.length}>;\n\n@stage(compute) @workgroup_size(1)\nfn main() {\n  for(var i = 0; i < ${cases.length}; i = i + 1) {\n    outputs[i].value = ${expr};\n  }\n}\n`;\n  const inputSize = cases.length * parameterTypes.length * kValueStride;\n\n  // Holds all the parameter values for all cases\n  const inputData = new Uint8Array(inputSize);\n\n  // Pack all the input parameter values into the inputData buffer\n  {\n    const caseStride = kValueStride * parameterTypes.length;\n    for (let caseIdx = 0; caseIdx < cases.length; caseIdx++) {\n      const caseBase = caseIdx * caseStride;\n      for (let paramIdx = 0; paramIdx < parameterTypes.length; paramIdx++) {\n        const offset = caseBase + paramIdx * kValueStride;\n        const params = cases[caseIdx].input;\n        if (params instanceof Array) {\n          params[paramIdx].copyTo(inputData, offset);\n        } else {\n          params.copyTo(inputData, offset);\n        }\n      }\n    }\n  }\n  const inputBuffer = t.makeBufferWithContents(\n    inputData,\n    GPUBufferUsage.COPY_SRC |\n      (storageClass === 'uniform' ? GPUBufferUsage.UNIFORM : GPUBufferUsage.STORAGE)\n  );\n\n  // Construct a buffer to hold the results of the expression tests\n  const outputBufferSize = cases.length * kValueStride;\n  const outputBuffer = t.device.createBuffer({\n    size: outputBufferSize,\n    usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,\n  });\n\n  const module = t.device.createShaderModule({ code: source });\n  const pipeline = t.device.createComputePipeline({\n    compute: { module, entryPoint: 'main' },\n  });\n\n  const group = t.device.createBindGroup({\n    layout: pipeline.getBindGroupLayout(0),\n    entries: [\n      { binding: 0, resource: { buffer: inputBuffer } },\n      { binding: 1, resource: { buffer: outputBuffer } },\n    ],\n  });\n\n  const encoder = t.device.createCommandEncoder();\n  const pass = encoder.beginComputePass();\n  pass.setPipeline(pipeline);\n  pass.setBindGroup(0, group);\n  pass.dispatch(1);\n  pass.end();\n\n  t.queue.submit([encoder.finish()]);\n\n  const checkExpectation = (outputData: Uint8Array) => {\n    // Read the outputs from the output buffer\n    const outputs = new Array<Value>(cases.length);\n    for (let i = 0; i < cases.length; i++) {\n      outputs[i] = returnType.read(outputData, i * kValueStride);\n    }\n\n    // The list of expectation failures\n    const errs: string[] = [];\n\n    // For each case...\n    for (let caseIdx = 0; caseIdx < cases.length; caseIdx++) {\n      const c = cases[caseIdx];\n      const got = outputs[caseIdx];\n      const cmp = toComparator(c.expected)(got, cmpFloats);\n      if (!cmp.matched) {\n        errs.push(`(${c.input instanceof Array ? c.input.join(', ') : c.input})\n    returned: ${cmp.got}\n    expected: ${cmp.expected}`);\n      }\n    }\n\n    return errs.length > 0 ? new Error(errs.join('\\n\\n')) : undefined;\n  };\n\n  t.expectGPUBufferValuesPassCheck(outputBuffer, checkExpectation, {\n    type: Uint8Array,\n    typedLength: outputBufferSize,\n  });\n}\n\n/**\n * Packs a list of scalar test cases into a smaller list of vector cases.\n * Requires that all parameters of the expression overload are of a scalar type,\n * and the return type of the expression overload is also a scalar type.\n * If `cases.length` is not a multiple of `vectorWidth`, then the last scalar\n * test case value is repeated to fill the vector value.\n */\nfunction packScalarsToVector(\n  parameterTypes: Array<Type>,\n  returnType: Type,\n  cases: CaseList,\n  vectorWidth: number\n): { cases: CaseList; parameterTypes: Array<Type>; returnType: Type } {\n  // Validate that the parameters and return type are all vectorizable\n  for (let i = 0; i < parameterTypes.length; i++) {\n    const ty = parameterTypes[i];\n    if (!(ty instanceof ScalarType)) {\n      throw new Error(\n        `packScalarsToVector() can only be used on scalar parameter types, but the ${i}'th parameter type is a ${ty}'`\n      );\n    }\n  }\n  if (!(returnType instanceof ScalarType)) {\n    throw new Error(\n      `packScalarsToVector() can only be used with a scalar return type, but the return type is a ${returnType}'`\n    );\n  }\n\n  const packedCases: Array<Case> = [];\n  const packedParameterTypes = parameterTypes.map(p => TypeVec(vectorWidth, p as ScalarType));\n  const packedReturnType = new VectorType(vectorWidth, returnType as ScalarType);\n\n  const clampCaseIdx = (idx: number) => Math.min(idx, cases.length - 1);\n\n  let caseIdx = 0;\n  while (caseIdx < cases.length) {\n    // Construct the vectorized inputs from the scalar cases\n    const packedInputs = new Array<Vector>(parameterTypes.length);\n    for (let paramIdx = 0; paramIdx < parameterTypes.length; paramIdx++) {\n      const inputElements = new Array<Scalar>(vectorWidth);\n      for (let i = 0; i < vectorWidth; i++) {\n        const input = cases[clampCaseIdx(caseIdx + i)].input;\n        inputElements[i] = (input instanceof Array ? input[paramIdx] : input) as Scalar;\n      }\n      packedInputs[paramIdx] = new Vector(inputElements);\n    }\n\n    // Gather the comparators for the packed cases\n    const comparators = new Array<Comparator>(vectorWidth);\n    for (let i = 0; i < vectorWidth; i++) {\n      comparators[i] = toComparator(cases[clampCaseIdx(caseIdx + i)].expected);\n    }\n    const packedComparator = (got: Value, cmpFloats: FloatMatch) => {\n      let matched = true;\n      const gElements = new Array<string>(vectorWidth);\n      const eElements = new Array<string>(vectorWidth);\n      for (let i = 0; i < vectorWidth; i++) {\n        const d = comparators[i]((got as Vector).elements[i], cmpFloats);\n        matched = matched && d.matched;\n        gElements[i] = d.got;\n        eElements[i] = d.expected;\n      }\n      return {\n        matched,\n        got: `${packedReturnType}(${gElements.join(', ')})`,\n        expected: `${packedReturnType}(${eElements.join(', ')})`,\n      };\n    };\n\n    // Append the new packed case\n    packedCases.push({ input: packedInputs, expected: packedComparator });\n    caseIdx += vectorWidth;\n  }\n\n  return {\n    cases: packedCases,\n    parameterTypes: packedParameterTypes,\n    returnType: packedReturnType,\n  };\n}\n"],"file":"expression.js"}
{"version":3,"sources":["../../../src/webgpu/web_platform/util.ts"],"names":["SkipTestCase","assert","ErrorWithExtra","raceWithRejectOnTimeout","startPlayingAndWaitForVideo","video","callback","Promise","resolve","reject","callbackAndResolve","ex","error","message","addEventListener","event","requestVideoFrameCallback","timeWatcher","currentTime","requestAnimationFrame","loop","muted","preload","play","catch","waitForNextFrame","promise","videoCallbackHelper","getVideoFrameFromVideoElement","test","captureStream","undefined","skip","track","getVideoTracks","reader","MediaStreamTrackProcessor","readable","getReader","videoFrame","read","value","timeoutMessage","promiseWithoutTimeout"],"mappings":"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","sourcesContent":["import { Fixture, SkipTestCase } from '../../common/framework/fixture.js';\nimport { assert, ErrorWithExtra, raceWithRejectOnTimeout } from '../../common/util/util.js';\n\ndeclare global {\n  interface HTMLMediaElement {\n    // Add captureStream() support for HTMLMediaElement from\n    // https://w3c.github.io/mediacapture-fromelement/#dom-htmlmediaelement-capturestream\n    captureStream(): MediaStream;\n  }\n\n  interface HTMLVideoElement {\n    requestVideoFrameCallback(\n      callback: (now: DOMHighResTimeStamp, metadata: unknown) => void\n    ): number;\n  }\n}\n\n/**\n * Starts playing a video and waits for it to be consumable.\n * Returns a promise which resolves after `callback` (which may be async) completes.\n *\n * @param video An HTML5 Video element.\n * @param callback Function to call when video is ready.\n *\n * Adapted from https://github.com/KhronosGroup/WebGL/blob/main/sdk/tests/js/webgl-test-utils.js\n */\nexport function startPlayingAndWaitForVideo(\n  video: HTMLVideoElement,\n  callback: () => unknown | Promise<unknown>\n): Promise<void> {\n  return raceWithRejectOnTimeout(\n    new Promise((resolve, reject) => {\n      const callbackAndResolve = () =>\n        void (async () => {\n          try {\n            await callback();\n            resolve();\n          } catch (ex) {\n            reject();\n          }\n        })();\n      if (video.error) {\n        reject(\n          new ErrorWithExtra('Video.error: ' + video.error.message, () => ({ error: video.error }))\n        );\n        return;\n      }\n\n      video.addEventListener(\n        'error',\n        event => reject(new ErrorWithExtra('Video received \"error\" event', () => ({ event }))),\n        true\n      );\n\n      if ('requestVideoFrameCallback' in video) {\n        video.requestVideoFrameCallback(() => {\n          callbackAndResolve();\n        });\n      } else {\n        // If requestVideoFrameCallback isn't available, check each frame if the video has advanced.\n        const timeWatcher = () => {\n          if (video.currentTime > 0) {\n            callbackAndResolve();\n          } else {\n            requestAnimationFrame(timeWatcher);\n          }\n        };\n        timeWatcher();\n      }\n\n      video.loop = true;\n      video.muted = true;\n      video.preload = 'auto';\n      video.play().catch(reject);\n    }),\n    2000,\n    'Video never became ready'\n  );\n}\n\n/**\n * Fire a `callback` when the video reaches a new frame.\n * Returns a promise which resolves after `callback` (which may be async) completes.\n *\n * MAINTENANCE_TODO: Find a way to implement this for browsers without requestVideoFrameCallback as\n * well, similar to the timeWatcher path in startPlayingAndWaitForVideo. If that path is proven to\n * work well, we can consider getting rid of the requestVideoFrameCallback path.\n */\nexport function waitForNextFrame(\n  video: HTMLVideoElement,\n  callback: () => unknown | Promise<unknown>\n): Promise<void> {\n  const { promise, callbackAndResolve } = videoCallbackHelper(\n    callback,\n    'waitForNextFrame timed out'\n  );\n\n  if ('requestVideoFrameCallback' in video) {\n    video.requestVideoFrameCallback(() => {\n      callbackAndResolve();\n    });\n  } else {\n    throw new SkipTestCase('waitForNextFrame currently requires requestVideoFrameCallback');\n  }\n\n  return promise;\n}\n\nexport async function getVideoFrameFromVideoElement(\n  test: Fixture,\n  video: HTMLVideoElement\n): Promise<VideoFrame> {\n  if (video.captureStream === undefined) {\n    test.skip('HTMLVideoElement.captureStream is not supported');\n  }\n\n  const track: MediaStreamVideoTrack = video.captureStream().getVideoTracks()[0];\n  const reader = new MediaStreamTrackProcessor({ track }).readable.getReader();\n  const videoFrame = (await reader.read()).value;\n  assert(videoFrame !== undefined, 'unable to get a VideoFrame from track 0');\n  return videoFrame;\n}\n\n/**\n * Helper for doing something inside of a (possibly async) callback (directly, not in a following\n * microtask), and returning a promise when the callback is done.\n * MAINTENANCE_TODO: Use this in startPlayingAndWaitForVideo (and make sure it works).\n */\nfunction videoCallbackHelper(\n  callback: () => unknown | Promise<unknown>,\n  timeoutMessage: string\n): { promise: Promise<void>; callbackAndResolve: () => void } {\n  let callbackAndResolve: () => void;\n\n  const promiseWithoutTimeout = new Promise<void>((resolve, reject) => {\n    callbackAndResolve = () =>\n      void (async () => {\n        try {\n          await callback(); // catches both exceptions and rejections\n          resolve();\n        } catch (ex) {\n          reject(ex);\n        }\n      })();\n  });\n  const promise = raceWithRejectOnTimeout(promiseWithoutTimeout, 2000, timeoutMessage);\n  return { promise, callbackAndResolve: callbackAndResolve! };\n}\n"],"file":"util.js"}
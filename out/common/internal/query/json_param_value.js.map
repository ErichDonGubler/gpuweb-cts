{"version":3,"sources":["../../../../src/common/internal/query/json_param_value.ts"],"names":["assert","sortObjectByKey","jsUndefinedMagicValue","jsNaNMagicValue","jsPositiveInfinityMagicValue","jsNegativeInfinityMagicValue","toStringMagicValue","Map","undefined","NaN","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","fromStringMagicValue","jsNegativeZeroMagicValue","stringifyFilter","k","v","has","Object","is","get","stringifyParamValue","value","JSON","stringify","stringifyParamValueUniquely","parseParamValueReviver","parseParamValue","s","parse"],"mappings":";AAAA;AACA,GADA,SAASA,MAAT,EAAiBC,eAAjB,QAAwC,oBAAxC;AAGA;AACA;AACA,MAAMC,qBAAqB,GAAG,SAA9B;AACA,MAAMC,eAAe,GAAG,OAAxB;AACA,MAAMC,4BAA4B,GAAG,eAArC;AACA,MAAMC,4BAA4B,GAAG,eAArC;;AAEA,MAAMC,kBAAkB,GAAG,IAAIC,GAAJ,CAAyB;AAClD,CAACC,SAAD,EAAYN,qBAAZ,CADkD;AAElD,CAACO,GAAD,EAAMN,eAAN,CAFkD;AAGlD,CAACO,MAAM,CAACC,iBAAR,EAA2BP,4BAA3B,CAHkD;AAIlD,CAACM,MAAM,CAACE,iBAAR,EAA2BP,4BAA3B,CAJkD,CAAzB,CAA3B;;;AAOA,MAAMQ,oBAAoB,GAAG,IAAIN,GAAJ,CAAyB;AACpD,CAACL,qBAAD,EAAwBM,SAAxB,CADoD;AAEpD,CAACL,eAAD,EAAkBM,GAAlB,CAFoD;AAGpD,CAACL,4BAAD,EAA+BM,MAAM,CAACC,iBAAtC,CAHoD;AAIpD,CAACN,4BAAD,EAA+BK,MAAM,CAACE,iBAAtC,CAJoD,CAAzB,CAA7B;;;AAOA;AACA;AACA;AACA,MAAME,wBAAwB,GAAG,WAAjC;;AAEA,SAASC,eAAT,CAAyBC,CAAzB,EAAoCC,CAApC,EAAyD;AACvD;AACA,MAAI,OAAOA,CAAP,KAAa,QAAjB,EAA2B;AACzBjB,IAAAA,MAAM;AACJ,KAACa,oBAAoB,CAACK,GAArB,CAAyBD,CAAzB,CADG;AAEH,OAAEA,CAAE,0DAFD,CAAN;;;AAKAjB,IAAAA,MAAM;AACJiB,IAAAA,CAAC,KAAKH,wBADF;AAEH,OAAEG,CAAE,0DAFD,CAAN;;AAID;;AAED,MAAIE,MAAM,CAACC,EAAP,CAAUH,CAAV,EAAa,CAAC,CAAd,CAAJ,EAAsB;AACpB,WAAOH,wBAAP;AACD;;AAED,SAAOR,kBAAkB,CAACY,GAAnB,CAAuBD,CAAvB,IAA4BX,kBAAkB,CAACe,GAAnB,CAAuBJ,CAAvB,CAA5B,GAAwDA,CAA/D;AACD;;AAED,OAAO,SAASK,mBAAT,CAA6BC,KAA7B,EAA+D;AACpE,SAAOC,IAAI,CAACC,SAAL,CAAeF,KAAf,EAAsBR,eAAtB,CAAP;AACD;;AAED;AACA;AACA;AACA,OAAO,SAASW,2BAAT,CAAqCH,KAArC,EAAuE;AAC5E,SAAOC,IAAI,CAACC,SAAL,CAAeF,KAAf,EAAsB,CAACP,CAAD,EAAIC,CAAJ,KAAU;AACrC,QAAI,OAAOA,CAAP,KAAa,QAAb,IAAyBA,CAAC,KAAK,IAAnC,EAAyC;AACvC,aAAOhB,eAAe,CAACgB,CAAD,CAAtB;AACD;;AAED,WAAOF,eAAe,CAACC,CAAD,EAAIC,CAAJ,CAAtB;AACD,GANM,CAAP;AAOD;;AAED;;AAEA,SAASU,sBAAT,CAAgCX,CAAhC,EAA2CC,CAA3C,EAAwD;AACtD,MAAID,CAAC,KAAKF,wBAAV,EAAoC;AAClC,WAAO,CAAC,CAAR;AACD;;AAED,MAAID,oBAAoB,CAACK,GAArB,CAAyBF,CAAzB,CAAJ,EAAiC;AAC/B,WAAOH,oBAAoB,CAACQ,GAArB,CAAyBL,CAAzB,CAAP;AACD;;AAED,SAAOC,CAAP;AACD;;AAED,OAAO,SAASW,eAAT,CAAyBC,CAAzB,EAAuD;AAC5D,SAAOL,IAAI,CAACM,KAAL,CAAWD,CAAX,EAAcF,sBAAd,CAAP;AACD","sourcesContent":["import { assert, sortObjectByKey } from '../../util/util.js';\nimport { JSONWithUndefined } from '../params_utils.js';\n\n// JSON can't represent various values and by default stores them as `null`.\n// Instead, storing them as a magic string values in JSON.\nconst jsUndefinedMagicValue = '_undef_';\nconst jsNaNMagicValue = '_nan_';\nconst jsPositiveInfinityMagicValue = '_posinfinity_';\nconst jsNegativeInfinityMagicValue = '_neginfinity_';\n\nconst toStringMagicValue = new Map<unknown, string>([\n  [undefined, jsUndefinedMagicValue],\n  [NaN, jsNaNMagicValue],\n  [Number.POSITIVE_INFINITY, jsPositiveInfinityMagicValue],\n  [Number.NEGATIVE_INFINITY, jsNegativeInfinityMagicValue],\n]);\n\nconst fromStringMagicValue = new Map<string, unknown>([\n  [jsUndefinedMagicValue, undefined],\n  [jsNaNMagicValue, NaN],\n  [jsPositiveInfinityMagicValue, Number.POSITIVE_INFINITY],\n  [jsNegativeInfinityMagicValue, Number.NEGATIVE_INFINITY],\n]);\n\n// -0 needs to be handled separately, because -0 === +0 returns true. Not\n// special casing +0/0, since it behaves intuitively. Assuming that if -0 is\n// being used, the differentiation from +0 is desired.\nconst jsNegativeZeroMagicValue = '_negzero_';\n\nfunction stringifyFilter(k: string, v: unknown): unknown {\n  // Make sure no one actually uses a magic value as a parameter.\n  if (typeof v === 'string') {\n    assert(\n      !fromStringMagicValue.has(v),\n      `${v} is a magic value for stringification, so cannot be used`\n    );\n\n    assert(\n      v !== jsNegativeZeroMagicValue,\n      `${v} is a magic value for stringification, so cannot be used`\n    );\n  }\n\n  if (Object.is(v, -0)) {\n    return jsNegativeZeroMagicValue;\n  }\n\n  return toStringMagicValue.has(v) ? toStringMagicValue.get(v) : v;\n}\n\nexport function stringifyParamValue(value: JSONWithUndefined): string {\n  return JSON.stringify(value, stringifyFilter);\n}\n\n/**\n * Like stringifyParamValue but sorts dictionaries by key, for hashing.\n */\nexport function stringifyParamValueUniquely(value: JSONWithUndefined): string {\n  return JSON.stringify(value, (k, v) => {\n    if (typeof v === 'object' && v !== null) {\n      return sortObjectByKey(v);\n    }\n\n    return stringifyFilter(k, v);\n  });\n}\n\n// 'any' is part of the JSON.parse reviver interface, so cannot be avoided.\n// eslint-disable-next-line  @typescript-eslint/no-explicit-any\nfunction parseParamValueReviver(k: string, v: any): any {\n  if (k === jsNegativeZeroMagicValue) {\n    return -0;\n  }\n\n  if (fromStringMagicValue.has(k)) {\n    return fromStringMagicValue.get(k);\n  }\n\n  return v;\n}\n\nexport function parseParamValue(s: string): JSONWithUndefined {\n  return JSON.parse(s, parseParamValueReviver);\n}\n"],"file":"json_param_value.js"}